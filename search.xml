<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试寄录</title>
      <link href="/2024/10/10/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%AF%84%E5%BD%95/"/>
      <url>/2024/10/10/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%AF%84%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="01–库感智能"><a href="#01–库感智能" class="headerlink" title="01–库感智能"></a>01–库感智能</h2><p>初创公司，BOSS上直接和感知算法总监打招呼，约了第二天下午面试。</p><p>原本准备了几个问题，但是都没用到，一开始问的就比较深，说是想拷打我一下。</p><p>面试官直接要求讲自己的项目，第一个讲完开始拷打：</p><ol><li>重新讨论了一下单目摄像头定位、测距是怎样实现的，比赛项目比较脱离实际，重新描述了一次。已知了障碍物大小，标定了相机内参</li><li>问了一些计算机视觉方面的问题，都回答的不好。<ol><li>相机内参矩阵每个参数代表什么</li><li>相机外参，回答描述的是相机的位姿信息，引出了后面的坐标系转换</li><li>真实世界的一个点，怎样变换到图像画面中的（当时没有理解在问什么，回忆应该是想问这个问题。。）</li></ol></li><li>坐标系转换，一个点，左乘变换矩阵和右乘有什么区别。又是盲区，没回答上来。面试官解释：左乘变换矩阵表示对<strong>固定坐标系</strong>的变换，右乘变换矩阵表示对<strong>变化坐标的操作</strong>，不是很理解。</li><li>关于docker，detached和tached启动的区别，没有回答上来，解释说detached模式下启动的容器重启后会保持运行状态</li><li>问怎样实现导航的，又重新解释了一遍：已知背景地图，先确定了障碍物位置，实时定位又靠障碍物和里程计的参考。</li></ol><p>接着讲第二个机器狗项目，还是主要问传感器</p><ol><li>处理雷达数据时用的哪些包</li><li>了解SLAM吗，回答只会调包，知道哪些包，回答了gmapping和cartographer，问知道三维的SLAM包不，回答没用过</li><li>TensorRT是怎样优化的，回答内部自动实现的，具体细节不清楚。回答到内部会对一些网络层进行融合后面试官很满意。当时没想起来还有精度降低</li></ol><p>上面的问题问完后，面试官表示看完简历觉得我有点东西，就问了一些比较深的内容。（很好的表示，下次不允许了）</p><p>接下来问的简单问题，基本秒了：</p><ol><li>Git切换分支怎样操作，回答checkout（差点记错）</li><li>怎样提交代码到服务器，准备过的问题：add到暂存区、commit提交更改、push推送到服务器</li><li>简单的C++概念，static修饰符的效果、Vector和List</li><li>ROS2中spin和spin_once的区别，印象不深了，磕磕绊绊回答上来了。其实就是spin_once只回调一次，就执行之后的代码，spin会卡住一直回调。</li></ol><p>我反问：</p><ol><li><p>公司的经营模式，这个赛道怎么样</p><p>三大业务板块：园区清扫车(完成)、光伏清扫机器人(预交付)、移动充电站(战未来)</p><p>目前11个人，本硕博都有，目标是进军光伏领域（有相关行业的背景）</p></li><li><p>假如来实习，主要职责是什么</p><p>进他的组，做导航定位相关。不限制接触其他内容（意思啥都得干bushi）</p></li><li><p>对我的评价</p><p>作为大三学生，从简历、面试表现来说超出这个阶段很多，很务实</p><p>最后表示自身努力重要，选择的环境、道路更重要（是不是暗示我得考个研）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九届智能车地平线组完赛方案——02.系统启动和连接</title>
      <link href="/2024/09/30/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/02.%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
      <url>/2024/09/30/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/02.%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 智能车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能车 </tag>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九届智能车地平线组完赛方案——01.系统选择和烧录</title>
      <link href="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/"/>
      <url>/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>硬件：RDK X3开发板、SD卡</p><p>软件：操作系统镜像、balenaEtcher烧录软件</p><p>本章相关链接：</p><ul><li><a href="https://github.com/balena-io/etcher/releases">balenaEtcher软件下载</a></li><li><a href="https://archive.d-robotics.cc/downloads/os_images/rdk_x3/">rdk_x3操作系统镜像</a></li><li><a href="https://developer.d-robotics.cc/">地瓜开发者社区</a></li><li><a href="https://pan.baidu.com/s/1FH9txTJil7aMCIUOzhkVcg?pwd=gyh1#list/path=%2F">比赛时官方提供的资料及基础镜像网盘链接</a></li></ul><h3 id="操作系统镜像下载"><a href="#操作系统镜像下载" class="headerlink" title="操作系统镜像下载"></a>操作系统镜像下载</h3><p>官方封装了一些操作系统镜像，内置了许多工具和环境，目前共有三个大版本，1.0已经不推荐使用了，2.0基于Ubuntu-20.04，3.0基于Ubuntu-22.04。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928203049066.png" class="" title="image-20240928203049066"><p>我们这里使用的是上面的2.1.1版本。比赛时主办方在百度网盘提供了一个镜像，但是这个镜像在当时备赛过程中已经发现存在一些问题，主要是TogetherROS已经与GitHub文档无法对应，以及一些小的BUG，目前最新的镜像不存在这些问题。</p><p>(区域赛前一周意识到了上面的问题，由于只有一人开发，担心进度问题，就继续使用百度网盘中的镜像，所以如果想直接用我的源码，就得使用存在问题的镜像，已经提供在了开头的链接中)</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928204909300.png" class="" title="image-20240928204909300"><p>镜像分为desktop和server两个版本，开发板性能有限，我们使用sever版本。</p><h3 id="烧录系统"><a href="#烧录系统" class="headerlink" title="烧录系统"></a>烧录系统</h3><p>个人推荐使用balenaEtcher，UI更加现代化，还能提醒大容量设备，防止破坏其他硬盘（曾深受其害），类似的软件还有win32 disk imager，这里并没有强制要求。注意这类软件一般都需要以管理员身份运行，否则无法烧录。</p><p>打开软件，选择从文件烧录，选定下载好的img镜像文件</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928211401192.png" class="" title="image-20240928211401192"><p>点击选择目标磁盘，选定要烧录的sd卡，注意要选择单独的磁盘设备，不是分区，一旦开始烧录会格式化选定的整个磁盘设备。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240930142736534.png" class="" title="image-20240930142736534"><p>确定好之后开始烧录，烧录速度取决SD卡性能。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240930142843437.png" class="" title="image-20240930142843437"><p>镜像烧录完成就可以插入开发板卡槽，上电等待，如果绿灯闪烁说明系统已经成功启动。</p><p>如果出现烧录失败，例如报错镜像可能被更改之类，需要以管理员身份运行烧录软件。</p>]]></content>
      
      
      <categories>
          
          <category> 智能车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能车 </tag>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell与Terminal</title>
      <link href="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/"/>
      <url>/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shell（壳）、Terminal（终端），许多刚开始接触计算机的朋友可能跟以前的我一样并不清楚这两个概念，因为它们总是同时出现。配置开发环境或者学习Linux的过程中我们难免接触，所以我觉得有必要跟大家讨论一下它们的关系。</p><h2 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h2><p>shell翻译过来是“壳”，十分形象，shell就是包裹在操作系统内核上的一层外壳。shell接收用户输入的命令，并将其转换为操作系统可以理解的指令，然后执行这些指令。这里我们借助shell提供的cat指令来理解一下shell的作用。</p><p>熟悉Linux的朋友会知道，cat命令可以输出一个文件的内容到终端。这里我提前准备了一个hello.cpp文件，打开一个终端，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.cpp</span><br></pre></td></tr></table></figure><img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206213159507.png" class="" title="image-20231206213159507"><p>shell会解析我们命令行里的内容并执行，可以看到，文件里的内容成功输出到了我们的终端里。接下来我们思考一下，假如没有这个命令，我们想要达到同样的目的需要怎样的步骤，由于本人对windows内核并不熟悉，这里我会在Linux环境下进行演示，原理是相通的，不会影响我们理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, <span class="string">&quot;Usage: program_name &lt;filename&gt;\n&quot;</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回非零表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="type">char</span> *filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fileDescriptor = <span class="built_in">open</span>(filename, O_RDONLY);</span><br><span class="line">    <span class="comment">// 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, <span class="string">&quot;Error opening file\n&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 返回非零表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取并打印文件内容</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = <span class="built_in">read</span>(fileDescriptor, buffer, <span class="built_in">sizeof</span>(buffer))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buffer, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fileDescriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回零表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个my_cat程序，程序使用 <code>open</code> 打开文件，然后使用 <code>read</code> 从文件中读取内容，并使用 <code>write</code> 将内容写入标准输出。最后，使用 <code>close</code> 关闭文件描述符。这几个函数就是linux内核提供的接口。</p><p>编译并运行程序，可以看到成功输出文件内容<img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206220309890.png" class="" title="image-20231206220309890"></p><p>到这你是否对这层“壳”有了一点点感觉，再借助下面这张图，估计就能理解shell扮演的角色。</p><img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206222404523.png" class="" title="image-20231206222404523"><p>用户可以通过shell和各种程序操作系统内核，shell和程序之间也可以相互操作，通过这种架构我们可以十分灵活的完成对计算机的控制</p><h2 id="shell命令解释器"><a href="#shell命令解释器" class="headerlink" title="shell命令解释器"></a>shell命令解释器</h2><p>上面提到的shell是概念级的东西，在它之下有各种解释器的实现，例如Linux中常用的bash、zsh，windows的cmd、powershell，甚至一些软件例如Git、VistualStudio都会提供一些shell工具。</p><p>在linux中我们可以查看当前系统中都有那些shell解释器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206223115522.png" class="" title="image-20231206223115522"><p>可以看到我的ubuntu系统中有这些解释器，正在使用的是zsh，我的终端就是使用的oh-my-zsh进行的美化。</p><p>在windows环境，以前我们使用的是cmd（命令提示符），它只在windows下使用，并且很多命令都是微软自己的规范，有一定的学习成本。后来win10以后，powershell越来越完善，我们也强推使用这个。powershell是可以跨平台的。</p><h2 id="Terminal（终端）是什么"><a href="#Terminal（终端）是什么" class="headerlink" title="Terminal（终端）是什么"></a>Terminal（终端）是什么</h2><p>现在的终端和计算机刚发展时的终端概念发生了一些变化，现在我们看到的各种终端软件其实应该叫模拟终端，关于这个概念有兴趣的朋友可以查阅相关资料。</p><p>用我自己的理解来说，终端就是可以输入命令并显示程序运行信息的窗口软件。终端本身不会解释命令，它会把用户输入的命令交给shell解释器执行。由于这两者总是同时出现，所以才让我们容易混淆。</p><p>这些终端软件又会提供一些额外的功能，例如Terminator好用的拆分窗口、Windows Terminal提供的统一管理、美化等功能。</p><img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206230246074.png" class="" title="image-20231206230246074"><img src="/2023/12/06/%E6%9D%82%E8%B0%88/shell%E4%B8%8ETerminal/image-20231206230439597.png" class="" title="image-20231206230439597"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上：</p><ul><li>shell是操作系统内核的外层封装，方便用户对系统进行操作。</li><li>Terminal是提供窗口界面，将用户的命令交给shell解释器执行</li></ul><p>另外，shell本身还是一种脚本语言，我们可以直接将命令在命令行执行，也可以按照shell语法将这些命令写入文件中，shell解释器可以读取这个文件并执行。本人并不擅长shell编程，就不在这里献丑，有兴趣的朋友可以查看相关资料学习。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器与IDE</title>
      <link href="/2023/12/06/%E6%9D%82%E8%B0%88/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/"/>
      <url>/2023/12/06/%E6%9D%82%E8%B0%88/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>写这篇文章的想法源于某次课堂，老师多次将VC++6.0、CodeBlocks这些上古神器称为编译器，虽然知道它们区别的同学知道这只是老师的个人习惯，但我觉得课堂上还是应该严谨，特别是对刚接触计算机学科的同学们来说。</p><p>直接说结论：</p><ul><li>编辑器：用来编辑文本文件的工具。比如windows下的记事本、Notepad++，Linux下的Vi、Vim、gedit，当然还有Vscode这种跨平台的软件。</li><li>编译器：按一定的规则将文本格式的源代码翻译成可执行程序的工具。例如编译c\c++的GCC、G++、MSVC、Clang等</li><li>IDE（集成开发环境）：将上面的编译器、编辑器集成到一个软件中，再拓展更多便于开发人员使用的工具。</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>注意这里我们只讨论c\c++这类编译型语言。</p><p>我们都知道一段程序从源码到可执行程序需要经过预处理、编译、汇编、链接这几步操作，下面是我在windows环境下使用MinGW-w64编译器（不懂的朋友先不用管它是什么，马上会解释）分步执行了这个过程：</p><ol><li><p><strong>编辑（Editing）：</strong> 你首先使用文本编辑器（如Notepad++、Visual Studio Code、或者专门的集成开发环境（IDE）如Visual Studio等）编写C++源代码文件（通常以<code>.cpp</code>为扩展名）。在这个阶段，你可以编写类、函数、变量等。</p></li><li><p><strong>预处理（Preprocessing）：</strong> 在这个阶段，预处理器会对源代码进行处理。预处理器的任务包括处理<code>#include</code>指令，替换宏定义，以及处理条件编译等。预处理器生成一个新的临时源文件，通常以<code>.i</code>或<code>.ii</code>为扩展名。打开终端，进入源文件所在目录，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></li><li><p><strong>编译（Compiling）：</strong> 在这个阶段，编译器将预处理后的源代码翻译成汇编代码。汇编代码是一种低级的表示，它使用符号和指令来描述程序的操作。生成的文件通常以<code>.s</code>为扩展名。继续执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></li><li><p><strong>汇编（Assembling）：</strong> 汇编器将汇编代码翻译成机器码或者可重定位的目标代码。生成的文件通常以<code>.o</code>、<code>.obj</code>或者其他特定于平台的扩展名为后缀。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></li><li><p><strong>链接（Linking）：</strong> 在这个阶段，链接器将目标代码与其他已经编译的目标代码或者库文件链接在一起，生成最终的可执行文件。链接器的任务包括解析符号引用、地址重定向等。生成的文件通常是一个可执行文件，可以在计算机上运行。可执行文件的扩展名可能是<code>.exe</code>（Windows）或者无扩展名（Linux）。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello.exe</span><br></pre></td></tr></table></figure></li></ol><p>上面的过程中每一步都会生成相应的文件，其中几个文本类型文件有兴趣的朋友可以打开查看一下。</p><img src="/2023/12/06/%E6%9D%82%E8%B0%88/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231205235904204.png" class="" title="image-20231205235904204"><p>大家可以看到，我们通过gcc工具，在命令行中就实现了一个程序从源码到可执行程序的全过程（当然gcc命令还有更多使用方式，在这里不深入讨论）。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ol><li><p>GCC\G++</p><p>gcc 和 g++分别是GNU的c、c++的编译器，主要用于LINUX平台。现在大多Linux的发行版都会自带这两个编译器。</p></li><li><p>MinGW</p><p>其实MinGW就是GCC\G++在windows环境下的移植，上面我用来演示编译过程就是用的MinGW，与Linux下使用gcc没什么区别。</p></li><li><p>MSVC</p><p>这是Windows环境下的编译器，我们在安装Visual Studio之后就会自带这个编译器。</p></li></ol><h2 id="IDE（集成开发环境）"><a href="#IDE（集成开发环境）" class="headerlink" title="IDE（集成开发环境）"></a>IDE（集成开发环境）</h2><p>前边说的VC++6.0、CodeBlocks其实是在这个范畴，IDE是将文件管理系统、编辑器、编译器、调试、版本管理、代码提示、远程连接等等会用到的工具进行了一个打包，让程序员尽量做到开箱即用。</p><p>在windows环境下，我们大部分初学者接触到的都是微软的那套软件，我个人推荐的就是大名鼎鼎的Visual Studio，真正让初学者做到了开箱即食，能够尽快入门，而不是把时间和热情消耗在各种奇怪的环境配置上。</p><p>另外关于VScode，它本体其实只能算一个文本编辑器（记事本同级），加上各种插件之后才得以拿来开发。喜欢定制化、有时间折腾的朋友推荐使用，我个人最喜欢的就是vscode。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内容很简单，对大部分朋友来说这个问题可能太过低端，文中也没多少干货，但想想两年前的自己确实需要这种“启蒙”的文章，或许就有人需要呢。</p><p>最后附上本人正在使用开发工具大合集，你喜欢哪一款的风格呢？</p><img src="/2023/12/06/%E6%9D%82%E8%B0%88/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231206201826011.png" class="" title="image-20231206201826011"><img src="/2023/12/06/%E6%9D%82%E8%B0%88/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231206202027987.png" class="" title="image-20231206202027987"><p>上边两个是微软出品，下边是JetBrains全家桶中的两个</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是环境变量——windows</title>
      <link href="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
      <url>/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​我们在配置各种开发环境的时候，常常会包含一个步骤：配置环境变量。</p><p>​那么什么是环境变量，这个步骤是为了做什么，接下来我会抛掉官方解释，逐步带大家测试。（windows环境下）</p><h2 id="终端中执行的命令是什么"><a href="#终端中执行的命令是什么" class="headerlink" title="终端中执行的命令是什么"></a>终端中执行的命令是什么</h2><p>​我们经常会在电脑终端(cmd或者powershell)中输入&#x3D;&#x3D;ipconfig&#x3D;&#x3D;命令来查看电脑的网络配置，如图：</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204153850323.png" class="" title="image-20231204153850323"><p>​为什么输入ipconfig命令就会输出这些信息，这里先跟大家介绍一个新命令&#x3D;&#x3D;get-Command&#x3D;&#x3D;，这个命令的作用是获取其他命令的信息，这里我们目的是为了获取它的路径。（熟悉linux的朋友会不会想到where、which命令）</p><p>我们在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-Command ipconfig</span><br></pre></td></tr></table></figure><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204154604859.png" class="" title="image-20231204154604859"><p>​哦豁，看见Source条目没，首先它就是一个exe可执行程序！！其实想来也是，大一的计算机概论课就告诉我们计算机上执行的就是一堆二进制文件。</p><p>​有兴趣的朋友可以进到这个目录双击执行下这个文件，运气好就能看到输出信息。（但是八成会一闪而过，需要修改终端的终止行为才能卡住看到信息）</p><h2 id="自己的程序怎样在终端里运行"><a href="#自己的程序怎样在终端里运行" class="headerlink" title="自己的程序怎样在终端里运行"></a>自己的程序怎样在终端里运行</h2><p>​既然知道了Terminal里的各种命令本质就是一些二进制文件，那么我们学了c语言，成天到晚printf，我们编写的程序是不是也能这样运行呢？当然可以，程序都是人写的，微软程序员宁有种乎？！（bushi）</p><p>​这里先准备了一个简单程序，功能就是打印”current directory”这句话。</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204161326079.png" class="" title="image-20231204161326079"><p>​接下来我们进入文件所在目录，右键选择在终端中打开，就会弹出右边的窗口（你的可能和我不一样，powershell美化教程后续会出）</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204161728786.png" class="" title="image-20231204161728786"><p>​接下来在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPath</span><br></pre></td></tr></table></figure><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204162242146.png" class="" title="image-20231204162242146"><p>​哦豁，翻车了这下。。但是根据提示，我们再输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\myPath.exe</span><br><span class="line">或者</span><br><span class="line">.\myPath</span><br></pre></td></tr></table></figure><p>​<img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204162506238.png" class="" title="image-20231204162506238"></p><p>​这下ok了，所以我们的程序在终端也是可以执行的。</p><h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p>​为什么我们的程序必须加上 .\ 才可以运行呢，而且注意观察刚才的报错，Suggestion中提到了它在当前目录下检测到了这个程序，说明系统其实找到了这个文件，但是为什么不直接执行。</p><p>​这个问题有人回答是一种安全设计，防止恶意程序执行、防止环境变量与当前目录中的同名程序冲突等。本人没有继续深究，有兴趣的朋友可以继续探索。综上，这里的 .\ 就是指定了运行当前目录的程序</p><h2 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h2><p>​刚才我们想要执行程序，必须进入到程序所在的目录，或者完整指定程序的路径：</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204164412398.png" class="" title="image-20231204164412398"><p>​为什么系统中的命令，比如&#x3D;&#x3D;ipconfig&#x3D;&#x3D;不管我们在哪都可以执行呢？这就是环境变量的作用。</p><p>按照下图的步骤打开环境变量编辑器，</p><p>​<img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204165105696.png" class="" title="image-20231204165105696"></p><p>​观察新弹出的窗口，会有一个系统环境变量和一个用户变量（以你的用户名命名），这两个窗口都包含一个Path的条目，双击可以打开：</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204165635829.png" class="" title="image-20231204165635829"><p>​这里存的就是一堆路径，如果你还记得的话，&#x3D;&#x3D;C:\Windows\system32&#x3D;&#x3D;路径里就存着我们的&#x3D;&#x3D;ipconfig&#x3D;&#x3D;命令。</p><p>​到这就可以告诉大家了，当我们在终端输入一个命令时，系统就会在这一堆路径里去查找，找到了就执行，没有就报错。</p><p>​我们把刚才的程序所在路径添加到下边，再在终端执行（注意一定要先保存环境变量编辑，再新打开一个终端）<img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204170501737.png" class="" title="image-20231204170501737"></p><p>成功执行！说明系统正确查找到了我的程序。</p><h2 id="系统变量与用户变量"><a href="#系统变量与用户变量" class="headerlink" title="系统变量与用户变量"></a>系统变量与用户变量</h2><p>​但是还有一个问题，为什么还分系统变量和用户变量呢，他们有什么区别？</p><p>​windows系统与Linux一样，都支持多用户操作（虽然我们大部分朋友都是单用户使用），比如办公室的公用电脑，为了防止开发环境冲突，或者有些程序我们并不想让其他用户使用，我们就可以只配置当前用户的环境变量。在这种要求下，我们很快也能想到，他们两个就是查找顺序的区别，并且肯定是先系统变量，再用户变量。</p><p>​我重新生成了两个myPath程序，分别放在用户变量和系统变量中，各自输出：”SystemPath“和”UserPath“</p><p>​<img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204171908509.png" class="" title="image-20231204171908509"></p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204172002808.png" class="" title="image-20231204172002808"><p>此时再执行命令，发现输出的是”systemPath”，系统环境变量的程序</p><p>接下来删掉系统变量的条目，再开新终端执行，发现输出的是”userPath”，用户变量的程序</p><img src="/2023/12/04/%E6%9D%82%E8%B0%88/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204172449841.png" class="" title="image-20231204172449841"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，现在就可以回答之前搭建开发环境的问题，环境变量的作用就是让系统可以找到你需要的那些工具，比如Python、MinGW、JDK、conda等等。我们可以打开这些工具的bin目录，里边肯定会有一堆可执行程序，所谓的配置开发环境就是让这些工具正常使用。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>​1.系统不会递归的查找目录的子文件夹，不然直接放个C、D、E盘三个根目录，直接把电脑翻干净了hhh</p><p>​2.系统查找的流程是从上到下执行，只要找到程序就停止查询，配置环境有时候就会在这栽跟头</p><p>​3.窗口中除了Path项目，其他的条目就像是在给文件夹起别名，比如我们会找到TEMP这个变量，它的值就是”C:Users\你的用户名\AppData\Local\Temp”。起完别名我们可以直接在Path中用&#x3D;&#x3D;%别名%&#x3D;&#x3D;来使用</p><p>最后，由于本人还在学习，能力有限，文中如有错误恳请指正，将不胜感激！</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
