<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>现代CMake模块化项目指南</title>
      <link href="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/"/>
      <url>/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件、目录组织规范"><a href="#一、文件、目录组织规范" class="headerlink" title="一、文件、目录组织规范"></a>一、文件、目录组织规范</h2><h3 id="1-推荐的目录组织方式"><a href="#1-推荐的目录组织方式" class="headerlink" title="1. 推荐的目录组织方式"></a>1. 推荐的目录组织方式</h3><p>目录组织格式：</p><ul><li><p>项目名&#x2F;include&#x2F;项目名&#x2F;模块名.h</p></li><li><p>项目名&#x2F;include&#x2F;项目名&#x2F;模块名.h</p></li><li><p>项目名&#x2F;src&#x2F;模块名.cpp</p></li></ul><p>CMakeLists.txt内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(项目名 PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>源码文件（.h）中写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;项目名/模块名.h&gt;</span></span></span><br><span class="line"> 项目名::函数名();</span><br></pre></td></tr></table></figure><p>头文件中写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> 项目名 &#123;</span><br><span class="line"><span class="type">void</span> 函数名();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现文件（.cpp）中写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;项目名/模块名.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> 项目名 &#123;</span><br><span class="line"><span class="type">void</span> 函数名() &#123; 函数实现 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241031195636131.png" class="" title="image-20241031195636131"><ol start="2"><li><h3 id="划分子项目"><a href="#划分子项目" class="headerlink" title="划分子项目"></a>划分子项目</h3><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241031204357023.png" class="" title="image-20241031204357023"><p>大型的项目，往往会划分为几个子项目。</p><p>即使你只有一个子项目，也建议你先创建一个子目录，方便以后追加新的子项目。</p><p>上面的案例中，我们在根目录下，创建了两个子项目 biology 和 pybmain，他们分别在各自的目录下有自己的 CMakeLists.txt。</p></li><li><h3 id="根项目的CMakeLists-txt-配置"><a href="#根项目的CMakeLists-txt-配置" class="headerlink" title="根项目的CMakeLists.txt 配置"></a>根项目的CMakeLists.txt 配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根目录CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(CppCMakeDemo LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(MyUsefulFuncs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(pybmain)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(biology)</span><br></pre></td></tr></table></figure><p>在根项目的 CMakeLists.txt 中，设置了默认的构建模式，设置了统一的 C++ 版本等各种选项。然后通过 project 命令初始化了根项目。</p><p>随后通过 add_subdirectory 把两个子项目 pybmain 和 biology 添加进来（顺序无关紧要），这会调用 pybmain&#x2F;CMakeLists.txt 和 biology&#x2F;CMakeLists.txt。</p></li><li><h3 id="子项目的CMakeLists-txt-配置"><a href="#子项目的CMakeLists-txt-配置" class="headerlink" title="子项目的CMakeLists.txt 配置"></a>子项目的CMakeLists.txt 配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># biolog/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(biology STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(biology PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>子项目的 CMakeLists.txt 就干净许多，只是创建了 biology 这个静态库对象，并通过 GLOB_RECRUSE 为他批量添加了所有位于 src 和 include 下源码和头文件。</p><p>根项目的 CMakeLists.txt 负责处理全局有效的设定。而子项目的 CMakeLists.txt 则仅考虑该子项目自身的设定，比如他的头文件目录，要链接的库等等。</p><h4 id="子项目头文件"><a href="#子项目头文件" class="headerlink" title="子项目头文件"></a>子项目头文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(biology PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>这里我们给 biology 设置了头文件搜索路径 include。</p><p>因为子项目的 CMakeLists.txt 里指定的路径都是相对路径，所以这里指定 include 实际上是：根&#x2F;biology&#x2F;include。</p><p>注意我们用了 <strong>PUBLIC</strong> 修饰符，这是为了让链接 biology 的 pybmain 也能够共享 根&#x2F;biology&#x2F;include 这个头文件搜索路径。</p><h4 id="子项目源文件"><a href="#子项目源文件" class="headerlink" title="子项目源文件"></a>子项目源文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(biology STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br></pre></td></tr></table></figure><p>这里我们给 biology 批量添加了 src&#x2F;*.cpp 下的全部源码文件。</p><p>明明只有 <code>*.cpp</code> 需要编译，为什么还添加了 <code>include/*.h</code>？</p><p>为了头文件也能被纳入 VS 的项目资源浏览器，方便编辑。</p><p>因为子项目的 CMakeLists.txt 里指定的路径都是相对路径，所以这里指定 src 实际上是：根&#x2F;biology&#x2F;src。</p><h4 id="复习：GLOB和GLOB-RECURUSE的区别"><a href="#复习：GLOB和GLOB-RECURUSE的区别" class="headerlink" title="复习：GLOB和GLOB_RECURUSE的区别"></a>复习：GLOB和GLOB_RECURUSE的区别</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span> (GLOB myvar CONFIGURE_DEPENDS src/*.cpp)</span><br><span class="line"><span class="keyword">file</span> (GLOB_RECURSE myvar CONFIGURE_DEPENDS src/*.cpp)</span><br></pre></td></tr></table></figure><p><strong>疑问1</strong>：都是按照通配符批量匹配文件，有什么区别？</p><table><thead><tr><th>特性</th><th>GLOB</th><th>GLOB_RECURSE</th></tr></thead><tbody><tr><td>是否支持嵌套目录匹配</td><td>否</td><td>是</td></tr><tr><td>示例</td><td>- <code>src/main.cpp</code>（√）</td><td>- <code>src/main.cpp</code>（√）</td></tr><tr><td></td><td>- <code>src/**test**/main.cpp</code>（×）</td><td>- <code>src/**test**/main.cpp</code>（√）</td></tr></tbody></table><p><strong>总结</strong>：GLOB 不支持匹配嵌套的目录，而 GLOB_RECURSE 允许使用 <code>*</code> 匹配嵌套目录。</p><p><strong>疑问2</strong>：加了 <code>CONFIGURE_DEPENDS</code> 这个选项有什么区别？</p><p>如果不加 <code>CONFIGURE_DEPENDS</code>，在你创建新文件时，<code>myvar</code> 不会自动更新，仍然是旧的文件列表，这可能导致出现 <code>undefined symbol</code> 错误。在这种情况下，你需要手动运行 <code>cmake -B build</code> 才能更新。</p><p>而加上 <code>CONFIGURE_DEPENDS</code> 后，每次运行 <code>cmake --build</code> 时，CMake 会自动检测目录是否有更新。如果发现有新文件，CMake 会自动重新运行 <code>cmake -B build</code>，从而更新 <code>myvar</code> 变量。</p><p><strong>总结</strong>：使用 <code>CONFIGURE_DEPENDS</code> 可以确保在构建时自动检测文件变化，减少手动更新的需要，避免潜在的编译错误。</p></li><li><h3 id="头文件和源文件的一一对应关系"><a href="#头文件和源文件的一一对应关系" class="headerlink" title="头文件和源文件的一一对应关系"></a>头文件和源文件的一一对应关系</h3><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241031204325532.png" class="" title="image-20241031204325532"><p>通常每个头文件都有一个对应的源文件，两个文件名字应当相同（方便我们理解，也方便 IDE 跳转），只有后缀名不一样。</p><p>如果是一个类，则文件名应和类名相同，方便查找（Animal.cpp）。</p><p>头文件中包含函数和类的声明，源文件则包含他们的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// biology/include/biology/Animal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span> : Animal &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> : Animal &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// biology/src/Animal.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::speak</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> </span>&#123; os &lt;&lt; <span class="string">&quot;Meow~&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dog::speak</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> </span>&#123; os &lt;&lt; <span class="string">&quot;Wang!&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br></pre></td></tr></table></figure></li><li><h3 id="只有头文件，没有源文件的情况"><a href="#只有头文件，没有源文件的情况" class="headerlink" title="只有头文件，没有源文件的情况"></a>只有头文件，没有源文件的情况</h3><p>有时我们会直接把实现直接写在头文件里，这时可以没有与之对应的源文件，只有一个头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pybmain/include/pybmain/myutils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> pybmain &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">alluppercase</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">  std::string ret;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">    ret.<span class="built_in">push_back</span>(std::<span class="built_in">toupper</span>(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace pybmain</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在头文件里直接实现函数时，要加 static 或 inline 关键字。</p></li><li><h3 id="每新增一个功能模块，需要创建两个文件"><a href="#每新增一个功能模块，需要创建两个文件" class="headerlink" title="每新增一个功能模块，需要创建两个文件"></a>每新增一个功能模块，需要创建两个文件</h3><p>每新增一个功能模块，同时添加同名的源文件和头文件。头文件中的声明和源文件中的实现一一对应。</p><p>新添加功能模块：Carer</p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103195553720.png" class="" title="image-20241103195553720"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Carer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Carer</span> &#123;</span><br><span class="line">  <span class="function">std::string <span class="title">care</span><span class="params">(Animal *a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// carer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Carer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Carer::care</span><span class="params">(Animal *a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::ostringstream ss;</span><br><span class="line">    a-&gt;<span class="built_in">speak</span>(ss);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="一个模块依赖其他模块，则应导入他的头文件"><a href="#一个模块依赖其他模块，则应导入他的头文件" class="headerlink" title="一个模块依赖其他模块，则应导入他的头文件"></a>一个模块依赖其他模块，则应导入他的头文件</h3><p>如果新模块（Carer）中用到了其他模块（Animal）的类或函数，则需要在新模块（Carer）的头文件和源文件中都导入其他模块（Animal）的头文件。</p><p>注意不论是项目自己的头文件还是外部的系统的头文件，请全部统一采用 <strong>&lt;项目名&#x2F;模块名.h&gt;</strong> 的格式。不要用 <strong>“模块名.h”</strong> 这种相对路径的格式，避免模块名和系统已有头文件名冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 Carer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span><span class="comment">//项目名/模块名.cpp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Carer</span> &#123;</span><br><span class="line">  <span class="function">std::string <span class="title">care</span><span class="params">(Animal *a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件carer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Carer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span> <span class="comment">// 项目名/模块名.h</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Carer::care</span><span class="params">(Animal *a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::ostringstream ss;</span><br><span class="line">    a-&gt;<span class="built_in">speak</span>(ss);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="依赖其他模块但不解引用，则-可以只向前声明不导入头文件"><a href="#依赖其他模块但不解引用，则-可以只向前声明不导入头文件" class="headerlink" title="依赖其他模块但不解引用，则 可以只向前声明不导入头文件"></a>依赖其他模块但不解引用，则 可以只向前声明不导入头文件</h3><p>如果模块 Carer 的头文件 Carer.h 虽然引用了其他模块中的 Animal 类，但是他里面并没有解引用 Animal，只有源文件 Carer.cpp 解引用了 Animal。</p><p>那么这个头文件是不需要导入 Animal.h 的，只需要一个前置声明 <strong>struct Animal</strong>，只有实际调用了 Animal 成员函数的源文件需要导入 Animal.h。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 Carer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span>;<span class="comment">// 前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Carer</span> &#123;</span><br><span class="line">  <span class="function">std::string <span class="title">care</span><span class="params">(Animal *a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件carer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Carer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span><span class="comment">// 实际解引用的源文件导入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Carer::care</span><span class="params">(Animal *a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::ostringstream ss;</span><br><span class="line">    a-&gt;<span class="built_in">speak</span>(ss);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：加快编译速度，防止循环引用。</p></li><li><h3 id="以项目名为命名空间-namespace-，避免符号冲突"><a href="#以项目名为命名空间-namespace-，避免符号冲突" class="headerlink" title="以项目名为命名空间(namespace)，避免符号冲突"></a>以项目名为命名空间(namespace)，避免符号冲突</h3><p>在声明和定义外面都套一层命名空间，例如此处我的子项目名是 biology，那我就 <strong>biology::Animal</strong>。避免暴露全局的 Animal。这是因为万一有个“不拘一格”的第三方库也暴露个全局的 Animal，两个符号就会发生冲突，由于类符号都具有 weak 属性，链接器会随机选择一个覆盖掉，非常危险！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 Carer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;<span class="comment">// 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Carer</span> &#123;</span><br><span class="line">  <span class="function">std::string <span class="title">care</span><span class="params">(Animal *a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace biology</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源文件carer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Carer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;biology/Animal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> biology &#123;<span class="comment">// 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Carer::care</span><span class="params">(Animal *a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::ostringstream ss;</span><br><span class="line">    a-&gt;<span class="built_in">speak</span>(ss);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>（关于符号的 weak 属性，以后再讲讲，这里还是重点关注 CMake）</em></p></li><li><h3 id="依赖另一个子项目，则需要链接他"><a href="#依赖另一个子项目，则需要链接他" class="headerlink" title="依赖另一个子项目，则需要链接他"></a>依赖另一个子项目，则需要链接他</h3><p>让 pybmain 链接上 biology：target_link_libraries(pybmain PUBLIC biology)</p><p>由于 PUBLIC 属性具有传染性，根&#x2F;biology&#x2F;include 现在也加入 pybmain 的头文件搜索路径了，因此 pybmain 里可以 #include 到 biology 的头文件。</p><p>同理如果又有一个 target_link_libraries(xxx PUBLIC pybmain) 那么 xxx 也有 pybmain 和 biology 的所有头文件搜索路径了。</p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103201713328.png" class="" title="image-20241103201713328"><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103201640425.png" class="" title="image-20241103201640425"></li><li><h3 id="CMake的include流"><a href="#CMake的include流" class="headerlink" title="CMake的include流"></a>CMake的include流</h3><p>和 C&#x2F;C++ 的 #include 一样，CMake 也有一个 include 命令。</p><p>你写 include(XXX)，则他会在 CMAKE_MODULE_PATH 这个列表中的所有路径下查找 XXX.cmake 这个文件。</p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103201932443.png" class="" title="image-20241103201932443"><p>这样你可以在 XXX.cmake 里写一些你常用的函数，宏，变量等。</p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103202025325.png" class="" title="image-20241103202025325"><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103202050462.png" class="" title="image-20241103202050462"></li></ol><h2 id="二、第三方库、依赖项配置"><a href="#二、第三方库、依赖项配置" class="headerlink" title="二、第三方库、依赖项配置"></a>二、第三方库、依赖项配置</h2><h3 id="1-find-package命令"><a href="#1-find-package命令" class="headerlink" title="1. find_package命令"></a>1. find_package命令</h3><p>常用参数列表一览：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [CONFIG] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>用法举例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV)</span><br><span class="line">查找名为 OpenCV 的包，找不到不报错，事后可以通过 <span class="variable">$&#123;OpenCV_FOUND&#125;</span> 查询是否找到。</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV QUIET)</span><br><span class="line">查找名为 OpenCV 的包，找不到不报错，也不打印任何信息。</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)    <span class="comment"># 最常见用法</span></span><br><span class="line">查找名为 OpenCV 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core videoio)</span><br><span class="line">查找名为 OpenCV 的包，找不到就报错，且必须具有 OpenCV::core 和 OpenCV::videoio 这两个组件，如果没有这两个组件也会报错。</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED OPTIONAL_COMPONENTS core videoio)</span><br><span class="line">查找名为 OpenCV 的包，找不到就报错，可具有 OpenCV::core 和 OpenCV::videoio 这两个组件，没有这两组件不会报错，通过 <span class="variable">$&#123;OpenCV_core_FOUND&#125;</span> 查询是否找到 core 组件。</span><br></pre></td></tr></table></figure><h3 id="2-找的“包“到底是什么"><a href="#2-找的“包“到底是什么" class="headerlink" title="2. 找的“包“到底是什么"></a>2. 找的“包“到底是什么</h3><p>find_package(OpenCV) 实际上是在找一个名为 <strong>OpenCVConfig.cmake</strong> 的文件。</p><p>注：出于历史兼容性考虑，除了 OpenCVConfig.cmake 以外 <strong>OpenCV-config.cmake</strong> 这个文件名也会被 CMake 识别到。</p><p>同理，find_package(Qt5) 则是会去找名为 <strong>Qt5Config.cmake</strong> 的文件。</p><p>这些形如 <strong>包名 + Config.cmake</strong> 的文件，我称之为<strong>包配置文件</strong>。</p><p>Qt5Config.cmake 是你安装 Qt5 时，随 libQt5Core.so 等实际的库文件，一起装到你的系统中去的。以我的 Ubuntu Linux 系统为例：</p><ul><li><p>包配置文件位于 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake</p></li><li><p>实际的动态库文件位于 &#x2F;usr&#x2F;lib&#x2F;libQt5Core.so</p></li></ul><p>因此 find_package 并不是直接去找具体的<strong>动态库文件</strong>和<strong>头文件</strong>（例如 libQt5Core.so）</p><p>而是去找<strong>包配置文件</strong>（例如Qt5Config.cmake），这个配置文件里包含了包的具体信息，包括动态库文件的位置，头文件的目录，链接时需要开启的编译选项等等。</p><p>而且某些库都具有多个子动态库，例如 Qt 就有 libQt5Core.so、libQt5Widgets.so、libQt5Network.so。因此 CMake 要求所有第三方库作者统一包装成一个 Qt5Config.cmake 文件包含所有相关信息（类似于 nodejs 的 package.json），比你单独的一个个去找动态库文件要灵活的多。</p><p>包配置文件由第三方库的作者（Qt的开发团队）提供，在这个库安装时（Qt的安装程序或apt install等）会自动放到 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;XXXConfig.cmake 这个路径（其中XXX是包名），供 CMake 用户找到并了解该包的具体信息。</p><p>&#x2F;usr&#x2F;lib&#x2F;cmake 这个位置是 CMake 和第三方库作者<strong>约定俗成</strong>的，由第三方库的安装程序负责把包配置文件放到这里。如果第三方库的作者比较懒，没提供 CMake 支持（由安装程序提供XXXConfig.cmake），那么得用另外的一套方法（FindXXX.cmake），稍后细谈。</p><h3 id="3-搜索路径"><a href="#3-搜索路径" class="headerlink" title="3. 搜索路径"></a>3. 搜索路径</h3><p><strong>Windows 系统下的搜索路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;/</span><br><span class="line">&lt;prefix&gt;/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;prefix&gt;</code> 是变量 <code>$&#123;CMAKE_PREFIX_PATH&#125;</code>，Windows 平台默认为 C:&#x2F;Program Files。</p><p><code>&lt;name&gt;</code> 是你在 <code>find_package(&lt;name&gt; REQUIRED)</code> 命令中指定的包名。</p><p><code>&lt;arch&gt;</code> 是系统的架构名。</p><p><strong>Unix 类系统下的搜索路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;prefix&gt;</code> 是变量 <code>$&#123;CMAKE_PREFIX_PATH&#125;</code>，Unix 平台默认为 &#x2F;usr。</p><p><code>&lt;name&gt;</code> 是你在 <code>find_package(&lt;name&gt; REQUIRED)</code> 命令中指定的包名。</p><p><code>&lt;arch&gt;</code> 是系统的架构，例如 x86_64-linux-gnu 或 i386-linux-gnu。</p><ul><li>（用于伺候 Ubuntu 喜欢把库文件套娃在 &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu 目录下）</li></ul><p><strong>举例说明 find_package 搜索路径:</strong></p><p>例如你是 64 位的 Linux 系统，<code>find_package(Qt5 REQUIRED)</code> 会依次搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/share/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/share/Qt5/Qt5Config.cmake</span><br></pre></td></tr></table></figure><p>例如你是 64 位的 Windows 系统，find_package(Qt5 REQUIRED) 会依次搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:/Program Files/Qt5Config.cmake</span><br><span class="line">C:/Program Files/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/x86_64-windows-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/x86_64-windows-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/share/Qt5/Qt5Config.cmake</span><br></pre></td></tr></table></figure><p>还有一点，<code>&lt;name&gt;</code> 可以有<strong>额外后缀</strong>，且不分大小写（无论 Linux 还是 Windows），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:/Program Files/Qt5/cmake/Qt5Config.cmake</span><br><span class="line"></span><br><span class="line">C:/Program Files/Qt5.12.1/cmake/Qt5Config.cmake</span><br><span class="line"></span><br><span class="line">C:/Program Files/qt5dnmd/cmake/Qt5Config.cmake</span><br></pre></td></tr></table></figure><p>同样都是可以被 find_package(Qt5 REQUIRED) 搜索到的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/cmake/OpenCV/OpenCVConfig.cmake</span><br><span class="line">/usr/lib/cmake/opencv4/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure><p>同样都是可以被 find_package(OpenCV REQUIRED) 搜索到的。</p><h3 id="4-安装在非标准路径的库"><a href="#4-安装在非标准路径的库" class="headerlink" title="4. 安装在非标准路径的库"></a>4. 安装在非标准路径的库</h3><p>以 Qt5 为例，如果你安装在下列标准路径，find_package 能够自动找到。</p><ul><li><p>Windows：C:&#x2F;Program Files&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake</p></li><li><p>Linux：&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake</p></li></ul><p>但是假如我的库不是装在这些标准路径，而是我<strong>自定义的路径</strong>，怎么办？</p><p>而且即使你不自定义安装路径，Windows 版的 Qt 默认安装就会安装到：</p><ul><li>C:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</li></ul><p>何况我们同学有的还喜欢装到 D 盘去，Windows 是非标准路径的重灾区，他就没有一个统一的 &#x2F;usr&#x2F;lib 目录。然而你一旦把库安装到非标准路径，find_package 是找不到的。</p><p>这时你需要手动指定一个变量告诉他在哪儿，可以是普通变量 **${Qt5_DIR}**，也可以是环境变量 **$ENV{Qt5_DIR}**，两个中只要设置了任何一个 find_package 都可以识别到。</p><p>变量一般通过命令行 <code>-DQt5_DIR=“C:/Program Files/Qt5.12.1/lib/cmake/Qt5”</code> 设置。</p><p><strong>举例：</strong></p><ul><li>Windows 系统下的 Qt5：</li></ul><p>例如我把 Qt5 安装到了 D:&#x2F;Qt5.12.1。</p><p>首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。</p><p>假如你找到该文件的位置是 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5。有三种设置方法：</p><ol><li><p>单次有效。在 configure 阶段，可以从命令行设置（注意要加引号）：<code>cmake -B build -DQt5_DIR=”D:/Qt5.12.1/msvc2017/lib/cmake/Qt5”</code></p></li><li><p>全局启用。右键“我的电脑”-&gt;“管理”-&gt;“高级”添加一个环境变量 Qt5_DIR 值为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5，然后重启 Visual Studio。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。</p></li><li><p>单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行（注意要加引号）：<code>set(Qt5_DIR ”D:/Qt5.12.1/msvc2017/lib/cmake/Qt5”)  # 一定要加在最前面！</code></p></li></ol><ul><li>Linux 系统下的 Qt5：</li></ul><p>例如我把 Qt5 安装到了 &#x2F;opt&#x2F;Qt5.12.1。</p><p>首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。</p><p>假如你找到该文件的位置是 &#x2F;opt&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 &#x2F;opt&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5。有三种设置方法：</p><ol><li><p>单次有效。在 configure 阶段，可以从命令行设置：<code>cmake -B build -DQt5_DIR=”/opt/Qt5.12.1/lib/cmake/Qt5”</code></p></li><li><p>全局启用。修改你的 ~&#x2F;.bashrc 文件添加环境变量：<code>export Qt5_DIR=”/opt/Qt5.12.1/lib/cmake/Qt5”</code>，然后重启终端。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。</p></li><li><p>单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行：<code>set(Qt5_DIR ”/opt/Qt5.12.1/lib/cmake/Qt5”)  # 一定要加在最前面！</code></p></li></ol><p><strong>三种方案的利弊分析：</strong></p><p>单次有效（通过命令行）最安全，高度推荐。</p><p>全局有效（添加环境变量）可能影响以后其他项目。比如你 A 项目依赖 Qt5.12.1，你设置了环境变量 Qt5_DIR&#x3D;&#x2F;opt&#x2F;Qt5.12.1，后来又搞了个 B 项目依赖 Qt5.10.3，但是你忘了你设置过全局的环境变量指向 5.12.1 了，导致版本冲突。</p><p>单项目有效（写死在 CMakeLists.txt）虽然方便了你，但是你的 CMakeLists.txt 拿到别人电脑上（例如你通过 GitHub 开源的），可能你 set(Qt5_DIR D:&#x2F;Qt5)，而人家却需要 set(Qt5_DIR E:&#x2F;Qt5) 呢？就冲突了。</p><p>所以“单次有效”虽然劳驾您的高抬贵手每次命令行打一下 -DQt5_DIR&#x3D;”D:&#x2F;Qt5”，但人家也打一下 -DQt5_DIR&#x3D;”E:&#x2F;Qt5”，就没有冲突，<strong>各美其美，美美与共，赋能多元化社会，下沉团队合作发力面</strong>。</p><ul><li>实际上只要你不删 build，不需要每次都 -DQt5_DIR 一下，CMake 具有“记忆”功能。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DQt5_DIR=D:/Qt5  <span class="comment"># 只需要第一次指定好，</span></span><br><span class="line">cmake -B build  <span class="comment"># 以后第二次运行可以省略！</span></span><br><span class="line">rm -rf build  <span class="comment"># 只有清理了 build 以后，</span></span><br><span class="line">cmake -B build -DQt5_DIR=D:/Qt5  <span class="comment"># 才需要重新指定。</span></span><br></pre></td></tr></table></figure><h3 id="5-假如没有Config文件"><a href="#5-假如没有Config文件" class="headerlink" title="5. 假如没有Config文件"></a>5. 假如没有Config文件</h3><p>绝大多数常用 C++ 库都提供了 CMake 支持（即使他们本身不一定是用 CMake 构建的）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/cmake/Boost-<span class="number">1.80</span>.<span class="number">0</span>/BoostConfig.cmake</span><br><span class="line">/usr/lib/cmake/opencv4/OpenCVConfig.cmake</span><br><span class="line">/usr/lib/cmake/Qt5/Qt5Config.cmake</span><br></pre></td></tr></table></figure><p>这些 <strong>Config</strong>  文件都是由<strong>第三方库负责</strong>安装到 &#x2F;usr&#x2F;lib&#x2F;cmake。</p><p>但是，也有少数不听话的库，官方不提供 CMake 支持，即安装时不自带 Config 文件。</p><p>恼人的是，这些不听话的库有些竟然是非常热门的库！例如 Python，CUDA，Jemalloc。</p><p>为了不影响 CMake 用户体验，CMake 发明了 <strong>Find</strong> <strong>文件</strong>（FindXXX.cmake），你不支持我是吧？我支持你！Find 文件会在 <strong>CMake</strong> <strong>安装时负责</strong>安装到 &#x2F;usr&#x2F;share&#x2F;cmake&#x2F;Modules。</p><p>包搜索文件可以在不知道包具体位置信息的情况下搜索他们（在 &#x2F;usr&#x2F;lib 等默认路径搜索）。</p><p>这些都是 CMake 自带的包搜索文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/cmake/Modules/FindCUDAToolkit.cmake</span><br><span class="line">/usr/share/cmake/Modules/FindPython.cmake</span><br></pre></td></tr></table></figure><p>那么如果有个不太热门的第三方库没提供包配置文件，CMake 也没提供包搜索文件，我们该如何找到他？这就需要自己提供包搜索文件了！别担心，你不用自己写，GitHub 上有很多志士仁人已经写过了对应的包搜索文件，你搜一下 FindXXX.cmake 就能找到了。</p><p><strong>举例：FindJemalloc.cmake：</strong></p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103204451652.png" class="" title="image-20241103204451652"><p>虽然 <strong>Config</strong> <strong>文件</strong>通常风格比较统一，都是 XXX::xxx 这种格式。但是不同的 <strong>Find</strong> <strong>文件</strong>，特别是这种网上志士仁人自己编写的文件，风格可能千差万别（没办法，毕竟不是官方的支持嘛），很多都还是古代 CMake 的用法，例如 ${XXX_LIBRARIES}。关于具体使用的细节可以打开 FindXXX.cmake 文件查看，他里面前半部分是注释，会讲解如何使用。</p><p>现在你下载这个文件，放到 cmake&#x2F;FindXXX.cmake。然后在你的 CMakeLists.txt 里最上面写一行：</p><p><code>set(CMAKE_MODULE_PATH “$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;”)</code></p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103204549286.png" class="" title="image-20241103204549286"><p>这样你之后的 find_package(XXX) 就会用你下载的这个 FindXXX.cmake 去找包了。</p><h3 id="6-现代-vs-古代：Config和Find文件的区别"><a href="#6-现代-vs-古代：Config和Find文件的区别" class="headerlink" title="6. 现代 vs 古代：Config和Find文件的区别"></a>6. 现代 vs 古代：Config和Find文件的区别</h3><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103204719165.png" class="" title="image-20241103204719165"><p>不管是 Find 类还是 Config 类，一定要打开相应的 cmake 文件看看注释，才能确定他是古代风格还是现代风格。</p><p>古代 CMake 的命名规范高度不统一，有的是 <code>$&#123;XXX_LIBRARIES&#125;</code>，有的又是 <code>$&#123;XXX_LIBRARY&#125;</code> 非常沙雕，需要看相应 cmake 文件的注释，才能确定具体是怎么命名的。</p><p>现代 CMake 就好多了，统一用 <strong>包名::组件名</strong> 的格式。但是具体的组件名，还是要查看 cmake 文件中的注释才能确定。例如 CURL::libcurl OpenCV::core Qt5::core TBB::tbb 等。</p><p>大多现代的 Find&#x2F;Config 文件，都同时兼容现代和古代的用法。</p><p>特别古老的 Find 文件，则只能用古代的用法。</p><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103204752954.png" class="" title="image-20241103204752954"><p>例如上图是 FindCURL.cmake 的注释，可以看到 IMPORTED Targets 章节是在介绍现代的用法，而 Result Variables 章节是在介绍古代的用法，我们尽量用现代的那种就行。</p><h3 id="7-find-package-的两种模式"><a href="#7-find-package-的两种模式" class="headerlink" title="7. find_package 的两种模式"></a>7. find_package 的两种模式</h3><img src="/2024/11/13/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/image-20241103204833575.png" class="" title="image-20241103204833575"><p><strong>指定使用哪种模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(TBB MODULE REQUIRED)</span><br></pre></td></tr></table></figure><p>只会寻找 FindTBB.cmake，搜索路径：</p><ul><li><code>$&#123;CMAKE_MODULE_PATH&#125;</code>（默认为 &#x2F;usr&#x2F;share&#x2F;cmake&#x2F;Modules）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(TBB CONFIG REQUIRED)</span><br></pre></td></tr></table></figure><p>只会寻找 TBBConfig.cmake，搜索路径：</p><ul><li><p><code>$&#123;CMAKE_PREFIX_PATH&#125;/lib/cmake/TBB</code>（默认为 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;TBB）</p></li><li><p><code>$&#123;TBB_DIR&#125; 或 $ENV&#123;TBB_DIR&#125;</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(TBB REQUIRED)</span><br></pre></td></tr></table></figure><p>不指定则两者都会尝试，先尝试 FindTBB.cmake，再尝试 TBBConfig.cmake。</p><h3 id="8-关于vcpkg的坑"><a href="#8-关于vcpkg的坑" class="headerlink" title="8. 关于vcpkg的坑"></a>8. 关于vcpkg的坑</h3><p>刚刚说了有些懒惰第三方库，比如 Jemalloc，他不提供 Config 文件，需要我们自己手写（或抄别人开源项目里的）个 Find 文件，用起来很不方便。但是 vcpkg 会为所有第三方库，即使是懒惰的 Jemalloc，都配备一个 Config 文件方便你 find_package 导入。所以用 vcpkg 时，尽量用 find_package(XXX <strong>CONFIG</strong> REQUIRED) 避免被 CMake 自带的 Find 文件误导找到别的地方（而非 vcpkg 安装的那个）的库。</p><p>另外注意 vcpkg 需要的 CMAKE_TOOLCHAIN_FILE 如果你用 set 设置，必须在 project 命令前面，并且修改这个变量后要删除 build 目录重新 cmake -B build 一遍才能生效（否则会在旧的环境里找，找不到 vcpkg 装的库）。</p><h3 id="9-find-package-命令指定版本"><a href="#9-find-package-命令指定版本" class="headerlink" title="9. find_package 命令指定版本"></a>9. find_package 命令指定版本</h3><p><em>关于语义版本号的内容见最后科普内容</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>查找名为 OpenCV 的包，不限版本，事后可以通过 <strong>${OpenCV_VERSION}</strong> 查询找到的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenCV 2.0.1 REQUIRED)</span><br></pre></td></tr></table></figure><p>查找版本在 2.0.1 <strong>以上</strong>的 OpenCV 包（version &gt;&#x3D; 2.0.1）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenCV 2.0.1 EXACT REQUIRED)</span><br></pre></td></tr></table></figure><p>查找版本<strong>刚好为</strong> 2.0.1 的 OpenCV 包（version &#x3D;&#x3D; 2.0.1）</p><p>如果没写全，则没写的部分默认为 0。例如下列三者等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenCV 2 REQUIRED)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV 2.0 REQUIRED)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV 2.0.0 REQUIRED)</span><br></pre></td></tr></table></figure><h2 id="其他补充与科普"><a href="#其他补充与科普" class="headerlink" title="其他补充与科普"></a>其他补充与科普</h2><h3 id="macro-和-function-的区别"><a href="#macro-和-function-的区别" class="headerlink" title="macro 和 function 的区别"></a>macro 和 function 的区别</h3><p>macro 相当于直接把代码粘贴过去，直接访问调用者的作用域。这里写的相对路径 include 和 src，是基于调用者所在路径。</p><p>function 则是会创建一个闭包，优先访问定义者的作用域。这里写的相对路径 include 和 src，则是基于定义者所在路径。</p><h3 id="include-和-add-subdirectory-的区别"><a href="#include-和-add-subdirectory-的区别" class="headerlink" title="include 和 add_subdirectory 的区别"></a><strong>include 和 add_subdirectory 的区别</strong></h3><p>include 相当于直接把代码粘贴过去，直接访问调用者的作用域。这里创建的变量和外面共享，直接 set(key val) 则调用者也有 ${key} 这个变量了。</p><p>function 中则是基于定义者所在路径，优先访问定义者的作用域。这里需要 set(key val PARENT_SCOPE) 才能修改到外面的变量。</p><h3 id="亲-Unix-软件从源码安装的通用套路"><a href="#亲-Unix-软件从源码安装的通用套路" class="headerlink" title="亲 Unix 软件从源码安装的通用套路"></a>亲 Unix 软件从源码安装的通用套路</h3><p>Makefile 构建系统：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr --with-some-options  <span class="comment"># 生成 Makefile（这个 configure 脚本由 Autoconf 生成）</span></span><br><span class="line"></span><br><span class="line">make -j <span class="number">8</span>        <span class="comment"># 8 核心编译，生成 libtest.so</span></span><br><span class="line"></span><br><span class="line">sudo make <span class="keyword">install</span>  <span class="comment"># 安装，拷贝到 /usr/lib/libtest.so</span></span><br></pre></td></tr></table></figure><p>CMake 构建系统：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_INSTALL_PREFIX=/usr -DWITH_SOME_OPTIONS=<span class="keyword">ON</span> <span class="comment"># 生成 Makefile</span></span><br><span class="line"></span><br><span class="line">cmake --build build --parallel <span class="number">8</span>         <span class="comment"># 8 核心编译，生成 libtest.so</span></span><br><span class="line"></span><br><span class="line">sudo cmake --build build --<span class="keyword">target</span> <span class="keyword">install</span>  <span class="comment"># 安装，拷贝到 /usr/lib/libtest.so</span></span><br></pre></td></tr></table></figure><p>注：如果 -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local 则会拷贝到 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libtest.so</p><h3 id="语义版本号（semantic-versioning）系统"><a href="#语义版本号（semantic-versioning）系统" class="headerlink" title="语义版本号（semantic versioning）系统"></a>语义版本号（semantic versioning）系统</h3><p>软件行业记录版本迭代普遍采用的是一套所谓的<strong>语义版本号</strong>系统，英文简称 semver。</p><p>通常他的格式是三个用点分隔开来的十进制数字：<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code></p><p>例如：1.2.0，0.6.8，18.11.0</p><p>major 称为主版本号，出现功能重大变更，以至于和旧 API 不兼容的时候会增加该号。</p><p>minor 称为次版本号，功能有所变更或增加，但依然和旧的 API 兼容时会增加该号。</p><p>patch 称为补丁版号，功能没有改变，只是修复了一些 bug 就重新发布时会增加该号。</p><p>也有的软件不拘一格，索性用发布的日期作为版本号的三个数字，例如 2022.11.2。不论采用哪种编号方案，都是几个用点分开的数字，并且数字越大越新，且优先比较靠前面的数字。因此为了通用，CMake 支持最多四个点分开的版本号：**<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;.&lt;tweak&gt;</code>**。并且如果你写 0.6.8 他会自动帮你把多余的 tweak 默认为 0，也就是说 0.6.8 &#x3D;&#x3D; 0.6.8.0，1.2 &#x3D;&#x3D; 1.2.0 &#x3D;&#x3D; 1.2.0.0。</p><p>比较版本号时，可以用 <code>if ($&#123;XXX_VERSION&#125; VERSION_LESS 3.1.0)</code> 判断大小。</p><h3 id="古代CMake常见问题"><a href="#古代CMake常见问题" class="headerlink" title="古代CMake常见问题"></a>古代CMake常见问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(yourapp $&#123;XXX_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line">target_include_directories(yourapp $&#123;XXX_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure><p>Q: 我明明链接了 XXX 库，编译时却报错“找不到头文件 XXX.h”怎么办？</p><p>A: 你漏了上面的 2。</p><p>Q: 我明明编译都通过了，链接却报错“undefined symbol：XXXfunc”怎么办？</p><p>A: 你漏了上面的 1。</p><p>打印检查一下这两个变量是不是空的：message(“!!!!!!” <strong>${XXX_INCLUDE_DIRS}</strong>)</p><p>如果为空说明你变量名打错了，CMake 特色就是<strong>找不到变量不报错，而是视为空字符串</strong>。</p><p>去看一下 FindXXX.cmake 里的注释（那就是文档），到底是什么名字。</p><h3 id="少见的-add-subdirectory-邪教"><a href="#少见的-add-subdirectory-邪教" class="headerlink" title="少见的 add_subdirectory 邪教"></a>少见的 add_subdirectory 邪教</h3><p>大部分第三方库都需要提前安装好，然后再 find_package 找到他，然后才能链接。</p><p>也有少数第三方库为了方便，还支持作为子项目加到你的项目中来，这种就不需要 :: 语法。</p><p>标准方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_package(spdlog REQUIRED)</span><br><span class="line"></span><br><span class="line">target_link_libraries(yourapp PUBLIC spdlog::spdlog)</span><br></pre></td></tr></table></figure><p>邪教方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(spdlog) # 需要下载好他们的源码放到你的根目录下</span><br><span class="line"></span><br><span class="line">target_link_libraries(yourapp PUBLIC spdlog)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解STL- std::map和它的朋友们</title>
      <link href="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/"/>
      <url>/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="！！本文内容搬运小彭老师现代C-大典内容，仅为个人学习备份使用，请大家支持原作者"><a href="#！！本文内容搬运小彭老师现代C-大典内容，仅为个人学习备份使用，请大家支持原作者" class="headerlink" title="！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者"></a>！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者</h2><h2 id="链接：✝️小彭大典✝️"><a href="#链接：✝️小彭大典✝️" class="headerlink" title="链接：✝️小彭大典✝️"></a>链接：<a href="https://142857.red/book/stl_map/">✝️小彭大典✝️</a></h2><h3 id="数据结构与复杂度"><a href="#数据结构与复杂度" class="headerlink" title="数据结构与复杂度"></a>数据结构与复杂度</h3><p>不论什么语言，容器（或者用学校里的话说：数据结构）的正确使用，能够在复杂度层面上，大幅提升性能。</p><p>C++ 中也是如此，有数组（vector），字典（map），还有上一课讲过的集合（set）。</p><p>今天我们要介绍的就是 C++ 的字典容器 map，以及 C++11 引入的另一个字典容器 unordered_map，他们的区别我们最后会详细讨论。我们先学习较为简单的 map，随后学习 unordered_map 时也可以举一反三、融会贯通。</p><blockquote><p>介绍完这两个标准库自带的字典容器后，我们还将介绍一些常用的第三方库容器，例如 absl::flat_hash_map、tbb::concurrent_hash_map、google::dense_hash_map、robin_hood::unordered_map、tsl::robin_pg_map 等，需要根据应用场景选择适合的容器。</p></blockquote><p>map&#x2F;set 家族都是高效查找的专家：</p><ul><li>vector 容器用 std::find 查找：O(N)O(N)</li><li>map 或 set 容器用 .find 查找：O(logN)O(log⁡N)</li><li>unordered_map 或 unordered_set 容器用 .find 查找：O(1)+O(1)+</li></ul><p>不仅是查找，map 们还支持高效的增删改查等操作。</p><h2 id="map-的逻辑结构"><a href="#map-的逻辑结构" class="headerlink" title="map 的逻辑结构"></a>map 的逻辑结构</h2><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/logicmap.png" class="" title="logicmap"><p>特点：</p><ul><li>由一系列 <strong>键值对</strong> 组成</li><li>一个键只能对应一个值</li><li>键不得重复，值可以重复</li></ul><blockquote><p>std::map, std::unordered_map, absl::flat_hash_map, tbb::concurrent_hash_map 都满足“键值对”这一基本逻辑结构，只是物理实现不同。</p></blockquote><p>在编程中我们常常需要用到“映射”的关系，这就非常需要用到以 map 为首的“键值对”这类容器了。</p><h3 id="为什么要学习-std-map"><a href="#为什么要学习-std-map" class="headerlink" title="为什么要学习 std::map"></a>为什么要学习 std::map</h3><p>map 的具体实现可以是红黑树、AVL 树、线性哈希表、链表哈希表、跳表……不同的实现在不同操作上的复杂度不同，分别适用于不同的场景。</p><p>用法上几乎是差不多的，他们都有着几乎相同的接口（除了部分扩展功能）。当你觉得红黑树的 std::map 不合适时，可以轻松把对象类型就地替换为链表哈希表 std::unordered_map 或是是线性哈希表 absl::flat_hash_map，而不用对其他代码有任何更改。</p><p>这就是所有 map 类容器都有着相同的<strong>逻辑结构</strong>：都是一个键-值映射，不同的只是他们的<strong>物理结构</strong>而已。</p><p>所有的 map 实现，都会模仿提供和 std::map 一样的 API。这就是为什么虽然 std::map 实现的很低效，我们还是要学他的原因。std::map 本身并不是完美的，但却提供了一个所有第三方都会遵循的统一接口。学会了 std::map，任何第三方库的 map 类容器你都可以轻易举一反三。</p><blockquote><p>不仅是各种第三方的 map 库，比如 rapidjson 库中的 JSON 对象，也提供了类似 std::map 的 <code>find</code> 和 <code>end</code> 迭代器接口：<code>MemberFind</code> 和 <code>MemberEnd</code>，来查找一个字典的子键；几何处理库 cgal 中的“顶点查找”功能也是基于类似的迭代器接口。总之，学会 std::map 将大大有助于你看懂这类业界公认的接口规范。</p></blockquote><hr><h3 id="标准库中的-map-容器"><a href="#标准库中的-map-容器" class="headerlink" title="标准库中的 map 容器"></a>标准库中的 map 容器</h3><p>标准库中，map<a href="https://142857.red/book/stl_map/#fn:1">1</a> 是一个<strong>模板类</strong>，他的键类型，值类型，可以由尖括号内的参数指定，便于适应不同的用户需求。</p><blockquote><p>由于 C++ 标准库的容器大多都是模板类，提供的算法也大多是模板函数，因此 C++ 标准库常被称为标准模板库 (Standard-Template-Library, STL)。</p></blockquote><p>键类型和值类型可以是任意类型，包括基本类型，用户自定义的类，其他 STL 容器等，体现了容器的泛用性。</p><p>唯一的要求是：键必须支持比较，这里 map 要求的是小于运算符 <code>&lt;</code>。</p><ul><li>例如 <code>map&lt;string, int&gt;</code> 是一个键类型为 string，值类型为 int 的 map 容器。</li><li>例如 <code>map&lt;int, Student&gt;</code> 是一个键类型为 int，值类型为 Student 的 map 容器。</li><li>例如 <code>map&lt;char, vector&lt;int&gt;&gt;</code> 是一个键类型为 char，值类型为 <code>vector&lt;int&gt;</code> 的 map 容器。</li></ul><p>后面为了方便研究，以 <code>map&lt;K, V&gt;</code> 形式书写得出的结论，对于任何实际键和值类型，只需代入 K 和 V 即可。</p><blockquote><p>已知：要想使用 <code>map&lt;K, V&gt;</code>，就得满足 <code>K</code> 必须支持比较运算符 <code>&lt;</code>。</p><p>可得：要想使用 <code>map&lt;string, int&gt;</code>，就得满足 <code>string</code> 必须支持比较运算符 <code>&lt;</code><a href="https://142857.red/book/stl_map/#fn:2">2</a>。</p><p>已知：遍历 <code>map&lt;K, V&gt;</code> 时，是以键 <code>K</code> 部分从小到大的顺序遍历的。</p><p>可得：遍历 <code>map&lt;int, string&gt;</code> 时，是以键 <code>int</code> 部分从小到大的顺序遍历的。</p></blockquote><h2 id="map-的物理结构"><a href="#map-的物理结构" class="headerlink" title="map 的物理结构"></a>map 的物理结构</h2><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/physmap.png" class="" title="physmap"><p>map 和 set 一样，都是基于红黑树的二叉排序树，实现 O(logN)O(log⁡N) 复杂度的高效查找。</p><p>vector 就是因为元素没有固定的顺序，所以才需要暴力遍历查找。</p><p>在持续的插入和删除操作下，始终维持元素的有序性，正是 map 实现高效查找的关键所在。</p><h3 id="二叉排序树与二分法"><a href="#二叉排序树与二分法" class="headerlink" title="二叉排序树与二分法"></a>二叉排序树与二分法</h3><p>始终保存元素按键排序的好处是，如果需要寻找指定键值的元素，就可以采用二分法：</p><ol><li>从根节点开始查找。</li><li>如果当前节点的键小于要找的键，则往左子节点移动；</li><li>如果当前节点的键大于要找的键，则往右子节点移动；</li><li>如果当前节点的键等于要找的键，则该节点就是要找的节点，返回该节点。</li><li>如果当前节点已经是最后一层叶子节点，也没找到相等的键，则说明该键不存在。</li><li>把左&#x2F;右子节点设为新的当前节点，然后回到第 2 步，重复这一查找过程。</li></ol><hr><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>由于 map 的实现基于二叉排序树，map 额外有一个特点：<strong>有序</strong>。</p><p>map (或 set) 中的键 K 总是从小到大排列，方便进行二分查找，在 O(logN)O(log⁡N) 时间内找到对应元素。</p><p>每次插入新的键时，会找到适当的插入位置，使得插入后的 map 仍然有序。</p><blockquote><p>注：基于哈希散列表实现的 unordered_map (和 unordered_set)，就不具备<strong>有序</strong>这一特点。</p></blockquote><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/sortedset.png" class="" title="sortedset"><hr><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/setvsmap.png" class="" title="setvsmap"><p>两者的区别在于：map 在 K 之外，额外外挂了一个 V 类型。</p><p>map 中的 V 类型不参与排序，只按照 K 进行排序。</p><p>这样当用户根据 K 找到的是 K-V 对，然后可以取出 K 对应的 V。</p><p>这就实现了从 K 到 V 的映射。</p><h3 id="二叉树退化问题"><a href="#二叉树退化问题" class="headerlink" title="二叉树退化问题"></a>二叉树退化问题</h3><p>二叉排序树只解决了查找的问题，但是他并不能保证经历一通插入后的树不会“退化”。</p><p>如果插入的时候不小心，可能会让树的形状变得非常诡异！</p><p>例如，若插入数据的顺序是从小到大的，那就会一直在往右插入，清一色的一边倒，以至于几乎成了一根往右跑的链表。</p><p>如果插入顺序是从大到小，就变成一直往左边倒。即使插入的顺序不那么刻意，依然可能产生非常变态的形状，违背了二叉树的初衷。</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/binary_tree_best_worst_cases.png" class="" title="binary_tree_best_worst_cases"><p>这样“退化”的二叉排序树，虽然能保持有序，但二分查找时就起不到加速作用了。</p><p>如果要找一个中间的元素，几乎就和链表一样，需要遍历整个右枝干。</p><p>为了限制二叉排序树不要长成畸形，我们引入一个指标：“深度”，表示从根节点到最底层叶子节点的距离。</p><p>要最大化二分查找的效率，就需要二叉树的深度尽可能的低。</p><p>因为二分查找的次数就取决于每个叶子节点的平均深度，要尽可能减少平均需要访问的次数，就是要减少二叉树的深度。</p><p>也就是说要让大家都尽可能贴近根部，但我们不可能让所有叶子都最贴近根部。</p><p>例如右侧只有一个叶子节点，他自己是深度最低了，但代价是左边全部挤在一条链表上了！这不公平。</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/binary_tree_almost_worst_case.png" class="" title="binary_tree_almost_worst_case"><p>所以要最大化二分查找的效率，我们真正需要的是让所有叶子节点都尽可能“平等”！</p><h3 id="红黑树-vs-平衡树"><a href="#红黑树-vs-平衡树" class="headerlink" title="红黑树 vs 平衡树"></a>红黑树 vs 平衡树</h3><p>为了避免二叉树长成畸形，陷入一边倒的情况。我们需要在每次插入后，检查二叉树是否深度差距过大。</p><p>如果差的太多了，就需要进行一系列矫正操作，“劫富济贫”，把太长的枝干砍断，接在短的地方，尽可能保持所有叶子路径的深度差不多，这个“劫富济贫”的动作就是**平衡操作 (balancing)**。</p><p>问题是，最大能容忍叶子节点之间多大的深度差才开始矫正？针对这个问题，二叉排序树分为两派：</p><h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>最理想的情况下，一颗含有 NN 个节点的二叉树，至少需要有 ⌈logN⌉⌈log⁡N⌉ 深度。</p><p>这就是平衡树（AVL），他强制保证整个树处于完美的平衡状态，每个叶子节点之间的深度差距不会超过 1（当节点数量 NN 不是 2 的整数倍时，这是不得不存在的 1 格差距）。</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/balanced_binary_tree.png" class="" title="balanced_binary_tree"><ul><li>优点：始终保持最完美的平衡，平均复杂度和最坏复杂度最低。所以平衡树的查找性能是最好的。</li><li>缺点：然而始终保持完美的平衡意味着，几乎每插入一个元素（可能会突然产生深度差距超过 1 的情况），就立即需要平衡一次。平衡一次的开销是比较大的，所以平衡树的性能是插入性能是比较差的。</li></ul><p>平衡树实现平衡的方式是“旋转”，他能始终保持最低的深度差：</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/avltree_right_rotate_with_grandchild.png" class="" title="avltree_right_rotate_with_grandchild"><blockquote><p>这里的细节我们不会深究，那是数据结构课的内容，届时会带大家手搓平衡树和红黑树，本期只是稍微了解 map 常见的底层实现，帮助你理解为什么 map 是有序容器。</p></blockquote><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>而红黑树认为，我们不需要总是保持深度差距为 1 那么小，我们只需要保证最深叶子和最浅叶子的深度差不超过 2 倍即可。</p><p>例如最浅的一个叶子是 6 深度，另一个最深的叶子可以是 12 深度。只有当最深的叶子超过 12 深度时，红黑树才会开始主动干预平衡，避免继续畸形发展下去。</p><ul><li>缺点：树可能有一定的一边倒情况，平均复杂度稍微降低，最坏复杂度可以达到原来的 2 倍！</li><li>优点：因为对不平衡现象更加宽松，正常插入时基本不需要平衡，只有特别扭曲了才会下场“救急”。所以红黑树是牺牲了一部分查找性能，换取了更好的插入和删除性能。</li></ul><p>总之，如果你的用况是插入比较少，但是查询非常多，那就适合用平衡树。</p><p>由于换来的这部分插入和删除性能实际上比损失的查找性能多，而 map 常见的用况确实需要经常增删改查，所以现在 C++ 标准库的 map 底层都是基于红黑树实现的。</p><blockquote><p>如果你的需求是大量查找的话，完全可以考虑用查找平均复杂度低至 O(1)O(1) 的哈希表 unordered_map。</p><p>如果是一次性插入完毕后不会再修改，还可以用完美哈希表（frozen_map），他会为你的键值序列专门生成一个专用的哈希函数，编译期确定，且保证完全无冲突。例如你在做一种语言编译器，有很多“关键字”，比如“if”、“while”，你需要运行时频繁的查找这些关键字，而关键字有哪些在编译期是固定的，那就很适合用完美哈希。</p></blockquote><h4 id="红黑树实现平衡的秘密"><a href="#红黑树实现平衡的秘密" class="headerlink" title="红黑树实现平衡的秘密"></a>红黑树实现平衡的秘密</h4><p>红黑树是如何保证最深叶子和最浅叶子的深度差不超过 2 倍的呢？</p><p>他设定了这样 5 条规则：</p><ol><li>节点可以是红色或黑色的。</li><li>根节点总是黑色的。</li><li>所有叶子节点都是黑色（叶子节点就是 NULL）。</li><li>红色节点的两个子节点必须都是黑色的。</li><li>从任一节点到其所有叶子节点的路径都包含相同数量的黑色节点。</li></ol><p>看起来好像很复杂，但实际上大多是废话，有用的只是 4 和 5 这两条。</p><p>规则 4 翻译一下就是：不得出现相邻的红色节点（相邻指两个节点是父子关系）。这条规则还有一个隐含的信息：黑色节点可以相邻！</p><p>规则 5 翻译一下就是：从根节点到所有底层叶子的距离（以黑色节点数量计），必须相等。</p><p>因为规则 4 的存在，红色节点不可能相邻，也就是说最深的枝干只能是：红-黑-红-黑-红-黑-红-黑。</p><p>结合规则 5 来看，也就是说每条枝干上的黑色节点数量必须相同，因为最深的枝干是 4 个黑节点了，所以最浅的枝干至少也得有 4 个节点全是黑色的：黑-黑-黑-黑。</p><p>可以看到，规则 4 和规则 5 联合起来实际上就保证了：最深枝干的深度不会超过最浅枝干的 2 倍。</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/Red-black_tree_example.svg.png" class="" title="Red-black_tree_example"><p>如果超出了 2 倍，就不得不破坏红黑树的规则 4 或 5，从而触发“劫富济贫”的平衡操作，从而阻止了二叉树过于畸形化。</p><p>红黑树如何实现“劫富济贫”的细节我们就不再多谈了，点到为止，接下来直接进入正题：</p><h2 id="开始使用-map-容器"><a href="#开始使用-map-容器" class="headerlink" title="开始使用 map 容器"></a>开始使用 map 容器</h2><p>创建一个 map 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br></pre></td></tr></table></figure><p>一开始 map 初始是空的，如何插入一些初始数据？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;</span><br><span class="line">config[<span class="string">&quot;delay&quot;</span>] = <span class="number">211</span>;</span><br></pre></td></tr></table></figure><p>数据插入成功了，根据键查询对应的值？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]);</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;delay&quot;</span>]);</span><br></pre></td></tr></table></figure><p>查询时建议用 <code>.at(key)</code> 而不是 <code>[key]</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;delay&quot;</span>));</span><br></pre></td></tr></table></figure><hr><p>老生常谈的问题：map 中存 string 还是 const char *？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;    <span class="comment">// 常量区的 &quot;hello&quot;</span></span><br><span class="line"><span class="type">char</span> key[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// key 的地址在栈上</span></span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;        <span class="comment">// 栈上变量的 key = &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m);              <span class="comment">// 两个重复的键 &quot;hello&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;hello: old, hello: <span class="keyword">new</span>&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，任何时候都务必用 string！别用 C 语言老掉牙的 const char *，太危险了。</p><p>const char * 危险的原因：</p><ol><li>const char * 的 &#x3D;&#x3D; 判断的是指针的相等，两个 const char * 只要地址不同，即使实际的字符串相同，也不会被视为同一个元素（如上代码案例所示）。导致 map 里会出现重复的键，以及按键查找可能找不到等。</li><li>保存的是弱引用，如果你把局部的 char [] 或 string.c_str() 返回的 const char * 存入 map，等这些局部释放了，map 中的 const char * 就是一个空悬指针了，会造成 segfault。</li></ol><hr><p>请用安全的 string：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">string key = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>);  <span class="comment">// string 的 == 运算符是经过重载的，比较的是字符串里面的内容相等，而不是地址相等</span></span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>描述</th><th>C++</th><th>Java</th><th>Python</th></tr></thead><tbody><tr><td>内容相等</td><td><code>string(&quot;hello&quot;) == string(&quot;hello&quot;)</code></td><td><code>&quot;hello&quot;.equals(&quot;hello&quot;)</code></td><td><code>&#39;hello&#39; == &#39;hello&#39;</code></td></tr><tr><td>地址相等</td><td><code>&quot;hello&quot; == &quot;hello&quot;</code></td><td><code>&quot;hello&quot; == &quot;hello&quot;</code></td><td><code>id(&#39;hello&#39;) == id(&#39;hello&#39;)</code></td></tr></tbody></table><hr><p>如果你精通对象生命周期分析，能保证 key 指向的字符串活的比 m 久，想要避免拷贝，节省性能。</p><p>string 的弱引用版本：string_view，同样可以用封装了正确的 &#x3D;&#x3D; 运算符，会比较字符串内容而不是地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string_view, string_view&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">string_view key = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 此处 m 是栈上变量，key 是弱引用指向全局常量区（rodata），key 比 m 活得久，没有空悬指针问题</span></span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>⚠️ string_view 属于不建议初学者使用的优化小寄巧：有手之前，非常好用。</p><blockquote><p>注：map 实际上完全没有用到 &#x3D;&#x3D;，用到的只有 &lt; 运算符，当需要判定 <code>a == b</code> 时，他会转而用 <code>!(a &lt; b || b &lt; a)</code> 来判定。</p></blockquote><blockquote><p>string_view 也具有正确的 <code>hash&lt;string_view&gt;</code> 特化，因此也可以用做 unordered_map 的键类型。string_view 试图和 string 表现得完全一样，区别在于他是个弱引用，不持有对象，拷贝构造函数是浅拷贝。string_view 大小只有 16 个字节，内部是一个 const char * 和 size_t，但封装了正确的 &#x3D;&#x3D;，&lt;，&gt; 和 hash。</p></blockquote><hr><p>C++11 新特性——花括号初始化列表，允许创建 map 时直接指定初始数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123; &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;, &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>通常我们会换行写，一行一个键值对，看起来条理更清晰：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));  <span class="comment">// 985</span></span><br></pre></td></tr></table></figure><hr><p>总结花括号初始化语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt; m = &#123;</span><br><span class="line">    &#123;k1, v1&#125;,</span><br><span class="line">    &#123;k2, v2&#125;,</span><br><span class="line">    ...,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让 map 初始就具有这些数据。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>等号可以省略（这其实相当于是在调用 map 的构造函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以先构造再赋值给 auto 变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> config = map&lt;string, <span class="type">int</span>&gt;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>都是等价的。</p><p>作为函数参数时，可以用花括号初始化列表就地构造一个 map 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(map&lt;string, <span class="type">int</span>&gt; config)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myfunc</span>(map&lt;string, <span class="type">int</span>&gt;&#123;               <span class="comment">// 直接创建一个 map 传入</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于 <code>myfunc</code> 函数具有唯一确定的重载，要构造的参数类型 <code>map&lt;string, int&gt;</code> 可以省略不写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myfunc</span>(&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数这边，通常还会加上 <code>const &amp;</code> 修饰避免不必要的拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(map&lt;string, <span class="type">int</span>&gt; <span class="type">const</span> &amp;config)</span></span>;</span><br></pre></td></tr></table></figure><hr><p>从 vector 中批量导入键值对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(kvs.begin(), kvs.end())</span></span>;</span><br></pre></td></tr></table></figure><p>与刚刚花括号初始化的写法等价，只不过是从现有的 vector 中导入。同样的写法也适用于从 array 导入。</p><blockquote><p>如果记不住这个写法，也可以自己手写 for 循环遍历 vector 逐个逐个插入 map，效果是一样的。</p></blockquote><p>冷知识，如果不是 vector 或 array，而是想从传统的 C 语言数组中导入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, <span class="type">int</span>&gt; kvs[] = &#123;  <span class="comment">// C 语言原始数组</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(kvs, kvs + <span class="number">2</span>)</span></span>;                    <span class="comment">// C++98</span></span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(std::begin(kvs), std::end(kvs))</span></span>;  <span class="comment">// C++17</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>std::begin</code> 和 <code>std::end</code> 为 C++17 新增函数，专门用于照顾没法有成员函数 <code>.begin()</code> 的 C 语言数组。类似的全局函数还有 <code>std::size</code> 和 <code>std::data</code> 等……他们都是既兼容 STL 容器也兼容 C 数组的。</p></blockquote><hr><p>重点来了：如何根据键查询相应的值？</p><p>很多同学都知道 map 具有 [] 运算符重载，[] 里写要查询的键就可以返回对应值，也可以用 &#x3D; 往里面赋值，和某些脚本语言一样直观易懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;       <span class="comment">// 把 config 中键 timeout 对应值设为 985</span></span><br><span class="line"><span class="keyword">auto</span> val = config[<span class="string">&quot;timeout&quot;</span>];  <span class="comment">// 读取 config 中键 timeout 对应值</span></span><br><span class="line"><span class="built_in">print</span>(val);                    <span class="comment">// 985</span></span><br></pre></td></tr></table></figure><p>但其实用 [] 去<strong>读取元素</strong>是很不安全的，下面我会做实验演示这一点。</p><hr><p>沉默的 []，无言的危险：当键不存在时，会返回 0 而不会出错！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]); <span class="comment">// 985</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;tmeout&quot;</span>]);  <span class="comment">// 默默返回 0</span></span><br><span class="line"><span class="number">985</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>当查询的键值不存在时，[] 会默默创建并返回 0，而不会爆出任何错误。</p><p>这非常危险，例如一个简简单单的拼写错误，就会导致 map 的查询默默返回 0，你还在那里找了半天摸不着头脑，根本没发现错误原来在 map 这里。</p><hr><p>爱哭爱闹的 at()，反而更讨人喜欢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));  <span class="comment">// 985</span></span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;tmeout&quot;</span>));   <span class="comment">// 该键不存在！响亮地出错</span></span><br><span class="line"><span class="number">985</span></span><br><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::out_of_range&#x27;</span></span><br><span class="line">  <span class="built_in">what</span>():  <span class="function">map::at</span></span><br><span class="line"><span class="function"><span class="title">Aborted</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><p>有经验的老手都明白一个道理：<strong>及时奔溃</strong>比<strong>容忍错误</strong>更有利于调试。即 fail-early, fail-loudly<a href="https://142857.red/book/stl_map/#fn:1">1</a> 原则。</p><p>例如 JS 和 Lua 的 [] 访问越界不报错而是返回 undefined &#x2F; nil，导致实际出错的位置在好几十行之后，无法定位到真正出错的位置，这就是为什么后来发明了错误检查更严格的 TS。</p><p>使用 at() 可以帮助你更容易定位到错误，是好事。</p><hr><blockquote><p>在官方文档和各种教学课件中，都会展示一个函数的“原型”来讲解。</p><p>原型展现了一个函数的名称，参数类型，返回类型等信息，掌握了函数的原型就等于掌握了函数的调用方法。</p><p>本课程后面也会大量使用，现在来教你如何看懂成员函数的原型。</p></blockquote><p>假设要研究的类型为 <code>map&lt;K, V&gt;</code>，其中 K 和 V 是模板参数，可以替换成你具体的类型。</p><p>例如当我使用 <code>map&lt;string, int&gt;</code> 时，就把下面所有的 K 替换成 string，V 替换成 int。</p><p><code>map&lt;K, V&gt;</code> 的 [] 和 at 员函数，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K <span class="type">const</span> &amp;k);</span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure><p>可见 operator[] 只有一个版本，at 居然有名字相同的两个！这样不会发生冲突吗？</p><p>这是利用了 C++ 的“重载”功能，重载就是同一个函数有多个不同的版本，各个版本的参数类型不同。</p><hr><p>同理，编译器也是会根据调用时你传入的参数类型，决定要调用重载的哪一个具体版本。</p><ul><li>C 语言没有重载，函数名字相同就会发生冲突，编译器会当场报错。</li><li>C++ 支持重载，只有当函数名字相同，参数列表也相同时，才会发生冲突。</li><li>返回值类型不影响重载，重载只看参数列表。</li></ul><p>菜鸟教程上对 C++ 重载的解释<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><blockquote><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p><p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p></blockquote><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure><p>但是上面这两个 at 函数的参数类型都是 <code>K const &amp;</code>，为什么可以重载呢？</p><p>注意看第二个版本最后面多了一个 const 关键字，这种写法是什么意思？对其进行祛魅化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(map&lt;K, V&gt; *<span class="keyword">this</span>, K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(map&lt;K, V&gt; <span class="type">const</span> *<span class="keyword">this</span>, K <span class="type">const</span> &amp;k)</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure><p>原来加在函数括号后面的 const，实际上是用于修饰 this 指针的！</p><blockquote><p>该写法仅供示意，并不是真的可以把 this 写成参数</p></blockquote><p>所以两个 at 的参数列表不同，不同在于传入 this 指针的类型，所以可以重载，不会冲突。</p><ul><li>当 map 对象为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; const *</code>，所以只能调用第二个版本的 at。</li><li>当 map 对象不为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; *</code>，两个重载都可以调用，但由于第一个重载更加符合，所以会调用第一个版本的 at。</li></ul><blockquote><p>有趣的是，C++23 支持了显式对象形参（deducing-this），this 也能像普通参数一样定义了！上面的代码可以写成：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">map</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function">V &amp;<span class="title">at</span><span class="params">(<span class="keyword">this</span> map &amp;self, K <span class="type">const</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数体内可以使用self代替原来的this（this将不再可用）</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(<span class="keyword">this</span> map <span class="type">const</span> &amp;self, K <span class="type">const</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>刚刚解释了函数重载，那么运算符重载呢？</p><p>因为原本 C 语言就有 [] 运算符，不过那只适用于原始指针和原始数组。而 C++ 允许也 [] 运算符支持其他用户自定义类型（比如 std::map），和 C 语言自带的相比就只有参数类型不同（一个是原始数组，一个是 std::map），所以和函数重载很相似，这就是运算符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;key&quot;</span>];</span><br></pre></td></tr></table></figure><p>会被编译器“翻译”成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="keyword">operator</span>[](<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码并非仅供示意，是可以通过编译运行的。</p><blockquote><p>operator[] 虽然看起来很复杂一个关键字加特殊符号，其实无非就是个特殊的函数名，学过 Python 的童鞋可以把他想象成 <code>__getitem__</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K <span class="type">const</span> &amp;k);</span><br></pre></td></tr></table></figure><p>结论：[] 运算符实际上是在调用 operator[] 函数。</p><blockquote><p>所有的所谓“运算符重载函数”实际上都是一个特殊的标识符，以<code>operator</code> + 运算符的形式，他们两个组成一个整体，你还可以试试 <code>string(&quot;hel&quot;).operator+(&quot;lo&quot;)</code>，和 <code>string(&quot;hel&quot;) + &quot;lo&quot;</code> 是等价的。</p></blockquote><hr><p>因为 operator[] 这个成员函数后面没有 const 修饰，因此当 map 修饰为 const 时编译会不通过<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; config = &#123;  <span class="comment">// 此处如果是带 const &amp; 修饰的函数参数也是同理</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]);          <span class="comment">// 编译出错</span></span><br><span class="line">/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp: In function ‘<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>’:</span></span><br><span class="line"><span class="function">/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp:<span class="number">10</span>:<span class="number">23</span>: error: passing ‘const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, int&gt;’ as ‘this’ argument discards qualifiers [-fpermissive]</span></span><br><span class="line"><span class="function">   <span class="number">10</span> | print(config[<span class="string">&quot;timeout&quot;</span>]);</span></span><br></pre></td></tr></table></figure><p>编译器说 discards qualifiers，意思是 map 有 const 修饰，但是 operator[] 没有。</p><p>这实际上就是在说：<code>map&lt;K, V&gt; const *this</code> 不能转换成 <code>map&lt;K, V&gt; *this</code>。</p><p>有 const 修饰的 map 作为 this 指针传入没 const 修饰的 operator[] 函数，是减少了修饰（discards qualifers）。</p><p>C++ 规定传参时只能增加修饰不能减少修饰：只能从 <code>map *</code> 转换到 <code>map const *</code> 而不能反之。</p><p>所以对着一个 const map 调用非 const 的成员函数 operator[] 就出错了，相比之下 at() 就可以在 const 修饰下编译通过。</p><hr><p>为什么 operator[] 是非 const 修饰的呢？通常来说，一个成员函数不是 const，意味着他会<strong>就地修改 this 对象</strong>。</p><p>其实，operator[] 发现所查询的键值不存在时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;tmeout&quot;</span>]);  <span class="comment">// 有副作用！</span></span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>, <span class="string">&quot;tmeout&quot;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>会自动创建那个不存在的键值！</strong></p><p>你以为你只是观察了一下 map 里的 “tmeout” 元素，却意外改变了 map 的内容，薛定谔直呼内行。</p><hr><p>为什么把 [] 设计的这么危险？</p><p>既然已经有更安全的 .at()，为什么还要让 [] 继续存在呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>) = <span class="number">985</span>;  <span class="comment">// 键值不存在，报错！</span></span><br><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;     <span class="comment">// 成功创建并写入 985</span></span><br></pre></td></tr></table></figure><p>由上可见，当我们写入一个本不存在的键值的时候，恰恰需要 [] 的“自动创建”这一特性，这是 at() 所不具有的。</p><p>总结：读取时应该用 at() 更安全，写入时才需要用带有自动创建功能的 []。</p><blockquote><p>许多第三方库，例如 jsoncpp，他们的字典类型也使用类似的接口，at() 负责读，[] 负责写，分工明确！</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>-<br>  读取元素时，统一用 at()</p><ul><li>写入元素时，统一用 []</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = val;</span><br></pre></td></tr></table></figure><p>为什么其他语言比如 Python，只有一个 [] 就行了呢？而 C++ 需要两个？</p><ul><li>因为 Python 会检测 [] 位于等号左侧还是右侧，根据情况分别调用 <code>__getitem__</code> 或者 <code>__setitem__</code>。</li><li>C++ 编译器没有这个特殊检测，也检测不了，因为 C++ 的 [] 只是返回了个引用，并不知道 [] 函数返回以后，你是拿这个引用写入还是读取。为了保险起见他默认你是写入，所以先帮你创建了元素，返回这个元素的引用，让你写入。</li><li>而 Python 的引用是不能用 &#x3D; 覆盖原值的，那样只会让变量指向新的引用，只能用 .func() 引用成员函数或者 +&#x3D; 才能就地修改原变量，这是 Python 这类脚本语言和 C++ 最本质的不同。</li><li>总而言之，我们用 C++ 的 map 读取元素时，需要显式地用 at() 告诉编译器我是打算读取。</li></ul><hr><p>[] 找不到就返回个“默认值”，其实也是很多语言的传统异能了，只有刚好 Python 比较对初学者友好，会自动判断你的 [] 是读取还是写入，如果是读取，当找不到键值时能友善的给你报错。</p><table><thead><tr><th>语言及其关联容器名</th><th>C++ map</th><th>Python dict</th><th>Lua table</th><th>JS HashMap</th><th>Java HashMap</th></tr></thead><tbody><tr><td>找不到键时的行为</td><td>默默返回 0</td><td>报错 KeyError</td><td>默默返回 nil</td><td>默默返回 undefined</td><td>.get()，默默返回 null</td></tr></tbody></table><p>其中 C++ 的 [] 最为恶劣，因为古代 C++ 中并没有一个 null 或 nil 之类的额外特殊常量。</p><p>[] 返回的必须是个具体的类型，由于 [] 不能报错，值的类型又千变万化，<code>map&lt;K, V&gt;</code> 的 [] 只能返回“V 类型默认构造函数创建的值”：对于 int 而言是 0，对于 string 而言是 “”（空字符串）。</p><blockquote><p>也正因如此，如果一个 <code>map&lt;K, V&gt;</code> 中的 V 类型没有默认构造函数，就无法使用 [] 了。看似美好的 [] 只是骗骗小朋友的面子工程，模棱两可，充满危险。高手都使用更专业的写入函数：insert 或 insert_or_assign 代替。这两个函数不需要默认构造函数，还更高效一些，稍后会详细介绍。</p></blockquote><hr><p>at 与 [] 实战演练</p><p>我们现在的甲方是一个学校的大老板，他希望让我们管理学生信息，因此需要建立一个映射表，能够快速通过学生名字查询到相应的学生信息。思来想去 C++ 标准库中的 map 容器最合适。决定设计如下：</p><ul><li>键为学生的名字，string 类型。</li><li>值为一个自定义结构体，Student 类型，里面存放各种学生信息。</li></ul><p>然后自定义一下 Student 结构体，现在把除了名字以外的学生信息都塞到这个结构体里。</p><p>创建 <code>map&lt;string, Student&gt;</code> 对象，变量名为 <code>stus</code>，这个 map 就是甲方要求的学生表，成功交差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;             <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> age;            <span class="comment">// 年龄</span></span><br><span class="line">    string sex;         <span class="comment">// 性别</span></span><br><span class="line">    <span class="type">int</span> money;          <span class="comment">// 存款</span></span><br><span class="line">    set&lt;string&gt; skills; <span class="comment">// 技能</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, Student&gt; stus;</span><br></pre></td></tr></table></figure><hr><p>现在让我们用 <code>[]</code> 大法插入他的个人信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stus[<span class="string">&quot;彭于斌&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;相依&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;樱花粉蜜糖&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;Sputnik02&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>由于 C++11 允许省略花括号前的类型不写，所以 Student 可以省略，简写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stus[<span class="string">&quot;彭于斌&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;相依&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;樱花粉蜜糖&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;Sputnik02&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>又由于 map 支持在初始化时就指定所有元素，我们直接写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Student&gt; stus = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">1000</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;相依&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;樱花粉蜜糖&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Sputnik02&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>现在甲方要求添加一个“培训”函数，用于他们的 C++ 培训课。</p><p>培训函数的参数为字符串，表示要消费学生的名字。如果该名字学生不存在，则应该及时报错。</p><p>每次培训需要消费 2650 元，消费成功后，往技能 skills 集合中加入 “C++”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 这是在栈上拷贝了一份完整的 Student 对象</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这样写是不对的！</p><p><code>stus.at(stuName)</code> 返回的是一个引用 <code>Student &amp;</code> 指向 map 中的学生对象。但是等号左侧，却是个不带任何修饰的 <code>auto</code>，他会被推导为 <code>Student</code>。如何从一个引用 <code>Student &amp;</code> 转换为具体的 <code>Student</code>？找不到 <code>Student(Student &amp;)</code>，但是找到了最接近的 <code>Student(Student const &amp;)</code> 函数（这是编译器自动生成的拷贝构造函数），因此我们拷贝了一份 map 中的学生对象，到栈上的 stu 变量，之后不论如何修改，修改的都是这个栈上对象，而不会对 map 中的学生对象产生任何影响。</p><p>结论：把引用保存到普通变量中，则引用会退化，造成深拷贝！不仅影响性能，还影响功能！stu 已经是一个独立的 Student 对象，对 stu 的修改已经不会影响到 stus.at(stuName) 指向的那个 Student 对象了。</p><p>此时你对这个普通变量的所有修改，都不会同步到 map 中的那个 Student 中去！</p><hr><p>我们现在对相依童鞋进行 C++ 培训：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PeiXunCpp</span>(<span class="string">&quot;相依&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(stus.<span class="built_in">at</span>(<span class="string">&quot;相依&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果发现他的存款一分没少，也没学会 C++：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">id:</span> <span class="number">20220302</span>, <span class="attr">age:</span> <span class="number">21</span>, <span class="attr">sex:</span> <span class="string">&quot;男&quot;</span>, <span class="attr">money:</span> <span class="number">2000</span>, <span class="attr">skills:</span> &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>看来我们的修改没有在 map 中生效？原来是因为我们在 PeiXunCpp 函数里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 在栈上拷贝了一份完整的 Student 对象</span></span><br></pre></td></tr></table></figure><p>一不小心就用了“克隆人”技术！从学生表里的“相依1号”，克隆了一份放到栈上的“相依2号”！</p><p>然后我们扣了这个临时克隆人“相依2号”的钱，并给他培训 C++ 技术。</p><p>然而我们培训的是栈上的临时变量“相依2号”，克隆前的“相依1号”并没有受到培训，也没有扣钱。</p><p>然后呢？残忍的事情发生了！在一通操作培训完“相依2号”后，我们把他送上断头台——析构了！</p><p>而这一切“相依1号”完全不知情，他只知道有人喊他做克隆，然后就回家玩 Java 去了，并没有培训 C++ 的记忆。</p><hr><p>要防止引用退化成普通变量，需要把变量类型也改成引用！这种是浅拷贝，stu 和 stus.at(stuName) 指向的仍然是同一个 Student 对象。用 <code>auto</code> 捕获的话，改成 <code>auto &amp;</code> 就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 在栈上创建一个指向原 Student 对象的引用</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;id: <span class="number">20220302</span>, age: <span class="number">21</span>, sex: <span class="string">&quot;男&quot;</span>, money: <span class="number">-650</span>, skills: &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>终于，正版“相依1号”本体鞋废了 C++！</p><p>之后如果再从“相依1号”身上克隆，克隆出来的“相依n号”也都会具有培训过 C++ 的记忆了。</p><p>引用相当于身份证，我们复印了“相依”的身份证，身份证不仅复印起来比克隆一个大活人容易（拷贝开销）从而提升性能，而且通过身份证可以找到本人，对身份证的修改会被编译器自动改为对本人的修改，例如通过“相依”的身份证在银行开卡等，银行要的是身份证，不是克隆人哦。</p><hr><p>引用是一个烫手的香香面包，普通变量就像一个臭臭的答辩马桶，把面包放到马桶（auto）里，面包就臭掉，腐烂掉，不能吃了！要让面包转移阵地了以后依然好吃，需要放到保鲜盒（auto &amp;）里。</p><p>这就是 C++ 的 decay（中文刚好是“退化”、“变质”的意思）规则。</p><p>以下都是“香香面包”，放进马桶里会变质：</p><ul><li><code>T &amp;</code> 会变质成 <code>T</code>（引用变质成普通变量）</li><li><code>T []</code> 会变质成 <code>T *</code>（数组变质成首地址指针）</li><li><code>T ()</code> 会变质成 <code>T (*)()</code>（函数变质成函数指针）</li></ul><p>在函数的参数中、函数的返回值中、auto 捕获的变量中，放入这些“香香面包”都会发生变质！</p><p>如何避免变质？那就不要用马桶（普通变量）装面包呗！用保鲜盒（引用变量）装！</p><ul><li>避免引用 <code>T &amp;t</code> 变质，就得把函数参数类型改成引用，或者用 <code>auto &amp;</code>，<code>auto const &amp;</code> 捕获才行。</li><li>避免原生数组 <code>T t[N]</code> 变质，也可以改成引用 <code>T (&amp;t)[N]</code>，但比较繁琐，不如直接改用 C++11 封装的安全静态数组 <code>array&lt;T, N&gt;</code> 或 C++98 就有的安全动态数组 <code>vector&lt;T&gt;</code>。</li><li>避免函数 <code>T f()</code> 变质，可以 <code>T (&amp;f)()</code>，但繁琐，不如直接改用 C++11 的函数对象 <code>function&lt;T()&gt;</code>。</li></ul><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/autodecays.png" class="" title="autodecays"><hr><h3 id="C-语言的退化规则真是害人不浅"><a href="#C-语言的退化规则真是害人不浅" class="headerlink" title="C 语言的退化规则真是害人不浅"></a>C 语言的退化规则真是害人不浅</h3><p>题外话：邪恶的退化规则造成空悬指针的案例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> <span class="type">arr_t</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">arr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> ret;</span><br><span class="line">    <span class="built_in">memcpy</span>(ret, val, <span class="built_in">sizeof</span>(<span class="type">arr_t</span>));  <span class="comment">// 对 val 做一些运算, 把计算结果保存到 ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// double [10] 自动变质成 double *</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> val = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">func</span>(val);             <span class="comment">// 此处 auto 会被推导为 double *</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">span</span>(ret, ret + <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><p>修复方法：别再用 C 语言的煞笔原始人数组了！用 C++ 封装好的 array，无隐患</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>, 10&gt; <span class="type">arr_t</span>;  <span class="comment">// 如需动态长度，改用 vector 亦可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">arr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> ret;</span><br><span class="line">    ret = val;  <span class="comment">// 对 val 做一些运算, 把计算结果保存到 ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> val = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">func</span>(val);</span><br><span class="line">    <span class="built_in">print</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>如果你还是学不会怎么保留香香引用的话，土办法：也可以在修改后再次用 [] 写回学生表。这样学生表里不会 C++ 的“相依1号”就会被我们栈上培训过 C++ 的“相依1号”覆盖，现在学生表里的也是有 C++ 技能的“相依”辣！只不过需要翻来覆去克隆了好几次比较低效而已，至少能用了，建议只有学不懂引用的童鞋再用这种保底写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 克隆了一份“相依2号”</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    stus[stuName] = stu;          <span class="comment">// “相依2号”夺舍，把“相依1号”给覆盖掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要根据学号进行查找呢？那就以学号为键，然后把学生姓名放到 Student 结构体中。</p><p>如果同时有根据学号进行查找和根据姓名查找两种需求呢？</p><p>同时高效地根据多个键进行查找，甚至指定各种条件，比如查询所有会 C++ 的学生等，这可不是 map 能搞定的，或者说能搞定但不高效（最后往往只能暴力遍历查找，时间复杂度太高）。这是个专门的研究领域，称为：关系数据库。</p><p>关系数据库的实现有 MySQL，SQLite，MongoDB 等。C++ 等编程语言只需调用他们提供的 API 即可，不必自己手动实现这些复杂的查找和插入算法。</p><p>这就是为什么专业的“学生管理系统”都会用关系数据库，而不是自己手动维护一个 map。关系数据库底层的数据结构更复杂，但经过高度封装，效率更高，提供的功能也更全面，用起来也比较无感。何况 map 存在内存中，电脑一关机，学生数据就没了！而数据库可以把数据持久化到磁盘中，相当于在磁盘里构建出了一颗查找树，关机后数据依然保持。</p><p>查询 map 中元素的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>使用 <code>m.size()</code> 获得的 map 大小，或者说其中元素的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 0</span></span><br><span class="line">m[<span class="string">&quot;fuck&quot;</span>] = <span class="number">985</span>;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 1</span></span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = <span class="number">211</span>;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><p>应用举例：给每个键一个独一无二的计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&quot;fuck&quot;</span>] = m.<span class="built_in">size</span>();</span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = m.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><blockquote><p>需要 C++17 以上的版本，才能保证等号右边的 <code>m.size()</code> 先于 <code>m[&quot;fuck&quot;]</code> 求值。C++14 中上面这段代码行为未定义，需要改用 <code>m.insert(&#123;&quot;fuck&quot;, m.size()&#125;)</code> 的写法（函数参数总是优先于函数求值，这保证 <code>m.size()</code> 先求值，然后才发生元素插入）。</p></blockquote><hr><p>判断一个键是否存在：count 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>count 返回容器中键和参数 k 相等的元素个数，类型为 size_t（无符号 64 位整数）。</p><p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p><p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p><hr><p>因此可以直接通过 count 的返回值是否为 0 判断一个键在 map 中是否存在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">count</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在fuck，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到fuck&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">count</span>(<span class="string">&quot;dick&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在dick，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;suck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到dick&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">存在fuck，其值为 <span class="string">&quot;rust&quot;</span></span><br><span class="line">找不到dick</span><br></pre></td></tr></table></figure><p>C++20 中建议改用返回类型为 <code>bool</code> 的 <code>contains</code> 函数，函数名和类型更加一目了然，但实际效果和 <code>count</code> 是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">contains</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在fuck，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到fuck&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="你知道吗？-的妙用"><a href="#你知道吗？-的妙用" class="headerlink" title="你知道吗？[] 的妙用"></a>你知道吗？[] 的妙用</h2><p>除了写入元素需要用 [] 以外，还有一些案例中合理运用 [] 会非常的方便。</p><p>[] 的效果：当所查询的键值不存在时，会调用默认构造函数创建一个元素<a href="https://142857.red/book/stl_map/#fn:1">1</a>。</p><ul><li>对于 int, float 等数值类型而言，默认值是 0。</li><li>对于指针（包括智能指针）而言，默认值是 nullptr。</li><li>对于 string 而言，默认值是空字符串 “”。</li><li>对于 vector 而言，默认值是空数组 {}。</li><li>对于自定义类而言，会调用你写的默认构造函数，如果没有，则每个成员都取默认值。</li></ul><h3 id="妙用举例：出现次数统计"><a href="#妙用举例：出现次数统计" class="headerlink" title="[] 妙用举例：出现次数统计"></a>[] 妙用举例：出现次数统计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; input = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    counter[key]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(counter);</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="number">2</span>, <span class="string">&quot;world&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>活用 [] 自动创建 0 元素的特性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    counter[key]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>古板的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!counter.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">        counter[key] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        counter[key] = counter.<span class="built_in">at</span>(key) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="妙用举例：归类"><a href="#妙用举例：归类" class="headerlink" title="[] 妙用举例：归类"></a>[] 妙用举例：归类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; input = &#123;<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;weak&quot;</span>, <span class="string">&quot;strong&quot;</span>&#125;;</span><br><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(categories);</span><br><span class="line">&#123;<span class="string">&#x27;h&#x27;</span>: &#123;<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;, <span class="string">&#x27;w&#x27;</span>: &#123;<span class="string">&quot;world&quot;</span>, <span class="string">&quot;weak&quot;</span>&#125;, <span class="string">&#x27;s&#x27;</span>: &#123;<span class="string">&quot;strong&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><p>活用 [] 自动创建”默认值”元素的特性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(categories);</span><br></pre></td></tr></table></figure><p>古板的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!categories.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">        categories[key] = &#123;str&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/v2-f2560f634b1e09f81522f29f363827f7_720w.jpg" class="" title="Elegence"><h3 id="妙用举例：线程局部变量"><a href="#妙用举例：线程局部变量" class="headerlink" title="[] 妙用举例：线程局部变量"></a>[] 妙用举例：线程局部变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">concurrent_map&lt;std::thread::id, Data&gt; tls;</span><br><span class="line"><span class="built_in">parallel_for</span>([] &#123;</span><br><span class="line">    Data &amp;data = tls[std::this_thread::<span class="built_in">get_id</span>()];</span><br><span class="line">    ...;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过 <code>thread_local</code> 关键字，可以取代。</p><h2 id="为什么需要反向查找表"><a href="#为什么需要反向查找表" class="headerlink" title="为什么需要反向查找表"></a>为什么需要反向查找表</h2><p>反面典型：查找特定元素在 vector 中的位置（下标）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">array_find</span><span class="params">(vector&lt;string&gt; <span class="type">const</span> &amp;arr, string <span class="type">const</span> &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;fucker&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello在数组中的下标是：&quot;</span>, <span class="built_in">array_find</span>(arr, <span class="string">&quot;fucker&quot;</span>));    <span class="comment">// O(N) 低效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nice在数组中的下标是：&quot;</span>, <span class="built_in">array_find</span>(arr, <span class="string">&quot;nice&quot;</span>));       <span class="comment">// O(N) 低效</span></span><br></pre></td></tr></table></figure><p>每次调用 <code>array_find</code>，都需要 O(N)O(N) 复杂度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fucker在数组中的下标是：0</span><br><span class="line"><span class="built_in">nice</span>在数组中的下标是：2</span><br></pre></td></tr></table></figure><p>如果查询 N 次，则复杂度就是 O(N2)O(N2)。</p><blockquote><p>注：假设 vector 中不存在重复的元素</p></blockquote><h3 id="map-构建下标查找表"><a href="#map-构建下标查找表" class="headerlink" title="map 构建下标查找表"></a>map 构建下标查找表</h3><p>正确做法：构建 vector 的反向查找表，以后查找更高效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;fucker&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; arrinv;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;                <span class="comment">// O(N) 一次性受苦</span></span><br><span class="line">    arrinv[arr[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;反向查找表构建成功：&quot;</span>, arrinv);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fucker在数组中的下标是：&quot;</span>, arrinv.<span class="built_in">at</span>(<span class="string">&quot;fucker&quot;</span>));  <span class="comment">// O(log N) 高效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nice在数组中的下标是：&quot;</span>, arrinv.<span class="built_in">at</span>(<span class="string">&quot;nice&quot;</span>));      <span class="comment">// O(log N) 高效</span></span><br></pre></td></tr></table></figure><p>只有第一次构造反向查找表时，需要 O(N)O(N) 复杂度。</p><p>以后每次调用 <code>map.at</code>，只需要 O(logN)O(log⁡N) 复杂度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反向查找表构建成功：&#123;<span class="string">&quot;day&quot;</span>: 3, <span class="string">&quot;fucker&quot;</span>, 4, <span class="string">&quot;hello&quot;</span>: 0, <span class="string">&quot;nice&quot;</span>: 2, <span class="string">&quot;world&quot;</span>: 1&#125;</span><br><span class="line">fucker在数组中的下标是：4</span><br><span class="line"><span class="built_in">nice</span>在数组中的下标是：2</span><br></pre></td></tr></table></figure><blockquote><p>轶事：在数据库中，这种反向查找表被称为“倒序索引”</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv[arr[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前构造好查找表 O(N)O(N)，以后每次查找只需要 O(logN)O(log⁡N) 复杂度就行。</p><ul><li>（正向查找）已知下标 i，求元素 v：<code>v = arr[i]</code></li><li>（反向查找）已知元素 v，求下标 i：<code>i = arrinv[v]</code></li></ul><p>如果查询 N 次，则复杂度就是 O(NlogN)O(Nlog⁡N)，比优化前高效。</p><blockquote><p>只有当 vector 更新时，才需要重新构建 map。如果 vector 的删除采用 back-swap-erase（见 <a href="https://142857.red/book/cpp_tricks/">C++ 小妙招</a>），那么无需完全重构 map，只需更新 swap 的两个元素即可，总复杂度 O(logN)O(log⁡N)，这样就实现了一个 O(logN)O(log⁡N) 的有下标又能快速查找数组，兼具 map 和 vector 的优势。在之后的数据结构进阶课中我们会详细介绍此类复合数据结构。</p></blockquote><h3 id="map-构建另一个-map-的反向查找表"><a href="#map-构建另一个-map-的反向查找表" class="headerlink" title="map 构建另一个 map 的反向查找表"></a>map 构建另一个 map 的反向查找表</h3><p>map 只能通过值映射到键，能不能反过来通过键查找值？</p><p>案例：构建另一个 map 的反向查找表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; tab = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, string&gt; tabinv;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: tab) &#123;</span><br><span class="line">    tabinv[v] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(tabinv);</span><br></pre></td></tr></table></figure><p>效果就是，键变值，值变键，反一反，两个 map 互为逆运算：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;rust&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fuck&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：要求 tab 中不能存在重复的值，键和值必须是一一对应关系，才能用这种方式构建双向查找表。否则一个值可能对应到两个键，反向表必须是 <code>map&lt;string, vector&lt;string&gt;&gt;</code> 了。</p></blockquote><hr><h2 id="元编程查询成员类型：value-type"><a href="#元编程查询成员类型：value-type" class="headerlink" title="元编程查询成员类型：value_type"></a>元编程查询成员类型：<code>value_type</code></h2><p>STL 容器的元素类型都可以通过成员 <code>value_type</code> 查询，常用于泛型编程（又称元编程）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::value_type      <span class="comment">// int</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::value_type   <span class="comment">// int</span></span><br><span class="line">string::value_type        <span class="comment">// char</span></span><br></pre></td></tr></table></figure><p>此外还有引用类型 <code>reference</code>，迭代器类型 <code>iterator</code>，常迭代器类型 <code>const_iterator</code> 等。</p><p>曾经在 C++98 中很常用，不过自从 C++11 有了 auto 和 decltype 以后，就不怎么用了，反正能自动推导返回类型。</p><p>C++23:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;elem: arr) &#123;</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;elem: arr) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++98:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typename-修饰"><a href="#typename-修饰" class="headerlink" title="typename 修饰"></a>typename 修饰</h3><p>当容器有至少一个不确定的类型 T 作为模板参数时，就需要前面加上 <code>typename</code> 修饰了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::value_type;               <span class="comment">// 没有不定类型，不需要</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;T&gt;::value_type;        <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;set&lt;T&gt;&gt;::value_type;   <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, T&gt;::value_type;   <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;K, T&gt;::value_type;     <span class="comment">// 包含有 K、T 是不定类型</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::value_type;       <span class="comment">// 没有不定类型，不需要</span></span><br></pre></td></tr></table></figure><p>如果你搞不清楚，始终加 <code>typename</code> 就行了，反正加多肯定不会有错。你就认为：这就是一个平时可以省略，偶尔不能省略的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> set&lt;<span class="type">int</span>&gt;::value_type;    <span class="comment">// 可以省略，但你加了也没关系</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;T&gt;::value_type;      <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;set&lt;T&gt;&gt;::value_type; <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, T&gt;::value_type; <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;K, T&gt;::value_type;   <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, string&gt;::value_type; <span class="comment">// 可以省略，但你加了也没关系</span></span><br></pre></td></tr></table></figure><blockquote><p>含有 T 的类型表达式称为 dependent-type，根本原因是因为在不知道具体是类型表达式还是值表达式的情况下，编译器无法区分模板的 <code>&lt;</code> 和小于符号 <code>&lt;</code>，以及类型的指针 <code>*</code> 和数值乘法 <code>*</code>。默认会认为是小于符号和数值乘法，加上 <code>typename</code> 后明确前面这一串是类型表达式，才知道这是模板的 <code>&lt;</code> 和指针的 <code>*</code>。</p></blockquote><h3 id="decltype-大法好"><a href="#decltype-大法好" class="headerlink" title="decltype 大法好"></a>decltype 大法好</h3><p>也有更直观的获取 STL 容器元素类型的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arr[<span class="number">0</span>])&gt;; <span class="comment">// T = int</span></span><br></pre></td></tr></table></figure><blockquote><p><code>decltype</code> 必须配合 <code>std::decay_t</code> 才能用！否则会得到引用类型 <code>int &amp;</code>，后续使用中就坑到你！（因为 arr 的 [] 返回的是一个引用类型）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">using</span> T = <span class="keyword">decltype</span>(arr[<span class="number">0</span>]); <span class="comment">// T = int &amp;</span></span><br><span class="line"></span><br><span class="line">T i = <span class="number">0</span>; <span class="comment">// int &amp;i = 0; 后续使用中编译出错！</span></span><br></pre></td></tr></table></figure><hr><h3 id="查询类名小工具"><a href="#查询类名小工具" class="headerlink" title="查询类名小工具"></a>查询类名小工具</h3><p>在本课程的案例代码中附带的 “cppdemangle.h”，可以实现根据指定的类型查询类型名称并打印出来。</p><p>跨平台，需要 C++11，支持 MSVC，Clang，GCC 三大编译器，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;());</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;std::string&gt;());</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;std::wstring::value_type&gt;());</span><br></pre></td></tr></table></figure><p>在我的 GCC 12.2.1 上得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;int &amp;&amp;&quot;</span></span><br><span class="line"><span class="string">&quot;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&quot;</span></span><br><span class="line"><span class="string">&quot;wchar_t&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="map-真正的元素类型究竟是什么？"><a href="#map-真正的元素类型究竟是什么？" class="headerlink" title="map 真正的元素类型究竟是什么？"></a>map 真正的元素类型究竟是什么？</h3><p>map 具有三个成员类型<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><ul><li>元素类型：<code>value_type</code></li><li>键类型：<code>key_type</code></li><li>值类型：<code>mapped_type</code></li></ul><p>后面，将会一直以“元素”称呼官方的“value”，“键”称呼官方的“key”，“值”称呼官方的“mapped”</p><p>用 cppdemangle 做实验，看看这些成员类型具体是什么吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::value_type   <span class="comment">// pair&lt;const int, float&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::key_type     <span class="comment">// int</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::mapped_type  <span class="comment">// float</span></span><br></pre></td></tr></table></figure><p>结论：<code>map&lt;K, V&gt;</code> 的元素类型是 <code>pair&lt;const K, V&gt;</code> 而不是 <code>V</code>。</p><hr><p>疑惑：<code>pair&lt;const K, V&gt;</code> 中，为什么 K 要加 const？</p><p>我们在 set 课中说过，set 内部采用红黑树数据结构保持有序，这样才能实现在 O(logN)O(log⁡N) 时间内高效查找。</p><p>键值改变的话会需要重新排序，如果只修改键值而不重新排序，会破坏有序性，导致二分查找结果错误！所以 set 只提供了不可变迭代器（const_iterator），没有可变的迭代器，不允许用户修改任何元素的值。</p><p>map 和 set 一样也是红黑树，不同在于：map 只有键 K 的部分会参与排序，V 是个旁观者，随便修改也没关系。</p><p>所以 map 有可变迭代器，只是在其值类型 value_type 中给键的部分，K，加上了 const 修饰：不允许修改 K，但可以随意修改 V。</p><p>如果你确实需要修改键值，那么请先取出旧值，把这个键删了，然后再以同样的值重新插入一遍到新的键。相当于重新构建了一个 <code>pair&lt;const K, V&gt;</code> 对象。</p><blockquote><p>C++17 开始也可以用更高效 <code>node_handle</code> 系列 API，避免数据发生移动，稍后介绍。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>begin() 和 end() 迭代器分别指向 map 的首个元素和最后一个元素的后一位。</p><p>其中 end() 迭代器指向的地址为虚空索敌，不可解引用，仅仅作为一个“标志”存在（回顾之前 vector 课）。</p><hr><ul><li>迭代器可以通过 <code>*it</code> 或 <code>it-&gt;</code> 解引用，获取其指向的元素。</li><li>由于 map 内部总是保持有序，map 的首个元素一定是键最小的元素。</li><li>由于 map 内部总是保持有序，map 的最后一个元素一定是键最大的元素。</li></ul><p>例如要查询成绩最好和最坏的学生，可以把成绩当做 key，学生名做 value 依次插入 map，他会帮我们排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; score = &#123;</span><br><span class="line">    &#123;<span class="number">100</span>, <span class="string">&quot;彭于斌&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">80</span>, <span class="string">&quot;樱花粉蜜糖&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;相依&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">60</span>, <span class="string">&quot;Sputnik02&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">string poorestStudent = score.<span class="built_in">begin</span>()-&gt;second;   <span class="comment">// 成绩最差学生的姓名</span></span><br><span class="line">string bestStudent = <span class="built_in">prev</span>(score.<span class="built_in">end</span>())-&gt;second;  <span class="comment">// 成绩最好学生的姓名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最低分:&quot;</span>, poorestStudent);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最高分:&quot;</span>, bestStudent);</span><br><span class="line">最低分: <span class="string">&quot;相依&quot;</span></span><br><span class="line">最高分: <span class="string">&quot;彭于斌&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：仅当确保 <code>score.size() != 0</code> 时才可以解引用，否则 begin() 和 end() 都是虚空迭代器，这时解引用会奔溃。</p></blockquote><hr><p>map 的遍历：古代 C++98 的迭代器大法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, it-&gt;first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意迭代器是一个指向元素的指针，不是元素本身！要用 <code>-&gt;</code> 而不是 <code>.</code>。</p><hr><p>运用 C++11 的 auto 简写一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, it-&gt;first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用 C++17 结构化绑定（structured-binding）语法<a href="https://142857.red/book/stl_map/#fn:1">1</a>直接拆开 pair 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [k, v] = *it;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>map 的遍历：现代 C++17 基于范围的循环（range-based loop）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv: m) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, kv.first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, kv.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时运用 C++17 结构化绑定语法<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如何在遍历的过程中修改值？</p><p>古代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;rust&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    it-&gt;second = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="number">986</span>, <span class="string">&quot;rust&quot;</span>: <span class="number">212</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>如何在遍历的过程中修改值？</p><p>现代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;rust&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="number">985</span>, <span class="string">&quot;rust&quot;</span>: <span class="number">211</span>&#125;</span><br></pre></td></tr></table></figure><p>没有成功修改！为什么？</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Range-based loop 只是个花哨语法糖，他相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [k, v] = *it;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Structured-binding 也只是个花哨语法糖，他相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = *it;</span><br><span class="line">    <span class="keyword">auto</span> k = tmp.first;</span><br><span class="line">    <span class="keyword">auto</span> v = tmp.second;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样保存下来的 v 是个栈上变量，是对原值的一份拷贝，不仅浪费性能，且对 v 的修改不会反映到原 map 中去！</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;  <span class="comment">// 解决方案是在这里加一个小小的 &amp;，让 range-based loop 捕获引用而不是拷贝</span></span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是拆除 Range-based loop 的花哨语法糖，相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[k, v] = *it;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续拆除 Structured-binding 的花哨语法糖，相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;tmp = *it;</span><br><span class="line">    <span class="keyword">auto</span> &amp;k = tmp.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;v = tmp.second;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样保存下来的 v 是个引用，是对原值的引用（用 Rust 的话说叫 borrowed）。不仅避免拷贝的开销节省了性能，而且对 v 的修改会实时反映到原 map 中去。</p><hr><p>总结，当需要在遍历的同时修改 map 中的值时，要用 <code>auto &amp;</code> 捕获引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;  <span class="comment">// 捕获一个引用，写入这个引用会立即作用在原值上</span></span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使不需要修改 map 中的值时，也建议用 <code>auto const &amp;</code> 避免拷贝的开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: m) &#123;   <span class="comment">// 捕获只读的 const 引用，引用避免拷贝开销，const 避免不小心手滑写入</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注：即使捕获为 <code>auto &amp;</code>，由于 map 的元素类型是 <code>pair&lt;const K, V&gt;</code> 所以 K 部分还是会捕获为 <code>K const &amp;</code>，无法写入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;</span><br><span class="line">    k = <span class="string">&quot;key&quot;</span>;    <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">    v = <span class="number">985211</span>;   <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是如果捕获为 <code>auto const &amp;</code> 就两个都不允许写入了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: m) &#123;</span><br><span class="line">    k = <span class="string">&quot;key&quot;</span>;    <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">    v = <span class="number">985211</span>;   <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>m.find(key) 函数，根据指定的键 key 查找元素<a href="https://142857.red/book/stl_map/#fn:1">1</a>。</p><ul><li>成功找到，则返回指向找到元素的迭代器</li><li>找不到，则返回 m.end()</li></ul><p>由于 STL 传统异能之 end() 虚空索敌，他不可能指向任何值，所以经常作为找不到时候缺省的返回值。</p><p>可以用 <code>m.find(key) != m.end()</code> 判断一个元素是否存在，等价于 <code>m.count(key) != 0</code>。</p><p>第二个版本的原型作用是：如果 map 本身有 const 修饰，则返回的也是 const 迭代器。</p><p>为的是防止你在一个 const map 里 find 了以后利用迭代器变相修改 map 里的值。</p><h3 id="count-和-contains-没区别"><a href="#count-和-contains-没区别" class="headerlink" title="count 和 contains 没区别"></a>count 和 contains 没区别</h3><p>实际上 count 和 contains 函数就是基于 find 实现的，性能没有区别，glibc 源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt; 201703L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Finds whether an element with the given key exists.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Key of (key, value) pairs to be located.</span></span><br><span class="line"><span class="comment">       *  @return  True if there is an element with the specified key.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function">      <span class="title">contains</span><span class="params">(<span class="type">const</span> key_type&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">find</span>(__x) != _M_t.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Kt&gt;</span></span><br><span class="line"><span class="function">      <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">      <span class="title">contains</span><span class="params">(<span class="type">const</span> _Kt&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      -&gt; <span class="title">decltype</span><span class="params">(_M_t._M_find_tr(__x), <span class="type">void</span>(), <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t._M_find_tr(__x) != _M_t.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Finds the number of elements with given key.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Key of (key, value) pairs to be located.</span></span><br><span class="line"><span class="comment">       *  @return  Number of elements with specified key.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function only makes sense for multimaps; for map the result will</span></span><br><span class="line"><span class="comment">       *  either be 0 (not present) or 1 (present).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">size_type</span></span><br><span class="line"><span class="function">      <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">find</span>(__x) == _M_t.<span class="built_in">end</span>() ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="comment">// 以下三者等价</span></span><br><span class="line">m.<span class="built_in">contains</span>(key)</span><br><span class="line">m.<span class="built_in">count</span>(key)</span><br><span class="line">m.<span class="built_in">find</span>(key) != m.<span class="built_in">end</span>()</span><br></pre></td></tr></table></figure><h3 id="end-不能解引用"><a href="#end-不能解引用" class="headerlink" title="end 不能解引用"></a>end 不能解引用</h3><p>检查过不是 m.end()，以确认成功找到后，就可以通过 * 运算符解引用获取迭代器指向的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);  <span class="comment">// 寻找 K 为 &quot;fuck&quot; 的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> kv = *it;     <span class="comment">// 解引用得到 K-V 对</span></span><br><span class="line">    <span class="built_in">print</span>(kv);         <span class="comment">// &#123;&quot;fuck&quot;, 985&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(kv.first);   <span class="comment">// &quot;fuck&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(kv.second);  <span class="comment">// 985</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到 fuck！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-的好处"><a href="#find-的好处" class="headerlink" title="find 的好处"></a>find 的好处</h3><p>find 的高效在于，可以把两次查询合并成一次。</p><p>保底写法：开销 2logN2log⁡N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.<span class="built_in">count</span>(<span class="string">&quot;key&quot;</span>)) &#123;    <span class="comment">// 第一次查询，只包含&quot;是否找到&quot;的信息</span></span><br><span class="line">    <span class="built_in">print</span>(m.<span class="built_in">at</span>(<span class="string">&quot;key&quot;</span>));  <span class="comment">// 第二次查询，只包含&quot;找到了什么&quot;的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高效写法：开销 logNlog⁡N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 一次性查询</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;     <span class="comment">// 查询的结果，既包含&quot;是否找到&quot;的信息</span></span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);   <span class="comment">// 也包含&quot;找到了什么&quot;的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-17-语法糖"><a href="#C-17-语法糖" class="headerlink" title="C++17 语法糖"></a>C++17 语法糖</h4><p>C++17 的 if-auto 语法糖如何简化 find 的迭代器判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key2&quot;</span>);  <span class="comment">// 编译器报错：变量 it 重复定义！</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然删去前面的 auto 可以解决问题，但是如果这里是不同类型的 map 就尬了，得另外想一个变量名。</p><p>而 C++17 的 if-auto 语法糖捕获的 it 是限制在当前 if 作用域的，不会跑出去和别人发生冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>); it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key2&quot;</span>); it != m.<span class="built_in">end</span>()) &#123;  <span class="comment">// 这个变量 it 是局域的，不会和上一个局域的 it 产生名字冲突</span></span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>我给 C++ 标准委员会提一个建议，能不能给迭代器加一个 <code>operator bool</code> 代替烦人的 <code>!= m.end()</code>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    _RbTreeNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(iterator <span class="type">const</span> &amp;other) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == other.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那样的话就可以直接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 if-auto 省略分号后面的条件时，默认就是 <code>if (auto it = m.find(&quot;key&quot;); (bool)it)</code></p><h3 id="对-map-而言，迭代器解引用得到的是-pair"><a href="#对-map-而言，迭代器解引用得到的是-pair" class="headerlink" title="对 map 而言，迭代器解引用得到的是 pair"></a>对 map 而言，迭代器解引用得到的是 pair</h3><p>注意 <code>*it</code> 解引用得到的是 <code>pair&lt;const K, V&gt;</code> 类型的键值对，需要 <code>(*it).second</code> 才能获取单独的值 V。</p><p>好在 C 语言就有 <code>-&gt;</code> 运算符作为语法糖，我们可以简写成 <code>it-&gt;second</code>，与 <code>(*it).second</code> 等价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);   <span class="comment">// 寻找 K 为 &quot;fuck&quot; 的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);      <span class="comment">// 迭代器有效，可以直接获得值部分 985</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到 fuck！&quot;</span>);  <span class="comment">// 这个分支里不得用 * 和 -&gt; 运算符解引用 it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下我们查询只需要获取值 V 的部分就行了，直接 <code>it-&gt;second</code> 就可以了✅</p><blockquote><p>注意：find 找不到键时，会返回 <code>m.end()</code>，这是个无效迭代器，只作为标识符使用（类比 Python 中的 find 有时会返回 -1）。</p><p>没有确认 <code>it != m.end()</code> 前，不可以访问 <code>it-&gt;second</code>！那相当于解引用一个空指针，会造成 segfault（更专业一点说是 UB）。</p><p>记住，一定要在 <code>it != m.end()</code> 的分支里才能访问 <code>it-&gt;second</code> 哦！你得先检查过饭碗里没有老鼠💩之后，才能安心吃饭！</p><p>如果你想让老妈（标准库）自动帮你检查有没有老鼠💩，那就用会自动报错的 at（类比 Python 中的 index 找不到直接报错）。</p><p>之所以用 find，是因为有时饭碗里出老鼠💩，是计划的一部分！例如当有老鼠💩时你可以改吃别的零食。而 at 这个良心老妈呢？一发现老鼠💩就拖着你去警察局报案，零食（默认值）也不让你吃了。今日行程全部取消，维权（异常处理，找上层 try-catch 块）设为第一要务。</p></blockquote><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>如果 map 没有 const 修饰，则其 find 返回的 it 也是非 const 迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; cm;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::const_iterator cit = cm.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(cit-&gt;second);  <span class="comment">// OK: 可以读取</span></span><br><span class="line">cit-&gt;second = <span class="number">1</span>;     <span class="comment">// 编译期报错: 不允许写入 const 迭代器指向的值</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);   <span class="comment">// OK: 可以读取</span></span><br><span class="line">it-&gt;second = <span class="number">1</span>;      <span class="comment">// OK: 可以写入</span></span><br></pre></td></tr></table></figure><p><code>it-&gt;second</code> 可以写入，it 是迭代器，迭代器类似于指针，写入迭代器指向的 second 就可以修改 map 里的值部分。</p><p><code>it-&gt;first</code> 是键部分，由于 map 的真正元素类型是 <code>pair&lt;const K, V&gt;</code> 所以这部分无法被修改。</p><hr><p>带默认值的查询</p><p>众所周知，Python 中的 dict 有一个 m.get(key, defl) 的功能，效果是当 key 不存在时，返回 defl 这个默认值代替 m[key]，而 C++ 的 map 却没有，只能用一套组合拳代替：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">count</span>(key) ? m.<span class="built_in">at</span>(key) : defl</span><br></pre></td></tr></table></figure><p>但上面这样写是比较低效的，相当于查询了 map 两遍，at 里还额外做了一次多余的异常判断。</p><p>正常来说是用通用 find 去找，返回一个迭代器，然后判断是不是 end() 决定要不要采用默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">return</span> it != m.<span class="built_in">end</span>() ? it-&gt;second : defl;</span><br></pre></td></tr></table></figure><blockquote><p>饭碗里发现了老鼠💩？别急着报警，这也在我的预料之中：启用 B 计划，改吃 defl 这款美味零食即可！</p><p>如果是良心老妈 at，就直接启用 C 计划：<img src="https://142857.red/book/img/stl/planc.png" alt="Plan C"> 抛出异常然后奔溃了，虽然这很方便我们程序员调试。</p></blockquote><hr><p>由于自带默认值的查询这一功能实在是太常用了，为了把这个操作浓缩到一行，我建议同学们封装成函数放到自己的项目公共头文件（一般是 utils.h 之类的名称）里方便以后使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> M::mapped_type <span class="title">map_get</span></span></span><br><span class="line"><span class="function"><span class="params">( M <span class="type">const</span> &amp;m</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::key_type <span class="type">const</span> &amp;key</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::mapped_type <span class="type">const</span> &amp;defl</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> M::const_iterator it = m.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>, <span class="number">-1</span>);  <span class="comment">// 如果配置文件里不指定，则默认 timeout 为 -1</span></span><br></pre></td></tr></table></figure><hr><p>这样还不够优雅，我们还可以更优雅地运用 C++17 的函数式容器 optional：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;</span><br><span class="line"><span class="function">std::optional&lt;<span class="keyword">typename</span> M::mapped_type&gt; <span class="title">map_get</span></span></span><br><span class="line"><span class="function"><span class="params">( M <span class="type">const</span> &amp;m</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::key_type <span class="type">const</span> &amp;key</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> M::const_iterator it = m.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不到时就返回 nullopt，找到就返回含有值的 optional。</p><p>调用者可以自行运用 optional 的 value_or 函数<a href="https://142857.red/book/stl_map/#fn:1">1</a>指定找不到时采用的默认值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>).<span class="built_in">value_or</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>如果要实现 at 同样的找不到就自动报错功能，那就改用 value 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>).<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure><p>optional 具有 <code>operator bool</code> 和无异常的 <code>operator*</code>，所以也可以配合 if-auto 语法糖使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> o_val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> val = *o_val;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到了&quot;</span>, val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到时的处理方案...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> o_val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (o_val) &#123;</span><br><span class="line">    <span class="type">int</span> val = *o_val;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到了&quot;</span>, val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到时的处理方案...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上是典型的函数式编程范式 (FP)，C++20 还引入了更多这样的玩意<a href="https://142857.red/book/stl_map/#fn:2">2</a>，等有空会专门开节课为大家一一介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> even = [] (<span class="type">int</span> i) &#123; <span class="keyword">return</span> <span class="number">0</span> == i % <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> square = [] (<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">          | std::views::<span class="built_in">filter</span>(even)</span><br><span class="line">          | std::views::<span class="built_in">transform</span>(square))</span><br><span class="line">    <span class="built_in">print</span>(i);  <span class="comment">// 0 4 16</span></span><br></pre></td></tr></table></figure><hr><p>现在学习删除元素用的 erase 函数，其原型如下<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>指定键值 key，erase 会删除这个键值对应的元素。</p><p>返回一个整数，表示删除了多少个元素（只能是 0 或 1）。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>erase 运用举例：删除一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">msg.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>erase 的返回值和 count 一样，返回成功删除的元素个数，类型为 size_t（无符号 64 位整数）。</p><p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p><p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p><hr><p>因此可以直接通过 erase 的返回值是否为 0 判断是否删除成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除fuck成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除fuck失败，键不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">erase</span>(<span class="string">&quot;dick&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除dick成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除dick失败，键不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">删除fuck成功</span><br><span class="line">删除dick失败，键不存在</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;  <span class="comment">// 指定键版</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>;   <span class="comment">// 已知位置版</span></span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>指定键版 erase(key) 实际上需要先调用 find(key) 找到元素位置，然后才能删除，而且还有找不到的可能性。</li><li>而已知位置的话（比如你已经事先用 find 找到了元素位置），可以用 erase(it) 直接用迭代器作为参数</li></ul><p>复杂度不同：</p><ul><li>指定键版 erase(key) 的时间复杂度：O(logN)O(log⁡N)。</li><li>已知位置版 erase(it) 的时间复杂度：O(1)+O(1)+，更高效。</li></ul><p>其中 ++ 代表这是平摊（Amortized）下来的时间复杂度。</p><p>这是因为即使已知位置，erase 有可能涉及树的更新，需要 O(logN)O(log⁡N) 复杂度。</p><p>但是大多数情况下需要的更新很少，平均下来是 O(1)O(1) 的。</p><p>这种情况就会用记号 O(1)+O(1)+ 来表示。</p><hr><p>erase(key) 可能是基于 erase(it) 实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span> </span>&#123;  <span class="comment">// 小彭老师猜想标准库内部</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(key);  <span class="comment">// O(log N)</span></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">this</span>-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">erase</span>(it);        <span class="comment">// O(1)+</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 找到了，删除成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 找不到，没有删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// 开销大的 find(key) 会覆盖小的 erase(it)，所以 erase(key) 的总复杂度为 O(log N)</span></span><br></pre></td></tr></table></figure><hr><p>指定位置版 erase(it) 返回的是删除元素的下一个元素位置。</p><p>由于 map 内部保持键从小到大升序排列，所谓的下一个就是键比当前键大一个的元素，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span> <span class="number">42</span><span class="punctuation">,</span> <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="number">985</span><span class="punctuation">,</span> <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="number">211</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>erase(find(“answer”)) 会返回指向 “hello” 的迭代器，因为 “hello” 最接近且大于 “answer”。</li><li>erase(find(“hello”)) 会返回指向 “world” 的迭代器，因为 “world” 最接近且大于 “hello”。</li><li>erase(find(“world”)) 会返回 end()，因为 “world” 已经是最大键，没有下一个。</li></ul><p>此外 erase(it) 还有性能上的优势：</p><ul><li>指定位置版 erase(it) 的复杂度是 O(1)+O(1)+</li><li>指定键版 erase(key) 的复杂度是 O(logN)O(log⁡N)</li></ul><p>当已知指向要删除元素的迭代器时（例如先通过 find 找到），直接指定那个迭代器比指定键参数更高效。</p><p>删除成绩最差的学生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score.<span class="built_in">erase</span>(score.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><hr><h2 id="一边遍历一边删除部分元素"><a href="#一边遍历一边删除部分元素" class="headerlink" title="一边遍历一边删除部分元素"></a>一边遍历一边删除部分元素</h2><p>常见需求场景：一边遍历一边删除部分元素（错误示范）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(k);  <span class="comment">// 遍历过程中删除当前元素，会导致正在遍历中的迭代器失效，奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><hr><p>引出问题：迭代器失效</p><ul><li>每当往 map 中插入新元素时，原先保存的迭代器不会失效。</li><li>删除 map 中的其他元素时，也不会失效。</li><li><strong>只有当删除的刚好是迭代器指向的那个元素时，才会失效</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = <span class="number">211</span>;</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;dick&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br></pre></td></tr></table></figure><hr><p>map 比起 unordered_map 来，已经是非常稳定，随便增删改查都不会迭代器失效。</p><p>只有一个例外：删除的元素刚好是迭代器指向的。</p><p>你拿着个你朋友家的地址，结果你一发 RPG 导弹把他家炸了，还摸不着头脑“奇怪，明明就是这个地址呀”，这时确实无论如何都不能避免失效，不能怪 map。</p><p>而刚刚的案例中，我们删除的恰好就是当前正在遍历的迭代器正在指向的那个元素（即使你用了 range-based loop 语法糖他背后还是迭代器遍历）。</p><p>而当你对着一个失效的迭代器执行 <code>++it</code> 时，就产生了 segfault 错误。因为红黑树的迭代器要找到“下一个”节点，需要访问这个红黑树节点中存的 <code>next</code> 指针，而这个红黑树节点都已经删除了已经析构了已经释放内存了，里面存的 <code>next</code> 指针也已经释放，被其他系统数据覆盖，这时会访问到错误的指针——野指针。</p><hr><p>所以《好友清除计划》完整的剧情是：</p><p>你有好多朋友，今天你要把他们全炸了。</p><p>1号朋友家里有一个字条，写着2号朋友家的地址。</p><p>2号朋友家里有一个字条，写着3号朋友家的地址。</p><p>…</p><p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it <span class="comment">/* 进入燃烧中的1号朋友家 */</span>) &#123;</span><br><span class="line">    m.<span class="built_in">erase</span>(it);  <span class="comment">// 一发 RPG 导弹炸毁1号朋友家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    m.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="comment">// it 已经失效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是，先进入1号朋友家，安全取出写着2号朋友家地址的字条后，再来一发 RPG 把1号朋友家炸掉。这样才能顺利找到2号朋友家，以此类推继续拆3号……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">auto</span> next_it = it;  <span class="comment">// 先进入1号朋友的家</span></span><br><span class="line">    ++next_it;          <span class="comment">// 拿出写有2号朋友家地址的字条</span></span><br><span class="line">    m.<span class="built_in">erase</span>(it);        <span class="comment">// 再发射 RPG 导弹</span></span><br><span class="line">    it = next_it;       <span class="comment">// 前往2号朋友家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注意到 erase 会返回删除元素的下一个元素的迭代器，也就是说这个 RPG 导弹非常智能，好像他就是专为《好友清除计划》设计的一样：他能在炸毁你朋友的房屋前，自动拿到其中的字条，并把他通过“弹射座椅”弹出来送到门外的你手上，把纸条安全送出来后，再爆炸摧毁你朋友的房屋。这样你就不用冒险进入燃烧的房屋拿字条（迭代器失效导致 segfault），也不用先劳烦您自己先进去一趟房屋拿字条了（上一页中那样提前保存 next_it）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it = m.<span class="built_in">erase</span>(it);        <span class="comment">// 这款 RPG 导弹“智能地”在摧毁你朋友的房屋同时把其中的字条拿出来了!?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只是注意这里 for 循环的步进条件 <code>++it</code> 要删掉，因为智能的 RPG 导弹 <code>it = m.erase(it)</code> 已经帮你步进了。</p></blockquote><hr><p>一边遍历一边删除部分元素（正解<a href="https://142857.red/book/stl_map/#fn:1">1</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;  <span class="comment">// 没有 ++it</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        it = msg.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;good&quot;</span>: <span class="string">&quot;job&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>不奔溃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        it = msg.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奔溃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">// 或者 msg.erase(k);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="C-20-更好的写法：erase-if"><a href="#C-20-更好的写法：erase-if" class="headerlink" title="C++20 更好的写法：erase_if"></a>C++20 更好的写法：erase_if</h3><p>批量删除符合条件的元素（C++20<a href="https://142857.red/book/stl_map/#fn:1">1</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::<span class="built_in">erase_if</span>(msg, [&amp;] (<span class="keyword">auto</span> <span class="type">const</span> &amp;kv) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[k, v] = kv;</span><br><span class="line">    <span class="keyword">return</span> k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;good&quot;</span>: <span class="string">&quot;job&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>如果你搞不懂迭代器这些，这里我提供一个保底写法，先把键提前保存到一个 vector 中去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; keys;             <span class="comment">// vector 或者 set 都可以</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;  <span class="comment">// 先把所有键提前拷贝到临时 vector 里</span></span><br><span class="line">    keys.<span class="built_in">push_back</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;k: keys) &#123;      <span class="comment">// 遍历刚才保存的键</span></span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(k);            <span class="comment">// 键值对已经提前深拷贝到临时 vector 里，这时删除 map 里的键不会奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小彭老师，永远的祛魅大师。</p></blockquote><hr><p>还是搞不懂的话，也可以新建一个 map，条件反之，把不需要删除的元素插入新 map，过滤出需要保留的元素，最后再一次性用新 map 覆盖旧 map。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, string&gt; newmsg;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;   <span class="comment">// 注意这里条件反了，不需要删除的才插入 newmsg</span></span><br><span class="line">        newmsg[k] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">msg = std::<span class="built_in">move</span>(newmsg);        <span class="comment">// 覆盖旧的 map，用更高效的移动赋值函数，O(1) 复杂度</span></span><br></pre></td></tr></table></figure><blockquote><p>小彭老师，永远的保底大师。</p></blockquote><hr><p>接下来开始学习如何插入元素，map 的成员 insert 函数原型如下<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; &amp;&amp;kv)</span></span>;</span><br></pre></td></tr></table></figure><p>他的参数类型就是刚刚介绍的 <code>value_type</code>，也就是 <code>pair&lt;const K, V&gt;</code>。</p><p>pair 是一个 STL 中常见的模板类型，<code>pair&lt;K, V&gt;</code> 有两个成员变量：</p><ul><li>first：K 类型，表示要插入元素的键</li><li>second：V 类型，表示要插入元素的值</li></ul><p>我称之为”键值对”。</p><hr><p>试着用 insert 插入键值对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;</span><br><span class="line">p.first = <span class="string">&quot;fuck&quot;</span>;  <span class="comment">// 键</span></span><br><span class="line">p.second = <span class="number">985</span>;    <span class="comment">// 值</span></span><br><span class="line">m.<span class="built_in">insert</span>(p);  <span class="comment">// pair&lt;string, int&gt; 可以隐式转换为 insert 参数所需的 pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;fuck&quot;</span><span class="punctuation">:</span> <span class="number">985</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>简化 insert</p><ol><li>直接使用 pair 的构造函数，初始化 first 和 second</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">insert</span>(p);</span><br></pre></td></tr></table></figure><ol><li>不用创建一个临时变量，pair 表达式直接作为 insert 函数的参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>));</span><br></pre></td></tr></table></figure><ol><li>可以用 <code>std::make_pair</code> 这个函数，自动帮你推导模板参数类型，省略 <code>&lt;string, int&gt;</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>));  <span class="comment">// 虽然会推导为 pair&lt;const char *, int&gt; 但还是能隐式转换为 pair&lt;const string, int&gt;</span></span><br></pre></td></tr></table></figure><ol><li>由于 insert 函数原型已知参数类型，可以直接用 C++11 的花括号初始化列表 {…}，无需指定类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;);           <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure><hr><p>因此，insert 的最佳用法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>insert 插入和 [] 写入的异同：</p><ul><li>同：当键 K 不存在时，insert 和 [] 都会创建键值对。</li><li>异：当键 K 已经存在时，insert 不会覆盖，默默离开；而 [] 会覆盖旧的值。</li></ul><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;);  <span class="comment">// 插入失败，默默放弃不出错</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;old&quot;</span>&#125;</span><br><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;new&quot;</span>;        <span class="comment">// 已经存在？我踏马强行覆盖！</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>insert 的返回值是 <code>pair&lt;iterator, bool&gt;</code> 类型，<del>STL 的尿性：在需要一次性返回两个值时喜欢用 pair</del>。</p><p>这又是一个 pair 类型，其具有两个成员：</p><ul><li>first：iterator 类型，是个迭代器</li><li>second：bool 类型，表示插入成功与否，如果发生键冲突则为 false</li></ul><p>其中 first 这个迭代器指向的是：</p><ul><li>如果插入成功（second 为 true），指向刚刚成功插入的元素位置</li><li>如果插入失败（second 为 false），说明已经有相同的键 K 存在，发生了键冲突，指向已经存在的那个元素</li></ul><hr><p>其实 insert 返回的 first 迭代器等价于插入以后再重新用 find 找到刚刚插入的那个键，只是效率更高：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">insert</span>(&#123;k, v&#125;).first;  <span class="comment">// 高效，只需遍历一次</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;k, v&#125;);     <span class="comment">// 插入完就忘事了</span></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(k);  <span class="comment">// 重新遍历第二次，但结果一样</span></span><br></pre></td></tr></table></figure><p>参考 C 编程网<a href="https://142857.red/book/stl_map/#fn:1">1</a>对 insert 返回值的解释：</p><blockquote><p>当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；</p><p>反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。</p></blockquote><hr><p>可以用 insert 返回的 second 判断插入多次是否成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>&#125;).second);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;).second);  <span class="comment">// false</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;key&quot;</span>);     <span class="comment">// 把原来的 &#123;&quot;key&quot;, &quot;old&quot;&#125; 删了</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;).second);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>也可以用 structured-binding 语法拆解他返回的 <code>pair&lt;iterator, bool&gt;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">auto</span> [it, success] = counter.<span class="built_in">insert</span>(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);  <span class="comment">// 直接用</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;  <span class="comment">// 如果已经存在，则修改其值+1</span></span><br><span class="line">    it-&gt;second = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果不存在，则打印以下信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;created a new entry!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这一长串代码和之前“优雅”的计数 [] 等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter[<span class="string">&quot;key&quot;</span>]++;</span><br></pre></td></tr></table></figure><h3 id="insert-or-assign"><a href="#insert-or-assign" class="headerlink" title="insert_or_assign"></a>insert_or_assign</h3><p>在 C++17 中，[] 写入有了个更高效的替代品 insert_or_assign<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_or_assign</span><span class="params">(K <span class="type">const</span> &amp;k, V v)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_or_assign</span><span class="params">(K &amp;&amp;k, V v)</span></span>;</span><br></pre></td></tr></table></figure><p>正如他名字的含义，“插入或者写入”：</p><ul><li>如果 K 不存在则创建（插入）</li><li>如果 K 已经存在则覆盖（写入）</li></ul><p>用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>);  <span class="comment">// 与 insert 不同，他不需要 &#123;...&#125;，他的参数就是两个单独的 K 和 V</span></span><br></pre></td></tr></table></figure><p>返回值依旧是 <code>pair&lt;iterator, bool&gt;</code>。由于这函数在键冲突时会覆盖，按理说是必定成功了，因此这个 bool 的含义从“是否插入成功”变为“是否创建了元素”，如果是创建的新元素返回true，如果覆盖了旧元素返回false。</p><hr><h4 id="insert-or-assign-的优势"><a href="#insert-or-assign-的优势" class="headerlink" title="insert_or_assign 的优势"></a>insert_or_assign 的优势</h4><p>看来 insert_or_assign 和 [] 的效果完全相同！都是在键值冲突时覆盖旧值。</p><p>既然 [] 已经可以做到同样的效果，为什么还要发明个 insert_or_assign 呢？</p><p>insert_or_assign 的优点是<strong>不需要调用默认构造函数</strong>，可以提升性能。</p><p>其应用场景有以下三种情况：</p><ul><li>⏱ 您特别在乎性能</li><li>❌ 有时 V 类型没有默认构造函数，用 [] 编译器会报错</li><li>🥵 强迫症发作</li></ul><p>否则用 [] 写入也是没问题的。</p><p>而且 insert_or_assign 能取代 [] 的岗位仅限于纯写入，之前 <code>counter[key]++</code> 这种“优雅”写法依然是需要用 [] 的。</p><h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>创建新键时，insert_or_assign 更高效。</p><h5 id=""><a href="#" class="headerlink" title="[]"></a>[]</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>覆盖旧键时，使用 [] 造成的开销：</p><ul><li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li></ul><p>创建新键时，使用 [] 造成的开销：</p><ul><li>调用默认构造函数 <code>V()</code></li><li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li></ul><h5 id="insert-or-assign-1"><a href="#insert-or-assign-1" class="headerlink" title="insert_or_assign"></a>insert_or_assign</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>覆盖旧键时，使用 insert_or_assign 造成的开销：</p><ul><li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li></ul><p>创建新键时，使用 insert_or_assign 造成的开销：</p><ul><li>调用移动构造函数 <code>V(V &amp;&amp;)</code></li></ul><h4 id="那我应该用什么"><a href="#那我应该用什么" class="headerlink" title="那我应该用什么"></a>那我应该用什么</h4><p>总结，如果你有性能强迫症，并且是 C++17 标准：</p><ul><li>写入用 insert_or_assign</li><li>读取用 at</li></ul><p>如果没有性能强迫症，或者你的编译器不支持 C++17 标准：</p><ul><li>写入用 []</li><li>读取用 at</li></ul><p>最后，如果你是还原论者，只需要 find 和 insert 函数就是完备的了，别的函数都不用去记。所有 at、[]、insert_or_assign 之类的操作都可以通过 find 和 insert 的组合拳实现，例如刚刚我们自定义的 map_get。</p><h4 id="insert-or-assign-vs-insert：顺序问题"><a href="#insert-or-assign-vs-insert：顺序问题" class="headerlink" title="insert_or_assign vs insert：顺序问题"></a>insert_or_assign vs insert：顺序问题</h4><p>回顾之前的反向查找表，如果有重复，如何区分找第一个还是最后一个？</p><p>构建反向查找表，找到最后一个的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv.<span class="built_in">insert_or_assign</span>(arr[i], i);</span><br><span class="line">    <span class="comment">// 等价于 arrinv[arr[i]] = i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建反向查找表，找到第一个的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv.<span class="built_in">insert</span>(&#123;arr[i], i&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量-insert"><a href="#批量-insert" class="headerlink" title="批量 insert"></a>批量 insert</h2><p>刚刚介绍的那些 insert 一次只能插入一个元素，insert 还有一个特殊的版本，用于批量插入一系列元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIt beg, InputIt end)</span></span>;</span><br></pre></td></tr></table></figure><p>参数<a href="https://142857.red/book/stl_map/#fn:1">1</a>是两个迭代器 beg 和 end，组成一个区间，之间是你要插入的数据。</p><p>该区间可以是任何其他容器的 begin() 和 end() 迭代器——那会把该容器中所有的元素都插入到本 map 中去。</p><p>例如，把 vector 中的键值对批量插入 map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);  <span class="comment">// &#123;&quot;delay&quot;: 211, &quot;timeout&quot;: 985&#125;</span></span><br></pre></td></tr></table></figure><h3 id="批量-insert-同样遵循不覆盖原则"><a href="#批量-insert-同样遵循不覆盖原则" class="headerlink" title="批量 insert 同样遵循不覆盖原则"></a>批量 insert 同样遵循不覆盖原则</h3><p>注：由于 insert 不覆盖的特性，如果 vector 中有重复的键，则会以键第一次出现时的值为准，之后重复出现的键会被忽视。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">666</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">233</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">666</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">233</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">404</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">404</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="批量-insert-实现-map-合并"><a href="#批量-insert-实现-map-合并" class="headerlink" title="批量 insert 实现 map 合并"></a>批量 insert 实现 map 合并</h3><p>批量 insert 运用案例：两个 map 合并</p><p>这个批量 insert 输入的迭代器可以是任何容器，甚至可以是另一个 map 容器。</p><p>运用这一点可以实现两个 map 的并集操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m1 = &#123;  <span class="comment">// 第一个 map</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m2 = &#123;  <span class="comment">// 第二个 map</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m1.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());  <span class="comment">// 把 m2 的内容与 m1 合并，结果写回到 m1</span></span><br><span class="line"><span class="built_in">print</span>(m1);</span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>注：还是由于 insert 不覆盖的特性，当遇到重复的键时（例如上面的 “timeout”），会以 m1 中的值为准。</p><h4 id="就地写入！"><a href="#就地写入！" class="headerlink" title="就地写入！"></a>就地写入！</h4><p>使用 <code>m1.insert(m2.begin(), m2.end())</code> 后，合并的结果会就地写入 m1。</p><p>如果希望合并结果放到一个新的 map 容器中而不是就地修改 m1，请先自行生成一份 m1 的深拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; m1 = &#123;  <span class="comment">// 第一个 map，修饰有 const 禁止修改</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; m2 = &#123;  <span class="comment">// 第二个 map，修饰有 const 禁止修改</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> m12 = m1;  <span class="comment">// 生成一份 m1 的深拷贝 m12，避免 insert 就地修改 m1</span></span><br><span class="line">m12.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="批量-insert-优先保留已经有的"><a href="#批量-insert-优先保留已经有的" class="headerlink" title="批量 insert 优先保留已经有的"></a>批量 insert 优先保留已经有的</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> m12 = m1;</span><br><span class="line">m12.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果，键冲突时优先取 m1 的值</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>刚刚写的 m1 和 m2 合并，遇到重复时会优先采取 m1 里的值，如果希望优先采取 m2 的呢？反一反就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> m12 = m2;</span><br><span class="line">m12.<span class="built_in">insert</span>(m1.<span class="built_in">begin</span>(), m1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果，键冲突时优先取 m2 的值</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br></pre></td></tr></table></figure><p>要是学不会批量 insert，那手写一个 for 循环遍历 m2，然后 m1.insert_or_assign(k2, v2) 也是可以的，总之要懂得变通，动动脑，总是有保底写法的。</p><h4 id="其他操作：交集、并集、差集等"><a href="#其他操作：交集、并集、差集等" class="headerlink" title="其他操作：交集、并集、差集等"></a>其他操作：交集、并集、差集等</h4><p>有同学就问了，这个 insert 实现了 map 的并集操作，那交集操作呢？这其实是 set 的常规操作而不是 map 的：</p><ul><li>set_intersection（取集合交集）</li><li>set_union（取集合并集）</li><li>set_difference（取集合差集）</li><li>set_symmetric_difference（取集合对称差集）</li></ul><p>非常抱歉在之前的 set 课中完全没有提及，因为我认为那是 <code>&lt;algorithm&gt;</code> 头文件里的东西。</p><p>不过别担心，之后我们会专门有一节 algorithm 课详解 STL 中这些全局函数——我称之为算法模板，因为他提供了很多常用的算法，对小彭老师这种算法弱鸡而言，实在非常好用，妈妈再也不用担心我的 ACM 奖杯。</p><p>在小彭老师制作完 algorithm 课之前，同学们可以自行参考 <a href="https://blog.csdn.net/u013095333/article/details/89322501">https://blog.csdn.net/u013095333/article/details/89322501</a> 提前进行学习这四个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">set_union</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(C, C.<span class="built_in">begin</span>()));  <span class="comment">// C = A U B</span></span><br></pre></td></tr></table></figure><blockquote><p>注：set_union 仅仅要求输入的两个区间有序，可以是 set，也可以是排序过的 vector。而且通过重载运算符或者指定 compare 函数，同样可以模拟 map 只对 key 部分排序的效果——参考 thrust::sort_by_key，但很可惜 STL 没有这函数，需要自定义 compare 函数模拟。</p></blockquote><p>同样地，这些操作也是很容易基于 map 的 contains、erase、insert 等接口“动动脑”写出保底写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m12;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[k, v] : m2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m1.<span class="built_in">contains</span>(k)) &#123; <span class="comment">// 此处为 count 也可以</span></span><br><span class="line">        <span class="comment">// 交集操作：如果 m1 和 m2 都有这个键，则插入他俩的交集 m12</span></span><br><span class="line">        m12.<span class="built_in">insert</span>(&#123;k, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-一个初始化列表"><a href="#insert-一个初始化列表" class="headerlink" title="insert 一个初始化列表"></a>insert 一个初始化列表</h3><p>C++11 还引入了一个以初始化列表（initializer_list）为参数的 insert 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist)</span></span>;</span><br></pre></td></tr></table></figure><p>用法和 map 的构造函数一样，还是用花括号列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 初始化时就插入两个元素</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;              <span class="comment">// 批量再插入两个新元素</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,   <span class="comment">// &quot;timeout&quot; 发生键冲突，根据 insert 的特性，不会覆盖</span></span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>注：这里还是和逐个 insert 一样，重复的键 “timeout” 没有被覆盖，依旧了保留原值。</p><hr><h4 id="小彭老师锐评批量-insert-有什么用"><a href="#小彭老师锐评批量-insert-有什么用" class="headerlink" title="小彭老师锐评批量 insert 有什么用"></a>小彭老师锐评批量 insert 有什么用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总之这玩意和分别调用两次 insert 等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果需要覆盖原值的批量写入，还是得乖乖写个 for 循环调用 [] 或 insert_or_assign。</p><p>问：既然和批量插入没什么区别，复杂度也一样是 O(logN)O(log⁡N)，那批量 insert 究竟还有什么存在的必要呢？map 又不像 vector 一个个分别插入会变成 O(N2)O(N2) 复杂度，确实需要提供个批量插入的方法。</p><p>答：</p><ol><li>是为了统一，既然 vector 都有批量 insert，那 set 和 map 也得有才符合完美主义美学，而且用他来合并两个 map 也很方便。</li><li>复杂度并不一样，当输入已经有序时，批量 insert 会比逐个 insert 更快，只需 O(N)O(N) 而不是 O(NlogN)O(Nlog⁡N)；如果输入无序，那么依然是 O(NlogN)O(Nlog⁡N)，稍后会讲原理。</li></ol><h3 id="operator-也支持初始化列表"><a href="#operator-也支持初始化列表" class="headerlink" title="operator&#x3D; 也支持初始化列表"></a>operator&#x3D; 也支持初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist);</span><br></pre></td></tr></table></figure><p>map 也支持赋值函数，不仅有 map 自己给自己赋值的移动赋值和拷贝赋值函数，还有从列表初始化的函数。</p><p>用法是等号右边一个花括号列表，作用是清空原有内容，直接设为一个全新的 map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 初始化时就插入两个元素</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m = &#123;                   <span class="comment">// 原有内容全部清空！重新插入两个新元素</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相当于 clear 了再重新 insert，原有的 “answer” 键也被删掉了。</p></blockquote><h4 id="赋值函数和构造函数概念辨析"><a href="#赋值函数和构造函数概念辨析" class="headerlink" title="赋值函数和构造函数概念辨析"></a>赋值函数和构造函数概念辨析</h4><p>要注意赋值函数 <code>operator=(initializer_list)</code> 和构造函数 <code>map(initializer_list)</code> 是不同的。</p><p>构造函数是初始化时调用的（无论有没有 &#x3D; 号），赋值函数是后期重新赋值时调用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m&#123;    <span class="comment">// 构造函数 map(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 虽然有等号，但这里是初始化语境，调用的依然是构造函数 map(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m = &#123;                   <span class="comment">// m 已经初始化过，这里是重新赋值，才是赋值函数 operator=(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果一个类要支持初始化，又要支持后期重新赋值，那么构造函数和赋值函数都要实现。</p><p>但也可以选择只定义 <code>operator=(map &amp;&amp;)</code> 移动赋值函数而不定义 <code>operator=(initializer_list)</code>。这样当试图 <code>operator=(initializer_list)</code> 时，会匹配到 <code>map(initializer_list)</code> 这个隐式构造函数来转换，然后调用到 <code>operator=(map &amp;&amp;)</code>。标准库选择将两个都定义可能是处于避免一次 map 移动的效率考量。</p><h4 id="assign-函数"><a href="#assign-函数" class="headerlink" title="assign 函数"></a>assign 函数</h4><p>map 还有一个 assign 函数，他和 <code>operator=</code> 等价：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist)</span></span>;</span><br></pre></td></tr></table></figure><p>assign 的额外好处是他拥有两个迭代器参数组成区间的版本，和批量 insert 类似，只不过 assign 会清除已有的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure><p>和 <code>operator=(map(first, last))</code> 等价。</p><h2 id="带插入位置提示的-insert"><a href="#带插入位置提示的-insert" class="headerlink" title="带插入位置提示的 insert"></a>带插入位置提示的 insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br></pre></td></tr></table></figure><p>这又是 insert 函数的一个重载版，增加了 pos 参数提示插入位置，官方文档称<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><blockquote><p>Inserts value in the position as close as possible to the position just prior to pos.</p><p>把元素（键值对）插入到位于 pos 之前，又离 pos 尽可能近的地方。</p></blockquote><p>然而 map 作为红黑树应该始终保持有序，插入位置可以由 K 唯一确定，为啥还要提示？</p><p>是为了在已知要插入的大致位置时，能够提升性能。</p><blockquote><p>（带提示的 insert 版本）中传入的迭代器，仅是给 map 容器提供一个建议，并不一定会被容器采纳。该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。<a href="https://142857.red/book/stl_map/#fn:2">2</a></p><p>也就是说这玩意还不一定管用，只是提示性质的（和 mmap 函数的 start 参数很像，你可以指定，但只是个提示，指定了不一定有什么软用，具体什么地址还是操作系统说了算，他从返回值里给你的地址才是正确答案）。例如已知指向 “key” 的迭代器，想要插入 “kea”，那么指定指向 “key” 的迭代器就会让 insert 能更容易定位到 “kea” 要插入的位置。</p></blockquote><h3 id="复杂度分类讨论"><a href="#复杂度分类讨论" class="headerlink" title="复杂度分类讨论"></a>复杂度分类讨论</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>当插入位置 pos 提示的准确时，insert 的复杂度可以低至 O(1)+O(1)+。</li><li>当插入位置 pos 提示不准确时，和普通的 insert 一样，还是 O(logN)O(log⁡N)。</li><li>返回指向成功插入元素位置的迭代器。</li></ul><p>想想看，这三个看似不相干的特性，能有什么用呢？</p><p>可以让已经有序数据的批量插入更高效！</p><p>众所周知，普通的批量 insert 复杂度为 O(NlogN)O(Nlog⁡N)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: arr) &#123;</span><br><span class="line">    tab.<span class="built_in">insert</span>(&#123;k, v&#125;);               <span class="comment">// O(log N)</span></span><br><span class="line">&#125;  <span class="comment">// 总共 O(N log N)</span></span><br></pre></td></tr></table></figure><p>假如输入本就有序，带提示的批量 insert 复杂度可以降低到 O(N)O(N)。</p><p>如果输入无序，带提示的批量 insert 复杂度依然是 O(NlogN)O(Nlog⁡N) 不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="keyword">auto</span> hint = tab.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: arr) &#123;</span><br><span class="line">    hint = tab.<span class="built_in">insert</span>(hint, &#123;k, v&#125;);  <span class="comment">// 平均 O(1)</span></span><br><span class="line">&#125;  <span class="comment">// 总共 O(N)</span></span><br></pre></td></tr></table></figure><p>想一想，为什么？</p><h3 id="小学生的趣味早操"><a href="#小学生的趣味早操" class="headerlink" title="小学生的趣味早操"></a>小学生的趣味早操</h3><p>你是一名小学老师，马上就要出早操了，为应付领导面子，你需要给你的学生排队，根据个子从矮到高排列。</p><p>不过这所小学的学生都比较懒散，有的来得早有的来得晚，而且来的早晚顺序和他们的高矮无关。</p><p>你本来打算等所有人到齐之后再一次性完成排序（std::sort）的，但是同学来的时间实在是太分散了：明明 8 点就要出早操，最晚的同学却 7 点 59 分才到达。意味着你需要一直干等着这个懒散的同学，最后在 1 分钟时间内临时抱佛脚，完成快速排序。这是不可能的，只能在同学陆续抵达的同时进行排序，这就是堆排序，一边插入一边排序，每次插入后都保证有序，与插入排序不同他使用堆内存中的节点而不是数组避免昂贵的数组平移操作。</p><p>每当来一个学生，你就得把他插入到现有的一个已经排好的队伍中去。</p><p>如何确定插入的位置？二分法。先从现有队伍的最中间（1&#x2F;2 处）开始，比较中间这个学生和新来的学生哪个高哪个矮，如果发现新来的学生高，则继续从队列的 3&#x2F;4 处那个同学开始比高矮，如果新来的学生矮就从队列的 1&#x2F;4 处继续比较。以此类推，最终唯一确定新同学要插入的位置。因为每次确定的范围就小一半，所以最多只需要 logNlog⁡N 次比较就可以成功插入，其中 NN 是当前已有学生的数量。</p><p>总共要来 NN 名学生，则你总共需要比较 NlogNNlog⁡N 次。能不能优化？让我们小彭老师省力点？</p><h3 id="小学生来的顺序已经有序的情况"><a href="#小学生来的顺序已经有序的情况" class="headerlink" title="小学生来的顺序已经有序的情况"></a>小学生来的顺序已经有序的情况</h3><p>后来你发现一个规律，似乎学生来的早晚顺序和高矮有关：矮小的同学喜欢起的早，高大的同学喜欢起的晚。</p><p>知道这个规律后，你改变你的策略：二分法时，不是先从最中间（1&#x2F;2 处）开始查找，而是从最末尾开始查找。因为矮小同学会早到，导致每次新来的同学往往总是队列中最高的那一个。所以可以从队伍的末尾（最高的地方）开始找，例如有 64 名同学则优先和 65&#x2F;64 处比较，找不到再往上一级和 31&#x2F;32 处比较。</p><p>这个策略也有缺点：对于早晚顺序和高矮无关、甚至负相关的情况，每次插入的消耗就会变成 2logN2log⁡N 了。</p><p>最终我们决定采用的策略是：不是从中间，也不是从开头，也不是从末尾，而是<strong>记住上一次成功插入的位置</strong>，下一次从上一次成功插入的位置开始找。这个记忆的插入位置，就是刚刚代码中那个位置提示迭代器 hint。</p><p>这正是我们代码的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = tab.<span class="built_in">insert</span>(hint, &#123;k, v&#125;);</span><br></pre></td></tr></table></figure><p>实际上，insert 的批量插入版 <code>insert(arr.begin(), arr.end())</code> 内部就会使用这种带提示的方式，逐个插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br></pre></td></tr></table></figure><h2 id="分奴-emplace"><a href="#分奴-emplace" class="headerlink" title="分奴 emplace"></a>分奴 emplace</h2><p>insert 的究极分奴版（不推荐）：emplace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure><p>虽然变长参数列表 <code>Args &amp;&amp;...args</code> 看起来很酷，然而由于 map 的特殊性，其元素类型是 <code>pair&lt;const K, V&gt;</code>，而 pair 的构造函数只有两个参数，导致实际上这个看似炫酷的变长参数列表往往只能接受两个参数，因此这个函数的调用方法实际上只能是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(K k, V v)</span></span>;</span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">emplace</span>(key, val);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, val&#125;);</span><br></pre></td></tr></table></figure><p>返回值还是 <code>pair&lt;iterator, bool&gt;</code>，其意义和 insert 一样，不再赘述。</p><hr><h3 id="emplace-hint"><a href="#emplace-hint" class="headerlink" title="emplace_hint"></a>emplace_hint</h3><p>insert 的宇宙无敌分奴版（不推荐）：emplace_hint<a href="https://142857.red/book/stl_map/#fn:1">1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace_hint</span><span class="params">(const_iterator pos, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">emplace_hint</span>(pos, key, val);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(pos, &#123;key, val&#125;);</span><br></pre></td></tr></table></figure><p>之所以要分两个函数名 emplace 和 emplace_hint 而不是利用重载区分，是因为直接传入 pos 会被 emplace 当做 pair 的构造参数，而不是插入位置提示。</p><ul><li>emplace 对应于普通的 <code>insert(pair&lt;const K, V&gt;)</code> 这一重载。</li><li>emplace_hint 对应于带插入位置提示的 <code>insert(const_iterator, pair&lt;const K, V&gt;)</code> 这一重载。</li><li>emplace_hint 的返回类型也和带插入位置提示的 insert 一样，是单独一个 iterator。</li></ul><h3 id="emplace-的原理和优点"><a href="#emplace-的原理和优点" class="headerlink" title="emplace 的原理和优点"></a>emplace 的原理和优点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure><p>emplace 对于 set，元素类型是比较大的类型时，例如 <code>set&lt;array&lt;int, 100&gt;&gt;</code>，可能确实能起到减少移动构造函数开销的作用。</p><p>但是这个 map 他的元素类型不是直接的 V 而是一个 pair，他分的是 pair 的构造函数，没有用，V 部分还是会造成一次额外的移动开销，所以这玩意除了妨碍类型安全和可读性以外，没有任何收益。</p><ul><li>set 可以用 emplace&#x2F;emplace_hint。</li><li>vector 可以用 emplace_back。</li><li>不建议在 map 上使用 emplace&#x2F;emplace_hint，请改用 try_emplace。</li></ul><h2 id="try-emplace-更好"><a href="#try-emplace-更好" class="headerlink" title="try_emplace 更好"></a>try_emplace 更好</h2><p>emplace 只支持 pair 的就地构造，这有什么用？我们要的是 pair 中值类型的就地构造！这就是 try_emplace 的作用了，他对 key 部分依然是传统的移动，只对 value 部分采用就地构造。</p><blockquote><p>这是观察到大多是值类型很大，急需就地构造，而键类型没用多少就地构造的需求。例如 <code>map&lt;string, array&lt;int, 1000&gt;&gt;</code></p><p>如果想不用 try_emplace，完全基于 emplace 实现针对值 value 的就地构造需要用到 std::piecewise_construct 和 std::forward_as_tuple，非常麻烦。</p></blockquote><p>insert 的托马斯黄金大回旋分奴版：try_emplace（C++17 引入）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">try_emplace</span><span class="params">(K <span class="type">const</span> &amp;k, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">try_emplace</span>(key, arg1, arg2, ...);</span><br></pre></td></tr></table></figure><p>他等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);</span><br></pre></td></tr></table></figure><p>后面的变长参数也可以完全没有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">try_emplace</span>(key);</span><br></pre></td></tr></table></figure><p>他等价于调用 V 的默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>()&#125;);</span><br></pre></td></tr></table></figure><p>由于 emplace 实在是憨憨，他变长参数列表就地构造的是 pair，然而 pair 的构造函数正常不就是只有两个参数吗，变长没有用。实际有用的往往是我们希望用变长参数列表就地构造值类型 V，对 K 部分并不关系。因此 C++17 引入了 try_emplace，其键部分保持 <code>K const &amp;</code>，值部分采用变长参数列表。</p><p>我的评价是：这个比 emplace 实用多了，如果要与 vector 的 emplace_back 对标，那么 map 与之对应的一定是 try_emplace。同学们如果要分奴的话还是建议用 try_emplace。</p><h3 id="try-emplace-可以避免移动！"><a href="#try-emplace-可以避免移动！" class="headerlink" title="try_emplace 可以避免移动！"></a>try_emplace 可以避免移动！</h3><p>insert 类函数总是不可避免的需要移动构造：先在函数中构造出临时对象，然后构造到真正的 pair 上。</p><p>而 try_emplace 可以允许你就地构造值对象，避免移动造成开销。</p><p>try_emplace 第一个参数是键，第二个开始是传给构造函数的参数，如只有第一个参数则是调用无参构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i) &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(int)\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">float</span> x) &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(const char *, float)\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, MyClass&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>);                 <span class="comment">// MyClass()</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="number">42</span>);             <span class="comment">// MyClass(int)</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;hell&quot;</span>, <span class="number">3.14f</span>);  <span class="comment">// MyClass(const char *, float)</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>()&#125;);                <span class="comment">// MyClass()</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">42</span>)&#125;);              <span class="comment">// MyClass(int)</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="string">&quot;hell&quot;</span>, <span class="number">3.14f</span>)&#125;);   <span class="comment">// MyClass(const char *, float)</span></span><br></pre></td></tr></table></figure><p>对于移动开销较大的类型（例如 <code>array&lt;int, 1000&gt;</code>），try_emplace 可以避免移动；对于不支持移动构造函数的值类型，就必须使用 try_emplace 了。</p><h3 id="谈谈-try-emplace-的优缺点"><a href="#谈谈-try-emplace-的优缺点" class="headerlink" title="谈谈 try_emplace 的优缺点"></a>谈谈 try_emplace 的优缺点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式效果等价，只有性能不同</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(key, arg1, arg2, ...);           <span class="comment">// 开销：1次构造函数</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);           <span class="comment">// 开销：1次构造函数 + 2次移动函数</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>(arg1, arg2, ...)));  <span class="comment">// 开销：1次构造函数 + 3次移动函数</span></span><br></pre></td></tr></table></figure><p>但是由于 try_emplace 是用圆括号帮你调用的构造函数，而不是花括号初始化。</p><p>导致你要么无法省略类型，要么你得手动定义类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;  <span class="comment">// 没有构造函数，只能用花括号语法进行初始化</span></span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;&#125;);            <span class="comment">// OK: insert 参数类型已知，Student 可以省略不写，但是会造成 2 次移动</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);           <span class="comment">// ERROR: 不存在构造函数 Student(string, int)；C++20 开始则 OK: C++20 起聚合初始化同时支持花括号和圆括号</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);         <span class="comment">// ERROR: 参数类型是模板类型，未知，无法省略花括号前的类型</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);  <span class="comment">// OK: 明确指定类型的花括号初始化；但这样又会造成 1 次移动，失去了 try_emplace 避免移动的意义</span></span><br></pre></td></tr></table></figure><blockquote><p>此外还要注意不论 insert、emplace、emplace_hint、try_emplace，都是一个尿性：键冲突时不会覆盖已有元素。</p><p>如果需要覆盖性的插入，还得乖乖用 [] 或者 insert_or_assign 函数。</p></blockquote><p>由于 try_emplace 里写死了圆括号，我们只好手动定义的构造函数才能劳驾 try_emplace 就地构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Student</span>(string sex, <span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">sex</span>(std::<span class="built_in">move</span>(sex))</span><br><span class="line">        , <span class="built_in">age</span>(age)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于 try_emplace 会就地构造对象，其值类型可以没有移动构造函数，而 insert 会出错</span></span><br><span class="line">    <span class="built_in">Student</span>(Student &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student &amp;<span class="keyword">operator</span>=(Student &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Student</span>(Student <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student &amp;<span class="keyword">operator</span>=(Student <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);           <span class="comment">// OK: 会调用构造函数 Student(string, int) 就地构造对象</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;彭于斌&quot;</span>, <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>)&#125;);     <span class="comment">// ERROR: insert 需要移动 Student 而 Student 的移动被 delete 了！</span></span><br></pre></td></tr></table></figure><h3 id="什么是聚合初始化"><a href="#什么是聚合初始化" class="headerlink" title="什么是聚合初始化"></a>什么是聚合初始化</h3><p>无构造函数时，C++11 支持花括号初始化（官方名: 聚合初始化<a href="https://142857.red/book/stl_map/#fn:1">1</a>），C++20 开始聚合初始化也能用圆括号（所以 emplace &#x2F; try_emplace 这类函数变得更好用了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> s1 = Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;;  <span class="comment">// C++11 起 OK: 无构造函数时的花括号初始化语法</span></span><br><span class="line"><span class="keyword">auto</span> s2 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);  <span class="comment">// C++20 起 OK: 编译器会自动生成圆括号构造函数 Student(string, int)</span></span><br></pre></td></tr></table></figure><p>和花括号初始化时一样，可以省略一部分参数，这部分参数会用他们的默认值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s1 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);     <span class="comment">// OK: sex 为 &quot;自定义&quot;，age 为 22</span></span><br><span class="line"><span class="keyword">auto</span> s2 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>);         <span class="comment">// OK: 省略 age 自动为 0</span></span><br><span class="line"><span class="keyword">auto</span> s3 = <span class="built_in">Student</span>();                 <span class="comment">// OK: 省略 sex 自动为 &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>不过他和花括号不一样的是，作为已知参数类型的函数参数时，类型名不能省略了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Student <span class="type">const</span> &amp;stu)</span></span>;    <span class="comment">// 已知函数签名</span></span><br><span class="line"><span class="built_in">func</span>(Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);      <span class="comment">// OK: C++11 语法</span></span><br><span class="line"><span class="built_in">func</span>(&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);             <span class="comment">// OK: C++11 语法，已知函数具有唯一重载的情况下类名可以省略</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>));      <span class="comment">// OK: C++20 语法</span></span><br><span class="line"><span class="built_in">func</span>((<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>));             <span class="comment">// ERROR: 无法从 int 转换为 Student</span></span><br></pre></td></tr></table></figure><h3 id="C-20-修复了聚合初始化不支持圆括号的缺点"><a href="#C-20-修复了聚合初始化不支持圆括号的缺点" class="headerlink" title="C++20 修复了聚合初始化不支持圆括号的缺点"></a>C++20 修复了聚合初始化不支持圆括号的缺点</h3><p>所以现在 try_emplace 也可以就地构造无构造函数的类型了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);       <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;自定义&quot;, 22&#125;</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>);           <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;自定义&quot;, 0&#125;</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>);                    <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;&quot;, 0&#125;</span></span><br></pre></td></tr></table></figure><p>方便！</p><blockquote><p>关于更多 C++20 的聚合初始化小知识，可以看这期 CppCon 视频：<a href="https://www.youtube.com/watch?v=flLNi0aejew">https://www.youtube.com/watch?v=flLNi0aejew</a></p><p>为方便你在比站搜索搬运，他的标题是：Lightning Talk: Direct Aggregate Initialisation - Timur Doumler - CppCon 2021</p></blockquote><h3 id="调用开销分析"><a href="#调用开销分析" class="headerlink" title="调用开销分析"></a>调用开销分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass &amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(MyClass &amp;&amp;)\n&quot;</span>); &#125;</span><br><span class="line">    MyClass &amp;<span class="keyword">operator</span>=(MyClass &amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass &amp;operator=(MyClass &amp;&amp;)\n&quot;</span>); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, MyClass&gt; tab;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;insert的开销:\n&quot;</span>);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="built_in">MyClass</span>()&#125;);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;try_emplace的开销:\n&quot;</span>);</span><br><span class="line">tab.<span class="built_in">try_emplace</span>(<span class="number">2</span>);  <span class="comment">// try_emplace 只有一个 key 参数时，相当于调用无参构造函数 MyClass()</span></span><br></pre></td></tr></table></figure><p>insert 调用了两次移动函数，一次发生在 pair 的构造函数，一次发生在 insert 把参数 pair 移进红黑树节点里。</p><p>而 try_emplace 内部使用了现代 C++ 的就地构造（placement new），直接在红黑树节点的内存中构造 MyClass，无需反复移动，对于尺寸较大的值类型会更高效。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert的开销:</span><br><span class="line"><span class="keyword">MyClass</span>()</span><br><span class="line"><span class="keyword">MyClass</span>(<span class="keyword">MyClass</span> &amp;&amp;)</span><br><span class="line"><span class="keyword">MyClass</span>(<span class="keyword">MyClass</span> &amp;&amp;)</span><br><span class="line">try_emplace的开销:</span><br><span class="line"><span class="keyword">MyClass</span>()</span><br></pre></td></tr></table></figure><h3 id="try-emplace-成功提升性能的案例"><a href="#try-emplace-成功提升性能的案例" class="headerlink" title="try_emplace 成功提升性能的案例"></a>try_emplace 成功提升性能的案例</h3><p>提升了 1.42 倍性能，不能说是惊天地泣鬼神吧，至少也可以说是聊胜于无了。这里的值类型 string 只有 32 字节还不够明显，可能更大的自定义类型会有明显的优势。这种优化的理论上限是 3 倍，最多能从 try_emplace 获得 3 倍性能提升。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test_insert</span><span class="params">(map&lt;K, V&gt; &amp;tab)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1次string(const char *) 2次string(string &amp;&amp;)</span></span><br><span class="line">        tab.<span class="built_in">insert</span>(&#123;i, <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test_try_emplace</span><span class="params">(map&lt;K, V&gt; &amp;tab)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1次string(const char *)</span></span><br><span class="line">        tab.<span class="built_in">try_emplace</span>(i, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, string&gt; tab;</span><br><span class="line">        <span class="built_in">test_insert</span>(tab);</span><br><span class="line">        <span class="built_in">doNotOptimize</span>(tab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, string&gt; tab;</span><br><span class="line">        <span class="built_in">test_try_emplace</span>(tab);</span><br><span class="line">        <span class="built_in">doNotOptimize</span>(tab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printScopeProfiler</span>();</span><br><span class="line">&#125;</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">       <span class="number">39</span>|       <span class="number">34</span>|      <span class="number">218</span>|    <span class="number">39927</span>| <span class="number">1000</span>| test_insert</span><br><span class="line">       <span class="number">28</span>|       <span class="number">27</span>|       <span class="number">91</span>|    <span class="number">28181</span>| <span class="number">1000</span>| test_try_emplace</span><br></pre></td></tr></table></figure><hr><p>如果改成更大的自定义类型，可以提升 2.3 倍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4096</span>];</span><br><span class="line">&#125;;</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">     <span class="number">1312</span>|     <span class="number">1193</span>|    <span class="number">18298</span>|  <span class="number">1312871</span>| <span class="number">1000</span>| test_insert</span><br><span class="line">      <span class="number">573</span>|      <span class="number">537</span>|     <span class="number">1064</span>|   <span class="number">573965</span>| <span class="number">1000</span>| test_try_emplace</span><br></pre></td></tr></table></figure><hr><h3 id="带插入位置提示的-try-emplace"><a href="#带插入位置提示的-try-emplace" class="headerlink" title="带插入位置提示的 try_emplace"></a>带插入位置提示的 try_emplace</h3><p>insert 的炫彩中二摇摆混沌大魔王分奴版：带插入位置提示的 try_emplace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">try_emplace</span><span class="params">(const_iterator pos, K <span class="type">const</span> &amp;k, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = m.<span class="built_in">try_emplace</span>(hint, key, arg1, arg2, ...);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = m.<span class="built_in">insert</span>(hint, &#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这次不需要再分一个什么 try_emplace_hint 出来了，是因为 try_emplace 的第一个参数是 K 类型而不是泛型，不可能和 const_iterator 类型混淆，因此 C++ 委员会最终决定直接共用同一个名字，让编译器自动重载了。</p></blockquote><h3 id="emplace-家族总结"><a href="#emplace-家族总结" class="headerlink" title="emplace 家族总结"></a>emplace 家族总结</h3><p>总结，如何用 emplace 家族优化？分直接插入和带提示插入两种用法，和你是否需要高性能两种需求，这里标了“推荐”的是建议采用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入版</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;);              <span class="comment">// 可读性推荐</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);                    <span class="comment">// 高性能推荐</span></span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));               <span class="comment">// 没意义</span></span><br><span class="line">m.<span class="built_in">emplace</span>(std::piecewise_construct, std::forward_as_tuple(<span class="string">&quot;key&quot;</span>), std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// C++17 以前的高性能写法</span></span><br><span class="line"><span class="comment">// 带插入位置提示版</span></span><br><span class="line">hint = m.<span class="built_in">insert</span>(hint, &#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;);       <span class="comment">// 可读性推荐</span></span><br><span class="line">hint = m.<span class="built_in">try_emplace</span>(hint, <span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);             <span class="comment">// 高性能推荐</span></span><br><span class="line">hint = m.<span class="built_in">emplace_hint</span>(hint, <span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">// 没意义</span></span><br><span class="line">hint = m.<span class="built_in">emplace_hint</span>(hint, std::piecewise_construct, std::forward_as_tuple(<span class="string">&quot;key&quot;</span>), std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// C++17 以前的高性能写法</span></span><br></pre></td></tr></table></figure><h2 id="map-与-RAII"><a href="#map-与-RAII" class="headerlink" title="map 与 RAII"></a>map 与 RAII</h2><p>梦幻联动：map 容器与 RAII 的双向奔赴</p><p>如果 map 中元素的值类型是 RAII 类型，其析构函数会在元素被删除时自动调用。</p><p>map 被移动时，不会调用元素的移动函数，因为 map 里只存着指向红黑树根节点的指针，只需指针移动即可。</p><p>map 被拷贝时，会调用元素的拷贝函数，如果元素不支持拷贝，则 map 的拷贝也会被禁用（delete）掉。</p><p>map 被析构时，其所有元素都会被析构。</p><h3 id="案例-1：资源类可以移动"><a href="#案例-1：资源类可以移动" class="headerlink" title="案例 1：资源类可以移动"></a>案例 1：资源类可以移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源移动\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII &amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源移动赋值\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure><h3 id="案例-2：资源类禁止移动"><a href="#案例-2：资源类禁止移动" class="headerlink" title="案例 2：资源类禁止移动"></a>案例 2：资源类禁止移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">RAII</span>(RAII <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新手定义 RAII 类时，记得把移动和拷贝 4 个函数全部删除。没错，<strong>移动也要删除</strong>，很多新手会觉得资源类应该可以移动的呀？要是想保留移动，就得预留一个 i &#x3D;&#x3D; 0 的空状态，那种处理很复杂的。总之一旦定义了析构函数，全部 4 个函数都得删除，除非你有相关经验。参见 <a href="https://142857.red/book/cpp_lifetime/">C++ 生命周期与析构函数专题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure><p>这时就体现出 try_emplace 的好处了：值类型不需要有移动构造函数也可以插入。</p><h3 id="记得删除移动构造函数"><a href="#记得删除移动构造函数" class="headerlink" title="记得删除移动构造函数"></a>记得删除移动构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>冷知识：只需要删除移动构造函数，编译器就会自动帮你删除剩下 3 个，这是因为看到你用了 <code>&amp;&amp;</code> 就知道你是懂 C++11 的，所以不用照顾 C++98 兼容性保留烦人的拷贝构造函数，自动帮你删了，这是个标准，所有 C++ 编译器都是这样的（要我说，建议改成定义了析构函数就自动删全 4 个函数，可惜标准委员会要照顾兼容性…）</p><p>以后 RAII 类只需要一行 <code>C(C &amp;&amp;) = delete</code> 就够了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure><h3 id="统一交给智能指针管理"><a href="#统一交给智能指针管理" class="headerlink" title="统一交给智能指针管理"></a>统一交给智能指针管理</h3><p>如果你想用更可读的 insert，RAII 资源类又不支持移动，可以用 <code>unique_ptr&lt;RAII&gt;</code> 包装一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, std::unique_ptr&lt;RAII&gt;&gt; m;</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源1号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">1</span>));</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源2号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">2</span>));</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源3号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="智能指针帮你避免移动"><a href="#智能指针帮你避免移动" class="headerlink" title="智能指针帮你避免移动"></a>智能指针帮你避免移动</h4><p>对于很大的 V 类型，也可以改用 <code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 避免反复移动元素本体。（用在需要反复扩容的 vector 中也有奇效）</p><p>因为包括 map 在内的所有容器都完美支持 RAII 类型，所以也可以用智能指针作为这些容器的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 假设这个很大</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyData</span><span class="params">(<span class="type">int</span> value_)</span> : value(value_) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, unique_ptr&lt;MyData&gt;&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;answer&quot;</span>, <span class="built_in">make_unique</span>&lt;MyData&gt;(<span class="number">42</span>)&#125;);  <span class="comment">// 只有 8 字节的 unique_ptr 被移动 2 次</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;fuck&quot;</span>, <span class="built_in">make_unique</span>&lt;MyData&gt;(<span class="number">985</span>)&#125;);</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">at</span>(<span class="string">&quot;answer&quot;</span>)-&gt;value);  <span class="comment">// 42</span></span><br><span class="line"><span class="comment">// ↑等价于：print((*m.at(&quot;answer&quot;)).value);</span></span><br></pre></td></tr></table></figure><ul><li><code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 中，智能指针指向的对象会在元素被删除时自动释放。</li><li><code>map&lt;T, V *&gt;</code> 中，C 语言原始指针不具备 RAII 功能，除非该指针被其他智能指针打理着，或者用户删除元素之前手动 delete，否则当元素删除时内存会泄露！</li></ul><p>我推荐完全采用智能指针来自动管理内存，智能指针和同样符合 RAII 思想的各大容器也是相性很好的。</p><p>如果需要浅拷贝的话，则可以改用 <code>map&lt;T, shared_ptr&lt;V&gt;&gt;</code>，小彭老师在他的 Zeno 项目中就是这样用的。</p><h2 id="增删改查总结"><a href="#增删改查总结" class="headerlink" title="增删改查总结"></a>增删改查总结</h2><h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><table><thead><tr><th>写法</th><th>效果</th><th>版本</th><th>推荐</th></tr></thead><tbody><tr><td><code>m.insert(make_pair(key, val))</code></td><td>插入但不覆盖</td><td>C++98</td><td>💩</td></tr><tr><td><code>m.insert(&#123;key, val&#125;)</code></td><td>插入但不覆盖</td><td>C++11</td><td>❤</td></tr><tr><td><code>m.emplace(key, val)</code></td><td>插入但不覆盖</td><td>C++11</td><td>💩</td></tr><tr><td><code>m.try_emplace(key, valargs...)</code></td><td>插入但不覆盖</td><td>C++17</td><td>💣</td></tr><tr><td><code>m.insert_or_assign(key, val)</code></td><td>插入或覆盖</td><td>C++17</td><td>❤</td></tr><tr><td><code>m[key] = val</code></td><td>插入或覆盖</td><td>C++98</td><td>💣</td></tr><tr><td><code>m.erase(key)</code></td><td>删除指定元素</td><td>C++98</td><td>❤</td></tr></tbody></table><h3 id="改查"><a href="#改查" class="headerlink" title="改查"></a>改查</h3><table><thead><tr><th>写法</th><th>效果</th><th>版本</th><th>推荐</th></tr></thead><tbody><tr><td><code>m.at(key)</code></td><td>找不到则出错，找到则返回引用</td><td>C++98</td><td>❤</td></tr><tr><td><code>m[key]</code></td><td>找不到则自动创建<code>0</code>值，返回引用</td><td>C++98</td><td>💣</td></tr><tr><td><code>myutils::map_get(m, key, defl)</code></td><td>找不到则返回默认值</td><td>C++98</td><td>❤</td></tr><tr><td><code>m.find(key) == m.end()</code></td><td>检查键 <code>key</code> 是否存在</td><td>C++98</td><td>💣</td></tr><tr><td><code>m.count(key)</code></td><td>检查键 <code>key</code> 是否存在</td><td>C++98</td><td>❤</td></tr><tr><td><code>m.contains(key)</code></td><td>检查键 <code>key</code> 是否存在</td><td>C++20</td><td>💩</td></tr></tbody></table><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><table><thead><tr><th>写法</th><th>效果</th><th>版本</th><th>推荐</th></tr></thead><tbody><tr><td><code>map&lt;K, V&gt; m = &#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td><td>初始化为一系列键值对</td><td>C++11</td><td>❤</td></tr><tr><td><code>auto m = map&lt;K, V&gt;&#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td><td>初始化为一系列键值对</td><td>C++11</td><td>💩</td></tr><tr><td><code>func(&#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;)</code></td><td>给函数参数传入一个 map</td><td>C++11</td><td>❤</td></tr><tr><td><code>m = &#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td><td>重置为一系列键值对</td><td>C++11</td><td>❤</td></tr><tr><td><code>m.clear()</code></td><td>清空所有表项</td><td>C++98</td><td>❤</td></tr><tr><td><code>m = &#123;&#125;</code></td><td>清空所有表项</td><td>C++11</td><td>💣</td></tr></tbody></table><h2 id="节点句柄系列接口"><a href="#节点句柄系列接口" class="headerlink" title="节点句柄系列接口"></a>节点句柄系列接口</h2><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><p>C++17 新增的 extract 函数<a href="https://142857.red/book/stl_map/#fn:1">1</a> 可以“剥离”出单个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node_type <span class="title">extract</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br><span class="line"><span class="function">node_type <span class="title">extract</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> &amp;k = node.<span class="built_in">key</span>();    <span class="comment">// 键（引用）</span></span><br><span class="line"><span class="keyword">auto</span> &amp;v = node.<span class="built_in">mapped</span>(); <span class="comment">// 值（引用）</span></span><br></pre></td></tr></table></figure><p>其功能与 erase 类似，都会将元素从 map 中删除，但 extract 只是把节点从 map 中移走，并不会直接销毁节点。</p><p>extract 会返回这个刚被“剥离”出来节点的句柄，类型为 node_type，节点的生杀大权就这样返回给了用户来处置。</p><p>node_type 是指向游离红黑树节点的特殊智能指针，称为节点句柄<a href="https://142857.red/book/stl_map/#fn:2">2</a>。只可移动不可拷贝，类似一个指向节点的 unique_ptr。</p><p>当调用 extract(key) 时会把 key 对应的键值对所在的红黑树节点“脱离”出来——不是直接释放节点内存并销毁键值对象，而是把删除的节点的所有权移交给了调用者，以返回一个特殊智能指针 node_type 的形式。</p><p>调用 extract 后，节点句柄指向的这个红黑树节点已经从 map 中移除（其 left、right、parent 等指针为 NULL），处于游离状态。</p><blockquote><p>节点中不仅存储着我们感兴趣的键和值，还有 left、right、parent、color 等用于维护数据结构的成员变量，对用户不可见。</p></blockquote><p>只是因为节点句柄类似于 unique_ptr，维持着节点的生命周期，保护着键 key() 和值 mapped() 没有被销毁，内存没有被释放。</p><p>如果调用者接下来不做操作，那么当离开调用者所在的函数体时，这个特殊的 unique_ptr 会自动释放其指向节点。</p><ul><li>对于第一个按键取出节点句柄的 extract 重载：如果键值不存在，那么 extract 会返回一个特殊的空节点句柄，类似于空指针。可以通过 <code>(bool)node</code> 来判断一个节点句柄是否为空。</li><li>对于第二个按迭代器取出句柄的 extract：总是成功，因为既然你已经获得了迭代器，肯定是 find 获得的，而 find 找不到返回的 end 传入 extract 是未定义行为。正如 erase 迭代器版重载 erase(it) 总是成功一样。</li></ul><h4 id="用途举例"><a href="#用途举例" class="headerlink" title="用途举例"></a>用途举例</h4><p>调用者稍后可以直接销毁这个特殊智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(node.<span class="built_in">key</span>(), node.<span class="built_in">mapped</span>());</span><br><span class="line">&#125; <span class="comment">// node 在此自动销毁</span></span><br></pre></td></tr></table></figure><p>也可以做一些修改后（例如修改键值），稍后重新用 insert(node) 重新把他插入回去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;love&quot;</span>;</span><br><span class="line">m.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br></pre></td></tr></table></figure><blockquote><p>过去，通过迭代器来修改键值是不允许的：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(it != m.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// *it 是 pair&lt;const string, int&gt;</span></span><br><span class="line">it-&gt;first = <span class="string">&quot;love&quot;</span>; <span class="comment">// 错误！first 是 const string 类型</span></span><br><span class="line">m.<span class="built_in">insert</span>(*it);</span><br></pre></td></tr></table></figure><blockquote><p>因为直接修改在 map 里面的一个节点的键，会导致排序失效，破坏红黑树的有序。而 extract 取出来的游离态节点，可以修改 <code>.key()</code>，不会影响任何红黑树的顺序，他已经不在树里面了。</p></blockquote><p>或者插入到另一个不同的 map 对象（但键和值类型相同）里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1 挪到 m2</span></span><br><span class="line"><span class="keyword">auto</span> node = m1.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br></pre></td></tr></table></figure><p>优点在于，extract 和节点版 insert 不涉及内存的重新分配与释放，不涉及元素类型的移动（因为节点句柄类似于智能指针，智能指针的移动并不会导致其指向对象的移动），所以会比下面这种传统写法更高效：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1 挪到 m2：传统写法</span></span><br><span class="line"><span class="keyword">if</span> (m1.<span class="built_in">count</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = std::<span class="built_in">move</span>(m1.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">    m2[<span class="string">&quot;fuck&quot;</span>] = std::<span class="built_in">move</span>(value);</span><br><span class="line">    m1.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用 auto 完整写出全部类型的形式（古代 C++98 作风）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> map&lt;K, V&gt;::node_type node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">K &amp;k = node.<span class="built_in">key</span>();</span><br><span class="line">V &amp;v = node.<span class="built_in">mapped</span>();</span><br></pre></td></tr></table></figure><p>set 也有 extract 函数，其节点句柄没有 key() 和 mapped() 了，而是只有一个 value()，获取其中的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;V&gt; s = &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;suck&quot;</span>, <span class="string">&quot;dick&quot;</span>&#125;;</span><br><span class="line">set&lt;V&gt;::node_type node = s.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">V &amp;v = node.<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure><h3 id="insert-节点版"><a href="#insert-节点版" class="headerlink" title="insert 节点版"></a>insert 节点版</h3><p>insert 函数：插入游离节点的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert_return_type <span class="title">insert</span><span class="params">(node_type &amp;&amp;node)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, node_type &amp;&amp;node)</span></span>; <span class="comment">// 带提示的版本</span></span><br></pre></td></tr></table></figure><p>可以用 insert(move(node)) 直接插入一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m1 = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dick&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">auto</span> node = m1.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));  <span class="comment">// 节点句柄类似于 unique_ptr，不可拷贝，需要用移动语义进行插入</span></span><br></pre></td></tr></table></figure><p>调用 insert(move(node)) 后由于所有权被移走，node 将会处于“空指针”状态，可以用 <code>node.empty()</code> 查询节点句柄是否为“空”状态，即节点所有权是否已经移走。</p><h4 id="insert-return-type"><a href="#insert-return-type" class="headerlink" title="insert_return_type"></a>insert_return_type</h4><p>这个版本的 insert 返回值类型 insert_return_type 是一个结构体（我的天他们终于肯用结构体而不是 pair 了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">insert_return_type</span> &#123;</span><br><span class="line">    iterator position;</span><br><span class="line">    <span class="type">bool</span> inserted;</span><br><span class="line">    node_type node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">insert_return_type <span class="title">insert</span><span class="params">(node_type &amp;&amp;nh)</span></span>;</span><br></pre></td></tr></table></figure><p>官方说法是<a href="https://142857.red/book/stl_map/#fn:1">1</a>：</p><blockquote><p>If nh is empty, inserted is false, position is end(), and node is empty.</p><p>Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty.</p><p>If the insertion failed, inserted is false, node has the previous value of nh, and position points to an element with a key equivalent to nh.key().</p></blockquote><h3 id="extract-insert-运用案例"><a href="#extract-insert-运用案例" class="headerlink" title="extract + insert 运用案例"></a>extract + insert 运用案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; hells = &#123;</span><br><span class="line">    &#123;<span class="number">666</span>, <span class="string">&quot;devil&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; schools = &#123;</span><br><span class="line">    &#123;<span class="number">985</span>, <span class="string">&quot;professor&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">211</span>, <span class="string">&quot;doctor&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">996</span>, <span class="string">&quot;fucker&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> node = schools.<span class="built_in">extract</span>(<span class="number">996</span>);</span><br><span class="line">hells.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br><span class="line"><span class="built_in">print</span>(schools);</span><br><span class="line"><span class="built_in">print</span>(hells);</span><br><span class="line">&#123;<span class="number">211</span>: <span class="string">&quot;doctor&quot;</span>, <span class="number">985</span>: <span class="string">&quot;professor&quot;</span>&#125;</span><br><span class="line">&#123;<span class="number">666</span>: <span class="string">&quot;devil&quot;</span>, <span class="number">996</span>: <span class="string">&quot;fucker&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>extract + insert(move(node)) 对比 find + insert({key, val})，可以避免键和值类型移动构造函数的开销，至始至终移动的只是一个红黑树节点的指针，元素没有被移动，也没有造成内存空间不必要的分配和释放。</p><p>但是 insert(move(node)) 仅适用于从 extract 中取出现有节点的情况，如果要新建节点还得靠 insert({key, val}) 或者 try_emplace(key, val) 的。</p><h3 id="extract-性能优化案例"><a href="#extract-性能优化案例" class="headerlink" title="extract 性能优化案例"></a>extract 性能优化案例</h3><p>已知两个映射表 tab1 和 tab2，和一个接受 K 类型做参数的仿函数 cond。</p><p>要求把 tab1 中键符合 cond 条件的元素移动到 tab2 中去，其余保留在 tab1 中。</p><p>我们编写四份同样功能的程序，分别采用：</p><ul><li>extract + 带提示的 insert</li><li>erase + 带提示的 insert</li><li>extract + 直接 insert</li><li>erase + 直接 insert</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_extract</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next_it = it;</span><br><span class="line">            ++next_it;</span><br><span class="line">            <span class="keyword">auto</span> node = tab1.<span class="built_in">extract</span>(it);</span><br><span class="line">            tab2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br><span class="line">            it = next_it;</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_erase</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            it = tab1.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">auto</span> kv = std::<span class="built_in">move</span>(*it);</span><br><span class="line">            tab2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(kv));</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_extract_with_hint</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">auto</span> hint = tab2.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next_it = it;</span><br><span class="line">            ++next_it;</span><br><span class="line">            <span class="keyword">auto</span> node = tab1.<span class="built_in">extract</span>(it);</span><br><span class="line">            hint = tab2.<span class="built_in">insert</span>(hint, std::<span class="built_in">move</span>(node));</span><br><span class="line">            it = next_it;</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_erase_with_hint</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">auto</span> hint = tab2.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            it = tab1.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">auto</span> kv = std::<span class="built_in">move</span>(*it);</span><br><span class="line">            hint = tab2.<span class="built_in">insert</span>(hint, std::<span class="built_in">move</span>(kv));</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extract vs erase 性能测试结果 (testextractvserase.cpp)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">avg</span>   <span class="string">|</span>   <span class="string">min</span>   <span class="string">|</span>   <span class="string">max</span>   <span class="string">|</span>  <span class="string">total</span>  <span class="string">|</span> <span class="string">cnt</span> <span class="string">|</span> <span class="string">tag</span></span><br><span class="line">   <span class="number">889</span><span class="string">|</span>      <span class="number">803</span><span class="string">|</span>     <span class="number">2388</span><span class="string">|</span>   <span class="number">889271</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_erase</span></span><br><span class="line">   <span class="number">642</span><span class="string">|</span>      <span class="number">595</span><span class="string">|</span>     <span class="number">1238</span><span class="string">|</span>   <span class="number">642542</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_extract</span></span><br><span class="line">   <span class="number">525</span><span class="string">|</span>      <span class="number">491</span><span class="string">|</span>     <span class="number">1398</span><span class="string">|</span>   <span class="number">525137</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_erase_with_hint</span></span><br><span class="line">   <span class="number">305</span><span class="string">|</span>      <span class="number">289</span><span class="string">|</span>      <span class="number">842</span><span class="string">|</span>   <span class="number">305472</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_extract_with_hint</span></span><br></pre></td></tr></table></figure><p>extract + 带提示的 insert 获胜，即函数 <code>filter_with_extract_with_hint</code> 是性能最好的那一个。</p><h3 id="游离节点可以修改键值"><a href="#游离节点可以修改键值" class="headerlink" title="游离节点可以修改键值"></a>游离节点可以修改键值</h3><p>由于处于游离状态，游离节点不属于任何 map 中，不需要满足排序性质，因此 <code>node.key()</code> 可修改。</p><p>先用 extract 取出游离态节点，修改完节点的键后再重新插入，利用这一点做到以前做不到的修改键值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);  <span class="comment">// 移出 &quot;fuck&quot; 键对应的节点，此时 m 会变为空</span></span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;fxxk&quot;</span>;  <span class="comment">// 修改键（以前用迭代器时 it-&gt;first 是不允许修改键的，因为迭代器指向的节点不是游离状态，修改键会破坏排序）</span></span><br><span class="line">node.<span class="built_in">mapped</span>() = <span class="number">211</span>;  <span class="comment">// 修改值（这个以前用迭代器时 it-&gt;second 也可以修改）</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">move</span>(node)); <span class="comment">// 把修改好的节点插入回去</span></span><br><span class="line"><span class="built_in">print</span>(m);             <span class="comment">// &#123;&#123;&quot;fxxk&quot;: 211&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>相当于你给小学生排队时，有一个小学生突然瞬间不知道吃了什么激素长高了，你的队伍就会乱掉。</p><p>所以需要让这个小学生先出列，让他单独一个人长高，等他长高完了再插入回队列。</p><h3 id="带提示的节点版-insert"><a href="#带提示的节点版-insert" class="headerlink" title="带提示的节点版 insert"></a>带提示的节点版 insert</h3><p>但是小学生长高的量可能是有限的（新的键可能和老键很接近）。</p><p>这时插入可以优先从他长高之前的位置开始二分法，也就是用 extract 之前，这个小学生后一位同学的位置，作为 insert 的提示，让 insert 更快定位到这个小学生应该插入的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(it != m.<span class="built_in">end</span>()); <span class="comment">// 假定 &quot;fuck&quot; 必须存在（如果不存在会返回 end）</span></span><br><span class="line"><span class="keyword">auto</span> next_it = std::<span class="built_in">next</span>(it); <span class="comment">// 下一位同学（可能会得到 end，但没关系，因为 insert 的提示也允许为 end 迭代器）</span></span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(it);</span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;fxxk&quot;</span>;   <span class="comment">// 修改键值，变化不大</span></span><br><span class="line">m.<span class="built_in">insert</span>(next_it, <span class="built_in">move</span>(node)); <span class="comment">// 如果键值变动不大，优先尝试在老位置插入</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>std::next(it)</code> 对于等价于 it + 1。但是 map 属于双向迭代器（而不是随机迭代器），不支持加法操作，只支持就地 ++。所以 <code>std::next</code> 内部等价于：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">next</span><span class="params">(<span class="keyword">auto</span> it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> next_it = it; <span class="comment">// 先拷贝一份，防止原迭代器被破坏（迭代器都支持拷贝，性质上是浅拷贝）</span></span><br><span class="line">    ++next_it;         <span class="comment">// 再让 next_it 就地自增到下一位</span></span><br><span class="line">    <span class="keyword">return</span> next_it;    <span class="comment">// 返回现在已经相当于 it + 1 的 next_it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果键不变，或者键变了以后，插入位置不变的话，那么这次 insert 可以低至 O(1)O(1) 复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;dick&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;, <span class="comment">// &quot;fuck&quot; -&gt; &quot;fxxk&quot; 后，重新插入，其依字典序的“大小”依然是介于 &quot;dick&quot; 和 &quot;suck&quot;</span></span><br><span class="line">    &#123;<span class="string">&quot;suck&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="merge：map-的合并操作（并集）"><a href="#merge：map-的合并操作（并集）" class="headerlink" title="merge：map 的合并操作（并集）"></a>merge：map 的合并操作（并集）</h3><p>C++17 新增的 merge 函数<a href="https://142857.red/book/stl_map/#fn:1">1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Cmp2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(map&lt;K, V, Cmp2&gt; &amp;__source)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：set 也有 merge 函数</p></blockquote><p>注意到 merge 的参数是另一个 map，可变引用，必须和本 map 同类型（这是为了保证节点句柄类型相同），但允许有不同的比较函数</p><ul><li><code>merge(source)</code> 会把 source 中的所有节点都<strong>移动</strong>并合并到本 map，注意是<strong>移动</strong>而不是拷贝，source 将会被清空，这样是为了更高效。</li><li><code>insert(source.begin(), source.end())</code> 则是把 source 里的元素拷贝后插入到本 map，更低效，因为需要拷贝，还得新建红黑树节点，额外分配内存空间。</li></ul><p>对于键存在冲突的情况：</p><ul><li>merge: 如果 source 中有与本 map 重复的键，则该元素不会被移动，保留在 source 里。</li><li>insert: 如果 source 中有与本 map 重复的键，则该元素不会被插入本 map。无论有没有插入本 map，原 source 中的键都不会被清除。</li></ul><blockquote><p>因此，merge 也并不总是完全清空 source，当 source 和本 map 有冲突时，冲突的键就保留在 source 里了。</p></blockquote><p>merge 等价于以下手动用 extract 和 insert 来移动节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.merge(m2) 等价于：</span></span><br><span class="line"><span class="keyword">auto</span> hint = m1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m2.<span class="built_in">begin</span>(); it != m2.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!m1.<span class="built_in">contains</span>(it-&gt;first)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = m2.<span class="built_in">extract</span>(it);</span><br><span class="line">        hint = m1.<span class="built_in">insert</span>(hint, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量-insert-vs-merge"><a href="#批量-insert-vs-merge" class="headerlink" title="批量 insert vs merge"></a>批量 insert vs merge</h4><p>同样做到两个 map 合并，<code>m1.merge(m2)</code> 与 <code>m1.insert(m2.begin(), m2.end())</code> 性能比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;benchmark/benchmark.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_Insert</span><span class="params">(benchmark::State &amp;state)</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m1_init;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m2_init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">range</span>(<span class="number">0</span>); i++) &#123;</span><br><span class="line">        m1_init[<span class="built_in">to_string</span>(i)] = i;</span><br><span class="line">        m2_init[<span class="built_in">to_string</span>(i + state.<span class="built_in">range</span>(<span class="number">0</span>))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">auto</span> m1 = m1_init;</span><br><span class="line">        <span class="keyword">auto</span> m2 = m2_init;</span><br><span class="line">        m2.<span class="built_in">insert</span>(m1.<span class="built_in">begin</span>(), m1.<span class="built_in">end</span>());</span><br><span class="line">        benchmark::<span class="built_in">DoNotOptimize</span>(m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_Insert)-&gt;<span class="built_in">Arg</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_Merge</span><span class="params">(benchmark::State &amp;state)</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m1_init;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m2_init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">range</span>(<span class="number">0</span>); i++) &#123;</span><br><span class="line">        m1_init[<span class="built_in">to_string</span>(i)] = i;</span><br><span class="line">        m2_init[<span class="built_in">to_string</span>(i + state.<span class="built_in">range</span>(<span class="number">0</span>))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">auto</span> m1 = m1_init;</span><br><span class="line">        <span class="keyword">auto</span> m2 = m2_init;</span><br><span class="line">        m2.<span class="built_in">merge</span>(m1);</span><br><span class="line">        benchmark::<span class="built_in">DoNotOptimize</span>(m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_Merge)-&gt;<span class="built_in">Arg</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>merge 函数不会产生不必要的内存分配导致内存碎片化，所以更高效。但作为代价，他会清空 m2！</p><ul><li>merge 相当于把 m2 的元素“移动”到 m1 中去了。</li><li>insert 则是把 m2 的元素“拷贝”了一份插入到 m1 中去，效率自然低下。</li></ul><p>如果不想破坏掉 m2，或者你用不上 C++17，则仍需要传统的 insert。</p><h4 id="merge-和-insert-一样不覆盖旧值"><a href="#merge-和-insert-一样不覆盖旧值" class="headerlink" title="merge 和 insert 一样不覆盖旧值"></a>merge 和 insert 一样不覆盖旧值</h4><p>merge(m2) 和 insert(m2.begin(), m2.end()) 一样尿性：如果 m2 中的键在 m1 中已经存在，则不会 extract 该 m2 中的节点，仍然留在 m2 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; ma &#123;&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;pear&quot;</span>&#125;, &#123;<span class="number">10</span>, <span class="string">&quot;banana&quot;</span>&#125;&#125;;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; mb &#123;&#123;<span class="number">2</span>, <span class="string">&quot;zorro&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;batman&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;X&quot;</span>&#125;, &#123;<span class="number">8</span>, <span class="string">&quot;alpaca&quot;</span>&#125;&#125;;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; u;</span><br><span class="line">  u.<span class="built_in">merge</span>(ma);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ma.size(): &quot;</span> &lt;&lt; ma.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  u.<span class="built_in">merge</span>(mb);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mb.size(): &quot;</span> &lt;&lt; mb.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mb.at(5): &quot;</span> &lt;&lt; mb.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="type">const</span> &amp;kv: u)</span><br><span class="line">    std::cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-自定义比较器"><a href="#map-自定义比较器" class="headerlink" title="map 自定义比较器"></a>map 自定义比较器</h2><p>map 容器的全部参数为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, Cmp, Alloc&gt;</span><br></pre></td></tr></table></figure><p>其中第 3、4 个参数 Cmp 和 Alloc 可以省略。</p><ul><li>Cmp 默认为 <code>std::less&lt;K&gt;</code></li><li>Alloc 默认为 <code>std::allocator&lt;std::pair&lt;K, V&gt;&gt;</code></li></ul><p>因此 <code>map&lt;K, V&gt;</code> 的完整模板参数是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;, std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>我们可以简写成 <code>map&lt;K, V&gt;</code>。</p><p>其中 allocator 我们以后专门开一节课讲，其他很多容器都有 allocator。</p><p>今天只研究 Cmp 这个参数，他决定了 map 如何排序，判断相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个 <code>std::less</code> 是个什么呢？是一个仿函数(functor)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;x, T <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具有成员函数 <code>operator()</code> 的类型，都被称之为仿函数。</p><h3 id="std-less-的作用"><a href="#std-less-的作用" class="headerlink" title="std::less 的作用"></a><code>std::less</code> 的作用</h3><p>仿函数对象，可以直接用圆括号当做普通函数调用，这就是“仿函数”的得名原因，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="type">int</span>&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line">less&lt;string&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>));   <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br><span class="line">less&lt;string_view&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>));   <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure><h4 id="operator"><a href="#operator" class="headerlink" title="operator()"></a><code>operator()</code></h4><p>注意仿函数的成员函数 <code>operator()</code> 是两个括号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">operator</span>()(...)</span><br></pre></td></tr></table></figure><ul><li>第一个括号是 <code>operator()</code> 的一部分，表示这是对圆括号 <code>()</code> 的运算符重载。</li><li>第二个括号是函数的参数列表，里面是 <code>operator()</code> 这个函数的形参。</li></ul><blockquote><p><code>operator()</code> 相当于 Python 中的 <code>__call__</code>。正如 <code>operator&lt;</code> 相当于 Python 中的 <code>__lt__</code>。这里 <code>operator</code> 和 <code>()</code> 是一个整体，连在一起，形成了一个标识符。</p></blockquote><h3 id="自定义排序方式"><a href="#自定义排序方式" class="headerlink" title="自定义排序方式"></a>自定义排序方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;&gt;</span><br></pre></td></tr></table></figure><p>我们之前提到 map 内部的元素始终按照键 K 从小到大的顺序排列。</p><p>map 决定大小顺序的，并不是直接调用 K 类型的比较运算符 <code>operator&lt;</code>。</p><p>而是调用他的模板参数 Cmp 类型的 <code>operator()</code>。</p><p>这是为了允许用户通过修改这个参数，控制 map 内部的行为，防止 map 数据结构与具体的比较方法耦合。</p><p>由于默认的 Cmp 是 <code>less&lt;K&gt;</code>，调用 <code>Cmp()(x, y)</code> 就相当于 <code>x &lt; y</code>，由此实现从小到大排序。</p><p>接下来我们将修改这一默认行为。</p><h4 id="只需要小于号"><a href="#只需要小于号" class="headerlink" title="只需要小于号"></a>只需要小于号</h4><p>一个类型要想作为 map 的键，只需要他支持 <code>&lt;</code> 运算符即可，不必定义其他 <code>&gt;</code>、<code>==</code> 运算符。</p><p>当 map 需要判断两个键是否相等时 <code>x == y</code>，会用 <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> 来等价地计算。</p><p>string, string_view, int, float, void *, shared_ptr, pair, tuple, array…</p><p>这些类型都支持比较运算符，都可以作为 map 的键。</p><h3 id="自定义小于号的三种方式"><a href="#自定义小于号的三种方式" class="headerlink" title="自定义小于号的三种方式"></a>自定义小于号的三种方式</h3><p>如果你写了个自定义类 Student，要让他作为 map 的键类型，有三种方法：</p><p>一、在 Student 类中添加 <code>operator&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Student <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)));</span><br><span class="line">        <span class="comment">// 等价于：</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex); <span class="comment">// tuple 实现了正确的 operator&lt; 运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><p>二、特化 <code>less&lt;Student&gt;</code>，添加 <code>operator()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;Student&gt; &#123;  <span class="comment">// 用户可以特化标准库中的 trait</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：以后如果 map 外面要用用到这个类的大小比较，也只能用 <code>less&lt;Student&gt;()(stu1, stu2)</code> 代替 <code>stu1 &lt; stu2</code>。</p></blockquote><p>三、重新自定义一个仿函数类 <code>LessStudent</code>，添加 <code>operator()</code>，然后把这个 <code>LessStudent</code> 作为 map 的比较器传入模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>, LessStudent&gt; stutab;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：以后每次创建新的 map 时，都需要加一个 LessStudent 参数。</p></blockquote><h3 id="自定义按哪个字段来索引"><a href="#自定义按哪个字段来索引" class="headerlink" title="自定义按哪个字段来索引"></a>自定义按哪个字段来索引</h3><p>如果希望 map 在查找时只根据学生姓名索引，则只需要改一下比较器的实现，让他只比较姓名字段即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LessStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这样的比较器，map 会认为姓名 name 相同的 Student 就是相等的，并去重。即使 id 和 sex 不同，只要名字相等就会视为重复，利用这一点可以实现针对特定字段的去重。</p><blockquote><p>结论：map 的排序和去重，都取决于于你的比较器如何实现！比较器里没比较的字段，就会被忽略而不参与排序、索引、和去重。</p></blockquote><h3 id="C-20-三路运算符"><a href="#C-20-三路运算符" class="headerlink" title="C++20 三路运算符 &lt;=&gt;"></a>C++20 三路运算符 <code>&lt;=&gt;</code></h3><p>四（同一）、利用 C++20 新特性，三路比较运算符 <code>&lt;=&gt;</code>：如果自定义类的每个成员都支持比较运算符，可以把 <code>operator&lt;=&gt;</code> 函数声明为 <code>default</code>，然后编译器会自动添加自定义类的所有比较运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(Student <span class="type">const</span> &amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时默认的 <code>operator&lt;</code> 实现等价于 <code>x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)))</code>。</p><blockquote><p><code>&lt;=&gt;</code> 的返回类型是 <code>std::strong_ordering</code>，这是一种有三种取值的强枚举类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;=&gt;` 对应的仿函数为 `std::compare_three_way</span><br></pre></td></tr></table></figure></blockquote><h3 id="仿函数运算符全家桶"><a href="#仿函数运算符全家桶" class="headerlink" title="仿函数运算符全家桶"></a>仿函数运算符全家桶</h3><p>libstdc++ 头文件中的 less 和 greater 实现参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">  <span class="type">bool</span></span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">  <span class="type">bool</span></span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似的运算符仿函数还有：</p><table><thead><tr><th>运算符</th><th>仿函数类</th></tr></thead><tbody><tr><td>x &#x3D;&#x3D; y</td><td>std::equal_to</td></tr><tr><td>x !&#x3D; y</td><td>std::not_equal_to</td></tr><tr><td>x &lt; y</td><td>std::less</td></tr><tr><td>x &gt; y</td><td>std::greater</td></tr><tr><td>x &lt;&#x3D; y</td><td>std::less_equal</td></tr><tr><td>x &gt;&#x3D; y</td><td>std::greater_equal</td></tr><tr><td>x + y</td><td>std::plus</td></tr><tr><td>x - y</td><td>std::minus</td></tr><tr><td>x * y</td><td>std::multiplies</td></tr><tr><td>x &#x2F; y</td><td>std::divides</td></tr><tr><td>x % y</td><td>std::modulus</td></tr><tr><td>-x</td><td>std::negate</td></tr></tbody></table><p>他们都在 <code>#include &lt;functional&gt;</code> 头文件中定义。</p><h3 id="greater-实现反向排序"><a href="#greater-实现反向排序" class="headerlink" title="greater 实现反向排序"></a>greater 实现反向排序</h3><p>案例：使用 greater 仿函数，让 map 反过来从大到小排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ilist = &#123;</span><br><span class="line">    &#123;<span class="number">985</span>, <span class="string">&quot;拳打&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">211</span>, <span class="string">&quot;脚踢&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m1 = ilist;                <span class="comment">// 从小到大排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, string, greater&lt;<span class="type">int</span>&gt;&gt; m2 = ilist;  <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">print</span>(m1); <span class="comment">// &#123;&#123;211, &quot;脚踢&quot;&#125;, &#123;985, &quot;拳打&quot;&#125;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(m2); <span class="comment">// &#123;&#123;985, &quot;拳打&quot;&#125;, &#123;211, &quot;脚踢&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="大小写不敏感的字符串比较器"><a href="#大小写不敏感的字符串比较器" class="headerlink" title="大小写不敏感的字符串比较器"></a>大小写不敏感的字符串比较器</h3><p>自定义比较仿函数，实现无视键大小写的 map 容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LessIgnoreCase</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::lexicographical_compare <span class="comment">// 位于 &lt;algorithm&gt; 头文件，和 std::string 同款的字典序比较</span></span><br><span class="line">        ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">        , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">        , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, string, LessIgnoreCase&gt; m = &#123;</span><br><span class="line">        &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;STUdy&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;stUDy&quot;</span>&#125;, <span class="string">&quot;js&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print</span>(m);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fuck对应的值为:&quot;</span>, m.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;Fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;STUdy&quot;</span>: <span class="string">&quot;cpp&quot;</span>&#125;</span><br><span class="line">fuck对应的值为: <span class="string">&quot;rust&quot;</span></span><br></pre></td></tr></table></figure><h3 id="传入-lambda-做比较器"><a href="#传入-lambda-做比较器" class="headerlink" title="传入 lambda 做比较器"></a>传入 lambda 做比较器</h3><p>C++11 的 lambda 表达式也是仿函数，配合 decltype 后就可以传入 map 作为比较器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">lexicographical_compare</span></span><br><span class="line">    ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">    , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">    , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, string, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;Study&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;, cmp)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(&#123;<span class="string">&quot;fuck&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(val);</span><br></pre></td></tr></table></figure><p>写的更清晰一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">lexicographical_compare</span></span><br><span class="line">    ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">    , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">    , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, string, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(cmp)</span></span>;</span><br><span class="line">m = &#123;</span><br><span class="line">    &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;&#123;<span class="string">&quot;Study&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(&#123;<span class="string">&quot;fuck&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(val);</span><br></pre></td></tr></table></figure><h4 id="map-构造函数是如何传入比较器的"><a href="#map-构造函数是如何传入比较器的" class="headerlink" title="map 构造函数是如何传入比较器的"></a>map 构造函数是如何传入比较器的</h4><p>刚刚用到的两个 map 构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span> = std::less&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map &#123;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">map</span>(Cmp cmp);</span><br><span class="line">    <span class="built_in">map</span>(initializer_list&lt;pair&lt;K, V&gt;&gt; ilist, Cmp cmp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本每个 map 的构造函数都有一个提供额外 cmp 参数的版本，统一都是在最后一个参数后面追加。</p><h4 id="有状态（捕获变量）的比较器"><a href="#有状态（捕获变量）的比较器" class="headerlink" title="有状态（捕获变量）的比较器"></a>有状态（捕获变量）的比较器</h4><p>传入的仿函数 cmp 甚至可以捕获其他变量，这种捕获了变量的仿函数称之为有状态仿函数 - stateful functor，和无状态仿函数 - stateless functor 相对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [&amp;] (<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[i] &lt; arr[j];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure><p>利用有状态仿函数可以实现 argsort 等操作，例如上面代码就是根据在 arr 里对应索引的值来排序。</p><blockquote><p>由于 map 需要比较仿函数为纯函数(pure function)，在上面例子中，请保证 map 存在期间 arr 的内容不发生变化，否则 map 基于排序的二分查找功能会得到错误的结果。</p></blockquote><p>传入比较器仿函数是设计模式中典型的策略模式，通过依赖注入，允许我们控制 map 内部的行为。</p><h4 id="建议用-function"><a href="#建议用-function" class="headerlink" title="建议用 function"></a>建议用 function</h4><p>如果嫌 decltype 麻烦（难以在全局或类内部用），function 容器作为比较运算符，就可以统一了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; m;</span><br></pre></td></tr></table></figure><p>稍后还可以通过 <code>key_comp()</code> 获取到用于键比较的仿函数，这个就是你刚刚传入的 cmp 参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">key_comp</span>()(<span class="number">1</span>, <span class="number">2</span>);              <span class="comment">// 等价于 cmp(1, 2)</span></span><br></pre></td></tr></table></figure><p><code>value_comp()</code> 获取到用于元素（键-值对）比较的仿函数（他帮你适配参数类型了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">value_comp</span>()(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;);  <span class="comment">// 等价于 cmp(1, 2)</span></span><br></pre></td></tr></table></figure><h2 id="透明-map"><a href="#透明-map" class="headerlink" title="透明 map"></a>透明 map</h2><h3 id="什么是透明仿函数"><a href="#什么是透明仿函数" class="headerlink" title="什么是透明仿函数"></a>什么是透明仿函数</h3><p>C++14 新增了“透明(transparent)”运算符仿函数。</p><p>对于 less、greater 这类标准库提供的仿函数，指定模板参数为 void 即可让一个运算符仿函数变成“透明”的。例如对 less 而言，他的透明版就是 <code>less&lt;void&gt;</code>。</p><p>C++14 之前用的都是“不透明”版的仿函数，必须指定一个具体的类型，例如 <code>less&lt;int&gt;</code> 就只能用于 int 类型的比较，<code>less&lt;string&gt;</code> 就只能用于 string 类型的比较。</p><p>无法用 <code>less&lt;int&gt;</code> 仿函数比较 string 类型。</p><p>而 <code>less&lt;void&gt;</code> 是通用的，他的 <code>operator()</code> 函数是泛型的，可以接受任意类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span>&lt;<span class="type">void</span>&gt; &#123;   <span class="comment">// 针对 void 的特化</span></span><br><span class="line">    <span class="comment">// 标准委员会想：由于 void 类型不可能有 &lt; 运算符的需求，所以他们干脆拿 void 作为透明版的模板参数“占位符”了</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tx</span>, <span class="keyword">class</span> <span class="title class_">Ty</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">operator</span><span class="params">()</span><span class="params">(Tx &amp;&amp;x, Ty &amp;&amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forward&lt;Tx&gt;(x) &lt; forward&lt;Ty&gt;(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">is_transparent</span>;  <span class="comment">// 空类，仅供 SFINAE 元编程时检测一个仿函数是否透明时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://142857.red/book/img/question.png" alt="img"> 我的思考：不透明版的 <code>less&lt;T&gt;</code> 泛型体现在类的模板参数上，而透明版的体现在了成员函数 <code>operator()</code> 的模板参数上。</p><p><img src="https://142857.red/book/img/bulb.png" alt="img"> 这里用 <code>void</code> 特化只是一个偷懒，<code>void</code> 并没有什么特殊的，实际上应该单独定义一个没有模板的 <code>transparent_less</code> 类，但他们就是懒得引入新标识符。</p></blockquote><h3 id="为什么需要透明仿函数"><a href="#为什么需要透明仿函数" class="headerlink" title="为什么需要透明仿函数"></a>为什么需要透明仿函数</h3><p>“透明”版的好处是可以同一个兼容任意类型，而不必创建多个 cmp 对象。而不透明版的好处是方便特化 traits，但毕竟 &lt; 运算符是可以用户自定义(运算符重载)的，没必要用 traits 特化，所以他们逐步发现透明版香了，还能支持左右参数为不同类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="type">void</span>&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>));  <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;cmake&quot;</span>), <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure><blockquote><p>但也要特别注意不能再依赖参数类型自动的隐式转换了，必须至少写完整其中一个 <code>string(&quot;hello&quot;)</code> 才能触发 <code>string</code> 的 <code>operator&lt;</code> 而不是 <code>const char *</code> 的指针比大小。如果只写 <code>cmp(&quot;cmake&quot;, &quot;cppcon&quot;)</code> 则是在比较指针的地址大小，结果是不一定的。</p></blockquote><p>由于 C++14 的 less 模板参数 T 默认为 void，所以 <code>less&lt;void&gt;</code> 还可以简写成 <code>less&lt;&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">less&lt;&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>));  <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;cmake&quot;</span>), <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure><h3 id="泛型版的-find-函数"><a href="#泛型版的-find-函数" class="headerlink" title="泛型版的 find 函数"></a>泛型版的 find 函数</h3><p>普通 find 函数：键类型作为参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>C++14 新增泛型版的 find 函数<a href="https://142857.red/book/stl_map/#fn:1">1</a>：任意类型作为参数，只要该类型支持与和键比大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(Kt &amp;&amp;k)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(Kt &amp;&amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 Kt 是模板参数类型，可以接受任意类型，此处 <code>&amp;&amp;</code> 是万能引用不是右值引用。</p></blockquote><p>相同点：找到了就返回一个迭代器指向与该参数相等的元素，如果找不到还是返回 end()。</p><p>不同点：泛型版本的参数类型 Kt 不必和键类型 K 一致，只要 Kt 和 K 可以比较大小（&lt; 运算符）即可。</p><p>不仅</p><h3 id="泛型-find-的要求：透明"><a href="#泛型-find-的要求：透明" class="headerlink" title="泛型 find 的要求：透明"></a>泛型 find 的要求：透明</h3><p>要想用泛型版的 find 函数有一个条件：</p><p>map 的比较器必须是“透明(transparent)”的，也就是 <code>less&lt;void&gt;</code> 这种。否则泛型版的 <code>find(Kt &amp;&amp;)</code> 不会参与重载，也就是只能调用传统的 <code>find(K const &amp;)</code>。</p><p>但是 <code>map&lt;K, V&gt;</code> 默认的比较器是 <code>less&lt;K&gt;</code>，他是不透明的，比较的两边必须都是 <code>K</code> 类型。如果其中一边不是的话，就得先隐式转换为 <code>K</code> 才能用。</p><p>这是早期 C++98 设计的失败，当时他们没想到 <code>find</code> 还可以接受 <code>string_view</code> 和 <code>const char *</code> 这类可以和 <code>string</code> 比较，但构造会廉价得多的弱引用类型。</p><p>只好后来引入了透明比较器企图力挽狂澜，然而为了历史兼容，<code>map&lt;K, V&gt;</code> 默认仍然是 <code>map&lt;K, V, less&lt;K&gt;&gt;</code>。</p><p>如果我们同学的编译器支持 C++14，建议全部改用这种写法 <code>map&lt;K, V, less&lt;&gt;&gt;</code>，从而用上更高效的 find、at、erase、count、contains 等需要按键查找元素的函数。</p><h4 id="应用：字符串为键的字典"><a href="#应用：字符串为键的字典" class="headerlink" title="应用：字符串为键的字典"></a>应用：字符串为键的字典</h4><p>除非传入的刚好就是一个 <code>string</code> 的 const 引用，否则就会发生隐式构造 <code>string</code> 的操作。</p><p>如果传入的是一个 <code>string_view</code> 或 <code>const char *</code>，那么需要从他们构造出一个 <code>string</code>，然后才能传入传统的 <code>find(string const &amp;)</code> 函数。而 <code>string</code> 的构造会发生拷贝，且可能产生内存分配。</p><p>对于比较大的字符串做键值，每次查找都需要重新构造一个 <code>string</code> 对象，开销会比较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; lut;</span><br><span class="line"></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="built_in">string</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>)); <span class="comment">// 隐式构造了一个 string，导致深拷贝了整个字符串！</span></span><br></pre></td></tr></table></figure><p>而启用了透明比较后，就不需要每次都拷贝整个字符串来构造 <code>string</code> 了。因为 find、at 这类函数会启用一个泛型的版本 <code>at(Kt &amp;&amp;)</code>，Kt 可以是任何类型，只要他支持与 <code>string</code> 比较。可以是 <code>const char *</code>，<code>string_view</code> 或另一个 <code>string</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>, less&lt;&gt;&gt; lut;</span><br><span class="line"></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">lut.<span class="built_in">at</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为不用拷贝了，更加高效，特别是对于键字符串非常长的情况。</p><p>at 内部也不会构造任何新的 <code>string</code>，他会拿着 <code>const char *</code> 和红黑树中的每个节点调用 <code>==</code> 比较。</p><blockquote><p><code>string == const char *</code> 是安全的，会比较字符串的内容而不是地址。</p></blockquote><h4 id="应用：智能指针为键的字典"><a href="#应用：智能指针为键的字典" class="headerlink" title="应用：智能指针为键的字典"></a>应用：智能指针为键的字典</h4><p>某有某些特殊情况下，我们需要把指针，甚至智能指针！放进 map 或 set 的键中，用于快速按指针的值查找到元素。（是的你没听错，是放在<strong>键类型</strong>里！）</p><blockquote><p>轶事：把指针放在键里并不罕见，常见的一个用法是 <code>set&lt;Node *&gt;</code>。好处是当 <code>Node</code> 析构时，他可以直接调用 <code>set.erase(this)</code> 把自己剔除掉。而普通的 <code>set&lt;Node&gt;</code> 就很难做到这一点了，你无法通过 Node 的 this 指针获得他在 set 中的迭代器，也无法知道自己位于哪个 set 中。侵入式红黑树完美解决了这一痛点，LLVM 和 Linux 内核中都大量运用了侵入式链表&#x2F;LRU&#x2F;红黑树，以后的高级数据结构课程中会为你讲解。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;Node *, <span class="type">int</span>&gt; lut;</span><br><span class="line"></span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr);</span><br></pre></td></tr></table></figure><p>如果是智能指针，就比较困难了，特别是 <code>unique_ptr</code>。如果你已知一个原始指针，想要在 map 中查找指向同样的智能指针键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr); <span class="comment">// 错误：无法从 Node * 隐式构造 unique_ptr&lt;Node&gt;</span></span><br></pre></td></tr></table></figure><p>过去，人们不得不用一种称为 stale-ptr（变质指针）的黑科技，来构造一个不掌握生命周期的伪 unique_ptr 出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line"><span class="function">unique_ptr&lt;Node&gt; <span class="title">stale_ptr</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">// 一个并不掌握生命周期的“变质智能指针”</span></span><br><span class="line">lut.<span class="built_in">find</span>(stale_ptr); <span class="comment">// OK: 匹配到 find(unique_ptr&lt;Node&gt; const &amp;) 重载</span></span><br><span class="line">stale_ptr.<span class="built_in">release</span>(); <span class="comment">// 必须！否则会出现双重释放 (double-free) 错误</span></span><br></pre></td></tr></table></figure><p>而 C++14 中，我们只需定义一个透明的比较函数，支持 <code>Node *</code> 与 <code>unique_ptr&lt;Node&gt;</code> 互相比较即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">transparent_ptr_less</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *<span class="type">const</span> &amp;p1, T <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 &lt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *<span class="type">const</span> &amp;p1, unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 &lt; p2.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p1, T *<span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.<span class="built_in">get</span>() &lt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p1, unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.<span class="built_in">get</span>() &lt; p2.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> is_transparent = std::true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>, transparent_ptr_less&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr); <span class="comment">// OK: 匹配到泛型的 find(Kt &amp;&amp;) 重载，其中 Kt 推导为 Node *const &amp;</span></span><br></pre></td></tr></table></figure><h4 id="应用：超大对象为键的字典"><a href="#应用：超大对象为键的字典" class="headerlink" title="应用：超大对象为键的字典"></a>应用：超大对象为键的字典</h4><p>以下摘自 cppreference 上泛型 find 的官方案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FatKey</span>   &#123; <span class="type">int</span> x; <span class="type">int</span> data[<span class="number">1000</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LightKey</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="comment">// Note: as detailed above, the container must use std::less&lt;&gt; (or other </span></span><br><span class="line"><span class="comment">//   transparent Comparator) to access these overloads.</span></span><br><span class="line"><span class="comment">// This includes standard overloads, such as between std::string and std::string_view.</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> FatKey&amp; fk, <span class="type">const</span> LightKey&amp; lk) &#123; <span class="keyword">return</span> fk.x &lt; lk.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> LightKey&amp; lk, <span class="type">const</span> FatKey&amp; fk) &#123; <span class="keyword">return</span> lk.x &lt; fk.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> FatKey&amp; fk1, <span class="type">const</span> FatKey&amp; fk2) &#123; <span class="keyword">return</span> fk1.x &lt; fk2.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// transparent comparison demo</span></span><br><span class="line">    std::map&lt;FatKey, <span class="type">char</span>, std::less&lt;&gt;&gt; example = &#123;&#123;&#123;<span class="number">1</span>, &#123;&#125;&#125;, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;&#123;<span class="number">2</span>, &#123;&#125;&#125;, <span class="string">&#x27;b&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    LightKey lk = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> search = example.<span class="built_in">find</span>(lk); search != example.<span class="built_in">end</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; search-&gt;first.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Found <span class="number">2</span> b</span><br></pre></td></tr></table></figure><h2 id="神奇的-multimap"><a href="#神奇的-multimap" class="headerlink" title="神奇的 multimap"></a>神奇的 multimap</h2><p>允许重复键值的 multimap</p><p>map 中一个键对应一个值，而 multimap 一个键可以对应多个值。</p><ul><li>map：排序 + 去重；</li><li>multimap：只排序，不去重。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map&lt;K, V&gt; 的插入函数：</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; &amp;&amp;kv)</span></span>;</span><br><span class="line"><span class="comment">// multimap&lt;K, V&gt; 的插入函数：</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; &amp;&amp;kv)</span></span>;</span><br></pre></td></tr></table></figure><p>因为 multimap 允许重复键值，所以插入总是成功，与普通 map 相比不用返回 bool 表示是否成功了。</p><h3 id="元素的排列顺序"><a href="#元素的排列顺序" class="headerlink" title="元素的排列顺序"></a>元素的排列顺序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; tab;</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;silly&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;smart&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;lazy&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;fast&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;pig&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(tab);</span><br><span class="line">&#123;<span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;smart&quot;</span>, <span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;fast&quot;</span>, <span class="string">&quot;java&quot;</span>: <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;silly&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;trash&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;trash&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;lazy&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>插入进 multimap 的重复键会紧挨着，他们之间的顺序取决于插入的顺序。例如上面键同样是 “cpp” 的两个元素，”smart” 先于 “fast” 插入，所以 “smart” 靠前了。</p><h3 id="用途：动态排序！"><a href="#用途：动态排序！" class="headerlink" title="用途：动态排序！"></a>用途：动态排序！</h3><p>multimap &#x2F; multiset 的作用通常就不是键值映射了，而是利用红黑树会保持元素有序的特性（任何二叉搜索树都这样）实现一边插入一边动态排序。</p><p>传统排序方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>multiset 排序方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;<span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    tab.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需再排序，tab 中的键已经是有序的了！</span></span><br><span class="line"><span class="comment">// 如需取出到 vector:</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(tab.begin(), tab.end())</span></span>;</span><br></pre></td></tr></table></figure><p>利用 multimap 键-值对的特点，还能轻易实现只对键排序，值的部分不参与排序的效果。</p><p>multimap 排序的好处是：</p><ul><li>动态排序，在插入的过程中就保持整个红黑树的有序性，最后任何无需额外操作。</li><li>在一次次插入的过程中，每时每刻都是有序的，而不必等到最后才变得有序。</li><li>可以随时动态删除一个元素，同样不会破坏有序性。</li><li>还很方便随时按键值查找到和我相等的元素。</li><li>如果还额外需要去重，则只需改用普通 map</li></ul><p>普通 map 轻松实现去重 + 动态排序，如何处置重复的键随你决定：</p><ul><li>普通 map 的 insert 只接受第一次出现的键-值对。</li><li>普通 map 的 insert_or_assign 只保留最后一次出现的键-值对。</li></ul><h3 id="查询某个键对应的多个值"><a href="#查询某个键对应的多个值" class="headerlink" title="查询某个键对应的多个值"></a>查询某个键对应的多个值</h3><p>因为 multimap 中，一个键不再对于单个值了；所以 multimap 没有 <code>[]</code> 和 <code>at</code> 了，也没有 <code>insert_or_assign</code>（反正 <code>insert</code> 永远不会发生键冲突！）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(Kt &amp;&amp;k)</span></span>;</span><br></pre></td></tr></table></figure><p>要查询 multimap 中的一个键对应了哪些值，可以用 <code>equal_range</code> 获取一前一后两个迭代器，他们形成一个区间。这个区间内所有的元素都是同样的键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; tab;</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;silly&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;smart&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;lazy&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;fast&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;pig&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> range = tab.<span class="built_in">equal_range</span>(<span class="string">&quot;cpp&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line">cpp smart</span><br><span class="line">cpp fast</span><br></pre></td></tr></table></figure><p><code>equal_range</code> 返回两个迭代器相等时（即区间大小为 0），就代表找不到该键值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> range = tab.<span class="built_in">equal_range</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (range.first == range.second) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到该元素！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equal_range</code> 返回的两个迭代器，也可以用 <code>lower_bound</code> 和 <code>upper_bound</code> 分别获得：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin_it = tab.<span class="built_in">lower_bound</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> end_it = tab.<span class="built_in">upper_bound</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (begin_it == end_it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到该元素！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin_it; it != end_it; ++it) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lower-upper-bound-实现范围查询"><a href="#lower-upper-bound-实现范围查询" class="headerlink" title="lower&#x2F;upper_bound 实现范围查询"></a>lower&#x2F;upper_bound 实现范围查询</h3><ul><li><code>lower_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于等于（&gt;&#x3D;）当前 key 的元素。</li><li><code>upper_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于（&gt;）当前 key 的元素。</li><li><code>begin()</code> 到 <code>lower_bound(key)</code> 迭代器之间的元素，都是小于（&lt;）当前 key 的元素。</li><li><code>begin()</code> 到 <code>upper_bound(key)</code> 迭代器之间的元素，都是小于等于（&lt;&#x3D;）当前 key 的元素。</li></ul><p>例如我要对一系列小彭友的成绩数据进行排序，要求查出大于等于 60 分的所有同学，发放“小红花”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Student&gt; students;</span><br></pre></td></tr></table></figure><p>就可以把成绩 int 作为键，学生名字作为值，插入 multimap。</p><p>插入的过程中 multimap 就自动为你动态排序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, string&gt; sorted;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;stu: students) &#123;</span><br><span class="line">    sorted.<span class="built_in">insert</span>(&#123;stu.score, stu.name&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，要找出所有大于等于 60 分的同学，也就是 <code>lower_bound(60)</code> 到 <code>end()</code> 这个区间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where score &gt;= 60</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = sorted.<span class="built_in">lower_bound</span>(<span class="number">60</span>); it != sorted.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜 &#123;&#125; 同学，考出了 &#123;&#125; 分，奖励你一朵小红花&quot;</span>, it-&gt;second, it-&gt;first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找出 30（含）到 60（不含）分的同学也很容易：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where 30 &lt;= score and score &lt; 60</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = sorted.<span class="built_in">upper_bound</span>(<span class="number">30</span>); it != sorted.<span class="built_in">lower_bound</span>(<span class="number">60</span>); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; 同学考出了 &#123;&#125; 分，不要灰心！小彭老师奖励你一朵小黄花，表示黄牌警告&quot;</span>, it-&gt;second, it-&gt;first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度总结说明"><a href="#时间复杂度总结说明" class="headerlink" title="时间复杂度总结说明"></a>时间复杂度总结说明</h2><table><thead><tr><th>函数或写法</th><th>解释说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>m1 &#x3D; move(m2)</td><td>移动</td><td>O(1)O(1)</td></tr><tr><td>m1 &#x3D; m2</td><td>拷贝</td><td>O(N)O(N)</td></tr><tr><td>swap(m1, m2)</td><td>交换</td><td>O(1)O(1)</td></tr><tr><td>m.clear()</td><td>清空</td><td>O(N)O(N)</td></tr></tbody></table><hr><table><thead><tr><th>函数或写法</th><th>解释说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>m.insert({key, val})</td><td>插入键值对</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.insert(pos, {key, val})</td><td>带提示的插入，如果位置提示准确</td><td>O(1)O(1)+</td></tr><tr><td>m.insert(pos, {key, val})</td><td>带提示的插入，如果位置提示不准确</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m[key] &#x3D; val</td><td>插入或覆盖</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.insert_or_assign(key, val)</td><td>插入或覆盖</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.insert({vals…})</td><td>设 M 为待插入元素（vals）的数量</td><td>O(MlogN)O(Mlog⁡N)</td></tr><tr><td>map m &#x3D;</td><td>如果 vals 无序</td><td>O(NlogN)O(Nlog⁡N)</td></tr><tr><td>map m &#x3D;</td><td>如果 vals 已事先从小到大排列</td><td>O(N)O(N)</td></tr></tbody></table><hr><table><thead><tr><th>函数或写法</th><th>解释说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>m.at(key)</td><td>根据指定的键，查找元素，返回值的引用</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.find(key)</td><td>根据指定的键，查找元素，返回迭代器</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.count(key)</td><td>判断是否存在指定键元素，返回相同键的元素数量（只能为 0 或 1）</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.equal_range(key)</td><td>根据指定的键，确定上下界，返回区间</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.size()</td><td>map 中所有元素的数量</td><td>O(1)O(1)</td></tr><tr><td>m.erase(key)</td><td>根据指定的键，删除元素</td><td>O(logN)O(log⁡N)</td></tr><tr><td>m.erase(it)</td><td>根据找到的迭代器，删除元素</td><td>O(1)+O(1)+</td></tr><tr><td>m.erase(beg, end)</td><td>批量删除区间内的元素，设该区间（beg 和 end 之间）有 M 个元素</td><td>O(M+logN)O(M+log⁡N)</td></tr><tr><td>erase_if(m, cond)</td><td>批量删除所有符合条件的元素</td><td>O(N)O(N)</td></tr></tbody></table><hr><table><thead><tr><th>函数或写法</th><th>解释说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>m.insert(node)</td><td></td><td>O(logN)O(log⁡N)</td></tr><tr><td>node &#x3D; m.extract(it)</td><td></td><td>O(1)+O(1)+</td></tr><tr><td>node &#x3D; m.extract(key)</td><td></td><td>O(logN)O(log⁡N)</td></tr><tr><td>m1.merge(m2)</td><td>合并两个 map，清空 m2，结果写入 m1</td><td>O(NlogN)O(Nlog⁡N)</td></tr><tr><td>m1.insert(m2.begin(), m2.end())</td><td>合并两个 map，m2 保持不变，结果写入 m1</td><td>O(NlogN)O(Nlog⁡N)</td></tr></tbody></table><h2 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 unordered_map"></a>哈希表 unordered_map</h2><p>C++11 新增：基于哈希 (hash) 的映射表 unordered_map</p><h3 id="unordered-map-与-map-之争：适用场景不同"><a href="#unordered-map-与-map-之争：适用场景不同" class="headerlink" title="unordered_map 与 map 之争：适用场景不同"></a>unordered_map 与 map 之争：适用场景不同</h3><p>之前提到，map 底层基于红黑树，大多数操作的复杂度都是 O(logN)O(log⁡N) 级别的，其中部分按迭代器的插入和删除的复杂度可以降低到 O(1)O(1)。</p><img src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/hash_map.png" class="" title="hash_map"><p>而 unordered_map 则是基于哈希表的更高效查找，只需 O(1)O(1) 复杂度！他能实现如此高效查找得益于哈希函数可以把散列唯一定位到一个数组的下标中去，而数组的索引是 O(1)O(1) 的。缺点是哈希值可能产生冲突，而且哈希数组可能有空位没有填满，浪费一部分内存空间。总的来说哈希表在平均复杂度上（O(1)O(1)）比红黑树这类基于树的复杂度（O(logN)O(log⁡N)）更低，虽然固有延迟高，占用空间大，还容易被哈希冲突攻击。</p><ul><li>哈希表结构简单无脑，在巨量的键值对的存储时会发挥出明显的性能优势，常用于需要高吞吐量但不太在乎延迟的图形学应用。</li><li>而各种基于树的数据结构，复杂度更加稳定，看似适合小规模数据，但是因为保持有序的特性，非常适合数据库这种需要范围查询的情况，且有序性反而有利于缓存局域性，无序的哈希表难以胜任。</li><li>最近新提出的一种数据结构——跳表，也是有序的，但基于链表，更加高效，在 Redis 等软件中都有应用。别担心，小彭老师之后的数据结构课程会专门介绍并带你手搓所有这些！</li></ul><hr><h3 id="原理：unordered-map-中的“桶”"><a href="#原理：unordered-map-中的“桶”" class="headerlink" title="原理：unordered_map 中的“桶”"></a>原理：unordered_map 中的“桶”</h3><p>unordered_map 如何快速检索数据？高效的秘诀在于 unordered_map 内部是一个数组，一个由许多“桶”组成的数组。插入时把键值对存到键的 hash 对应编号的桶去，查询时就根据 hash 去线性地查找桶（这一操作是 O(1)O(1) 的）。</p><p>例如键为 “hello”，假设算出他的 hash 为 42。而当前桶的数量是 32 个，则会把 “hello” 存到 42 % 32 &#x3D; 10 号桶去。查询时，同样计算出 hash(“hello”) % 32 &#x3D; 10 号桶，然后就可以从 10 号桶取出 “hello” 对应的数据了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    array&lt;pair&lt;K, V&gt;, 32&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();  <span class="comment">// 计算出来的 hash 可能很大，取模可以防止 h &gt;= buckets.size()</span></span><br><span class="line">        buckets[h] = kv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">V &amp;<span class="title">at</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(k) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;kv = buckets[h];</span><br><span class="line">        <span class="keyword">if</span> (k != kv.first) <span class="keyword">throw</span> out_of_range&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希冲突-hash-collision"><a href="#哈希冲突-hash-collision" class="headerlink" title="哈希冲突 (hash-collision)"></a>哈希冲突 (hash-collision)</h3><p>但是这里有一个问题，如果两个不同的字符串，刚好 hash 以后的模相同怎么办？这种现象称为 hash 冲突。</p><p>C++ 标准库的解决方案是采用链表法：一个桶不是单独的一个 K-V 对，而是数个 K-V 对组成的单链表（forward_list）。一个桶不是只存储一个数据，而是可以存储任意多个数据（0到∞个）。</p><p>插入时，找到对应的桶，并往链表的头部插入一个新的 K-V 对。查找时，先找到对应的桶，在这个桶里的链表里顺序遍历查找，由于第一步的桶查找是 O(1)O(1) 的，虽然最后还是链表暴力查找，但是已经被桶分摊了一个维度，因此查找的平均复杂度还是 O(1)+O(1)+ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();  <span class="comment">// 计算 hash 的模（所在桶的编号）</span></span><br><span class="line">    buckets[h].<span class="built_in">push_front</span>(kv);                <span class="comment">// 单链表的头插，是最高效的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">hash</span>(k) % buckets.<span class="built_in">size</span>();         <span class="comment">// 计算 hash 的模（所在桶的编号）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv: buckets[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == kv.first)  <span class="comment">// 可能有多个不同的键刚好有相同的 hash 模，需要进一步判断键确实相等才能返回</span></span><br><span class="line">            <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> out_of_range&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里还是有一个问题，hash 冲突时，对链表的暴力遍历查找复杂度是 O(N)O(N) 的，随着越来越多的元素被插入进来，32 个桶将会拥挤不堪。假设有 n 个元素，则平均每个桶都会有 n &#x2F; 32 个元素，需要 n &#x2F; 32 次遍历。所以元素数量充分大时 unordered_map 又会退化成暴力遍历的 O(N)O(N) 复杂度，满足不了我们用他加速查找的目的。</p><p>桶的数量相比元素的数量越是不足，越是拥挤，越是容易退化成链表。</p><p>因此 C++ 标准库规定，插入时，当检测到平均每个桶里都有 1 个元素时，也就是元素数量大于桶的数量时，就会发生自动扩容，一次性让桶的数量扩充 2 倍，并重新计算每个元素的 hash 模（桶编号）全部重新插入一遍。</p><blockquote><p>元素数量除以桶的数量被称为“负载率（load factor），对于链表法的哈希表 unordered_map 来说，负载率可以高于 1；对于线性地址法的 flat_hash_map 则最高为 1。C++ 标准库通常的 unordered_map 实现中，负载率高于 1 时，就会发生自动扩容。可以通过 <code>.load_factor()</code> 函数查询一个 unordered_map 的负载率。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;  <span class="comment">// 因为需要动态扩容，桶数组变成了动态数组 vector</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;  <span class="comment">// 记录当前容器共有多少个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> &gt; buckets.<span class="built_in">size</span>()) <span class="built_in">reserve</span>(n);  <span class="comment">// 如果插入后的元素数量大于桶的容量，则扩容</span></span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        buckets[h].<span class="built_in">push_front</span>(kv);</span><br><span class="line">        size++;     <span class="comment">// insert 时 size 自动加 1，erase 时也要记得减 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= buckets.<span class="built_in">size</span>()) <span class="keyword">return</span>;  <span class="comment">// 如果要求的大小已经满足，不需要扩容</span></span><br><span class="line">        buckets.<span class="built_in">resize</span>(<span class="built_in">max</span>(n, buckets.<span class="built_in">size</span>() * <span class="number">2</span>));  <span class="comment">// 把桶数组至少扩大 2 倍（避免重复扩容），至多扩到 n</span></span><br><span class="line">        此处省略 rehash 的具体实现  <span class="comment">// 桶的数量发生变化了，需要重新计算一遍所有元素 hash 的模，并重新插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>每个 key 所在的桶编号计算公式：bucket_index(key) &#x3D; hash(key) % bucket_count()</p></blockquote><p>还是存在问题，刚刚的 insert 根本没有检测要插入的键是否已经存在了。如果已经存在还插入，那就变成 unordered_multimap 了！我们是普通的需要去重的 unordered_map，所以插入时先需要遍历下链表检测一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(pair&lt;K, V&gt; &amp;kv)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> &gt; buckets.<span class="built_in">size</span>()) <span class="built_in">reserve</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv2: buckets[h]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kv.first == kv2.first)  <span class="comment">// 检测是否发生了冲突</span></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(kv2), <span class="literal">false</span>&#125;;  <span class="comment">// 发生冲突则返回指向已存在的键的迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">        buckets[h].<span class="built_in">push_front</span>(kv);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(buckets.<span class="built_in">front</span>()), <span class="literal">true</span>&#125;;  <span class="comment">// 没发生冲突则返回成功插入元素的迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="unordered-map-与-map-的异同"><a href="#unordered-map-与-map-的异同" class="headerlink" title="unordered_map 与 map 的异同"></a>unordered_map 与 map 的异同</h2><p>用法上，unordered_map 基本与 map 相同，以下着重介绍他们的不同点。</p><h3 id="区别-1：有序性"><a href="#区别-1：有序性" class="headerlink" title="区别 1：有序性"></a>区别 1：有序性</h3><ul><li>map 基于红黑树，元素从小到大顺序排列，遍历时也是从小到大的，键类型需要支持比大小（std::less 或 &lt;）。</li><li>unordered_map 基于哈希散列表，里面元素顺序随机，键类型需要支持哈希值计算（std::hash）和判断相等（std::equal_to 或 &#x3D;&#x3D;）。</li></ul><p>map 中的元素始终保持有序，unordered_map 里面的元素是随机的。</p><p>这也意味着 std::set_union 这类要求输入区间有序的 algorithm 函数无法适用于 unordered_map&#x2F;set。</p><h4 id="hash-和-equal-to"><a href="#hash-和-equal-to" class="headerlink" title="hash 和 equal_to"></a>hash 和 equal_to</h4><p>map 只需要 K 类型支持一个 less 就能工作。</p><p>而 unordered_map 需要 K 支持的 trait 有两个：hash 和 equal_to。</p><p><code>unordered_map&lt;K, V&gt;</code> 的完整形态是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;K, V, hash&lt;K&gt;, equal_to&lt;K&gt;, allocator&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>其中 allocator 我们照例先跳过不讲，之后分配器专题课中会介绍。</li><li>hash 说的是，如何求键的哈希值？hash 仿函数接受一个 K 类型的键，返回一个 size_t（在 64 位系统上是个无符号 64 位整数，表示哈希值）。</li><li>equal_to 说的是，如何判断两个键相等？如果两个键完全相等，他会返回 true。</li></ul><p>这里对 hash 的实现只有一个要求，<strong>如果两个键相等，则他们的哈希必定也相等，反之则不一定</strong>。</p><p>这个假设构成了 unordered_map 得以高效的基石，他使得 unordered_map 可以更快排除不可能的答案，而不必像 vector 的查找那样需要去暴力遍历全部元素，只需要遍历哈希相等的那一部分元素就够了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp,</span><br><span class="line">   <span class="keyword">typename</span> _Hash = hash&lt;_Key&gt;,      <span class="comment">// 默认的哈希函数实现，支持了 int, void *, string 等类型</span></span><br><span class="line">   <span class="keyword">typename</span> _Pred = equal_to&lt;_Key&gt;,  <span class="comment">// 默认的 == 运算符</span></span><br><span class="line">   <span class="keyword">typename</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> _Key, _Tp&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map</span><br></pre></td></tr></table></figure><p>换言之，只要 unordered_map 发现两个键不相等，就不用再做具体值的比较了，他们不可能相等了！</p><h4 id="哈希函数的思想"><a href="#哈希函数的思想" class="headerlink" title="哈希函数的思想"></a>哈希函数的思想</h4><p>hash 返回的 size_t 这个整数可以理解为一个对任意类型的“摘要”。</p><p>把一个很复杂的类型（例如 string）压缩成一个 unordered_map 很轻易就能比较的 size_t 整数，整数比较起来就很容易，而且还能直接作为数组的下标（string 不能直接作为数组的下标）。</p><p>这种摘要的关键在于如何把一个极为复杂的类型“映射”到小小的 size_t 上去，并且分布得尽可能均匀，不要冲突。</p><p>这就需要我们把这个极为复杂类型的每个成员（对 string 而言就是每个字符）都加到最终结果的表达式中。</p><p>以字符串类型 string 为例，常见的一种生成“摘要”的方法是，用一个任意素数的乘方序列和各字符的 ASCII 码做点积：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash_string</span><span class="params">(string <span class="type">const</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">        h = h * <span class="number">37</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如对于字符串 “hello”，则 hash 可以生成这样一个摘要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> h = (((<span class="string">&#x27;h&#x27;</span> * <span class="number">37</span> + <span class="string">&#x27;e&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;o&#x27;</span>;</span><br></pre></td></tr></table></figure><p>相当于 h⋅374+e⋅373+l⋅372+l⋅37+oh⋅374+e⋅373+l⋅372+l⋅37+o</p><blockquote><p>也有其他更高效的生成摘要的方法，例如借助位运算。</p><p>甚至还有偷懒直接拿 strlen 当哈希函数的“世界上最好的哈希表”，我不说是谁。（其实是早期 PHP 啦）</p></blockquote><h4 id="自动取模"><a href="#自动取模" class="headerlink" title="自动取模"></a>自动取模</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> h = (((<span class="string">&#x27;h&#x27;</span> * <span class="number">37</span> + <span class="string">&#x27;e&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;o&#x27;</span>;</span><br></pre></td></tr></table></figure><p>随着字符串长度的增加，这个 h 肯定会超过 size_t 的表示范围，但是没关系，无符号整数的乘法、加法溢出不是未定义行为，他会自动 wrapping（取关于 264264 的模），也就是只保留乘法结果和 2^64 取模的部分。</p><p>取模也是对哈希值常见的一个操作，反正哈希值是随机的，取模以后也是随机的，但是缩小了范围。</p><blockquote><p>基本假设：m 足够小时，一个均匀的分布取以 m 的模以后仍然应该是均匀的</p></blockquote><p>unordered_map 中桶的数量是有限的，为了把范围从 00 到 264−1264−1 的哈希值映射为 0 到 bucket_count - 1 的桶序号，他内部会把键的哈希值取以桶数量的模，作为一个键要存储到的桶的序号：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bucket_index</span> = hash(key) % bucket_count</span><br></pre></td></tr></table></figure><h3 id="hash-是个-trait-类"><a href="#hash-是个-trait-类" class="headerlink" title="hash 是个 trait 类"></a>hash 是个 trait 类</h3><p>std::hash 就是标准库用于计算哈希的仿函数类了，他和 std::less 一样，是一个 trait 类。</p><p>一些常见的类型有默认的实现，也可以针对自定义类型添加特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;t)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 有待实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;  <span class="comment">// 对 int 的特化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;T *&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(t);  <span class="comment">// 对 T * 的偏特化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>std::hash 针对每个不同的类型做了特化，例如当我们需要计算 string 类型的 hash 时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> h = <span class="built_in">hash</span>&lt;string&gt;()(str);</span><br><span class="line"><span class="built_in">print</span>(str, <span class="string">&quot;的哈希是&quot;</span>, h);</span><br></pre></td></tr></table></figure><p>注意：这里有两个括号，第一个是空的。第一个括号创建仿函数对象，第二个用str作为实参调用仿函数的 <code>operator()</code>。当然还别忘了第一个尖括号，这个尖括号里的 string 表示的是 hash 仿函数接下来要接受参数的类型，之所以作为类的模板参数而不是模板函数，是为了方便特化和偏特化。同学们也可以自己写一个这样的函数，用起来就不用指定类型（如这里的 string）了，让模板函数自动推导参数类型（类似于 make_pair）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">do_hash</span><span class="params">(T <span class="type">const</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;T&gt;()(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">do_hash</span>(str);</span><br><span class="line">    <span class="built_in">print</span>(str, <span class="string">&quot;的哈希是&quot;</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;Hello, world&quot;</span> 的哈希是 <span class="number">14701251851404232991</span></span><br></pre></td></tr></table></figure><hr><p>对任意类型哈希的结果都是一个 size_t，其在 32 位系统上等同于 uint32_t，在我们 64 为系统上等同于 uint64_t。选择 size_t 是为了能哈希了以后直接用于 unordered_map 中桶的索引。</p><p>由于 hash 是用作哈希表的哈希函数，而不是用于加密领域（请你移步 md5），或是用于随机数生成（请移步 mt19937），因此对于任意类型，只需要根据他生成一个 size_t 的哈希值即可，只要保证哈希值分布均匀即可，不一定要有随机性。例如标准库对 int 的 hash 实现就是个恒等函数——直接返回其整数值，不用做任何计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;  <span class="comment">// 对 int 的特化真是什么也不做呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而对于任意指针的实现则是直接把指针 bit-cast 成 size_t：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;T *&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(t);  <span class="comment">// 指针强制转换为整数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(i);  <span class="comment">// 没想到罢！我系恒等函数哒</span></span><br><span class="line"><span class="built_in">print</span>(i, j);</span><br><span class="line"><span class="number">42</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><p>记住，std::hash 不是为了加密或随机而生的，他的功能仅仅是尽可能快速地把任意类型 T 映射到 size_t 而已。</p><p>至于这对 unordered_map 的性能有何影响？通常没有什么影响，除非输入键故意设为和 bucket_count 同模，毕竟反正你也无法断定输入键的排布模式，不论选什么哈希函数只要保证均匀都是可以的。而恒等函数刚好是均匀的，又不用额外的花里胡哨位运算浪费时间，反而可能因为键有序而提升了缓存局域性，提升了性能，所以各大厂商的标准库都是这么做的。</p><h3 id="区别-2：时间复杂度"><a href="#区别-2：时间复杂度" class="headerlink" title="区别 2：时间复杂度"></a>区别 2：时间复杂度</h3><ul><li>map 的查询和插入操作是 O(logN)O(log⁡N) 复杂度的。</li><li>unordered_map 的查询和插入操作是 O(1)+O(1)+ 复杂度的。</li></ul><p>看起来 unordered_map 更高效？那还要 map 干什么？完全上位替代啊？</p><p>但是我们要注意，上面所说的复杂度 O(1)O(1) 只是平均下来的，并不代表每一次 unordered_map 插入操作的复杂度都是 O(1)O(1)！所以，复杂度表示法里的这个 + 号就是这个意思，代表我这个复杂度只是多次运行取平均，如果只考虑单次最坏的情况，可能更高。</p><ul><li>map 的插入操作<strong>最坏</strong>也只是 O(logN)O(log⁡N) 复杂度的。</li><li>unordered_map 的插入操作<strong>最坏</strong>可以是 O(N)O(N) 复杂度的。</li></ul><p>处理很高的数据量时，这一点最坏的情况会被平摊掉，unordered_map 更高效。</p><h4 id="哈希表的复杂度不稳定"><a href="#哈希表的复杂度不稳定" class="headerlink" title="哈希表的复杂度不稳定"></a>哈希表的复杂度不稳定</h4><p>所以 unordered_map 不稳定，虽然平均是 O(1)O(1) 复杂度，但最坏可达到 O(N)O(N) 复杂度。背后的原因是什么呢？</p><p>原来 unordered_map 和 vector 一样，是一个需要不断动态扩容的容器。</p><p>如果不扩容，那么当很多元素挤在一个桶里，链表的压力就会变大，会很低效，因此 unordered_map 必须扩容。但是在扩容的时候是需要进行 rehash 操作的。一次扩容，就需要把所有的元素都移动一遍。</p><p>结果就是 unordered_map 的插入如果没触发 rehash，那就是 O(1)O(1) 的。触发了，那就是最坏的情况，O(N)O(N) 的。但是不触发的情况远多于触发了的，所以平均下来还是 O(1)O(1)，为了提醒人们他最坏的情况，所以写作 O(1)+O(1)+，读作“平摊 O1”（Amortized Constant）。</p><p>此外，不仅 unordered_map 的插入函数是 O(1)+O(1)+，他的查询函数也是 O(1)+O(1)+。为什么呢？设想你在编写一个富连网服务器，如果黑客已知你的 hash 函数，那他就可以通过构造一系列特殊设计好的 key，他们的哈希刚好相等（或同模），这样就使得所有 key 刚好全部落在一个桶里，导致 unordered_map 退化成线性的链表，所有的查询和插入都变成了这一个桶上的链表遍历操作，复杂度达到最坏的 O(N)O(N)，这一现象叫做 hash 退化。</p><p>因此 hash 函数的好坏决定着 unordered_map 性能，对于安全领域来说，还要保证 hash 函数无法被黑客破解。只要 hash 函数足够随机，就能保证键不冲突，就很快，一旦出现键冲突就会变慢。但需要频繁使用的 hash 函数计算难度又不能太大，那又会影响性能，因此 hash 也不能太过复杂。</p><blockquote><p>标准库里存在这种“平摊复杂度”的例子还有很多，例如 vector 的 push_back 不 reserve 的话，就是 O(1)+O(1)+ 的，因为他需要动态扩容。</p></blockquote><h4 id="哈希表的应用限制"><a href="#哈希表的应用限制" class="headerlink" title="哈希表的应用限制"></a>哈希表的应用限制</h4><p>一些实时性要求很高的领域就不能用 unordered_map。例如你造了个火箭，规定：火箭控制程序需要在 1000 μs 内对外界变化做出实时反应，如果不能及时做出反应，火箭就会做托马斯回旋给你看。</p><p>你在火箭控制程序中用了 unordered_map，这个程序会不断运行，以便控制火箭做出正确的机动，对抗侧向风干扰。第一次运行他在 180 μs 内反应了，第二次在 250 μs 内反应了，第三次 245 μs 内反应了，你觉得他很高效。</p><p>但是突然有一次，unordered_map 觉得他内部“桶太乱”了，急需重新扩容并 rehash 一下“忧化性能”。然后，他把所有的元素都移动了一遍，移动完了，把处理完的数据返回给火箭姿态调控系统，认为大功告成。但当他睁开眼睛一看，刚想要控制一下姿态呢？却发现自己已经在做托马斯回旋了！原来我这一“忧化”就忧了 4000 μs，超出了火箭实时响应的硬性指标，导致西装骰子人卷款跑路，小彭老师破产。</p><p>小彭老师重新创业，这次他选用了稳定的 map，第一次他在 810 μs 内反应了，第二次在 680 μs 内反应了，第三次 730 μs 内反应了，你觉得他很低效。但是他每一次都能成功卡点给你完成任务，从来不会突然超过 O(logN)O(log⁡N)，他的最坏情况是可控的，从而避免了托马斯破产回旋。小彭老师最终创业成功，1000 年后，我司成功建造完成 Type-II 文明所急需的戴森球，向星辰大海进军。</p><p>对实时性要求高的这类领域包括，音视频，造火箭，量化交易等。这类低延迟低吞吐量的领域对平摊复杂度很反感，他们只看重最坏的复杂度，而不是平均的。</p><p>但对于主打一个高吞吐量无所谓延迟的离线图形学，离线科学计算，实时性不重要的生态化反场景，我们可以认为 unordered_map 的平摊 O(1)+O(1)+ 就是比 map 高效的。</p><hr><h3 id="区别-3：迭代器失效条件"><a href="#区别-3：迭代器失效条件" class="headerlink" title="区别 3：迭代器失效条件"></a>区别 3：迭代器失效条件</h3><ul><li>map 和 unordered_map 都是只有当删除的刚好是迭代器指向的那个元素时才会失效，这点相同。</li><li>但 unordered_map 扩容时候的 rehash 操作会造成所有迭代器失效。</li></ul><blockquote><p>insert 可能导致 unordered_map 扩容，其他只读操作不会。</p></blockquote><p>迭代器指向的那个元素被删除时，不论 map 和 unordered_map 都会失效。</p><p>unordered_map 在 insert 时如果发生扩容，之前保存的迭代器可能失效，可以通过调用 reserve 避免 insert 时扩容。</p><p>小彭老师编写好了迭代器失效表，方便你记忆:</p><table><thead><tr><th>容器</th><th>clear</th><th>swap</th><th>opeartor&#x3D;</th><th>rehash</th></tr></thead><tbody><tr><td>vector</td><td>是</td><td>否</td><td>是</td><td>-</td></tr><tr><td>map</td><td>是</td><td>否</td><td>是</td><td>-</td></tr><tr><td>unordered_map</td><td>是</td><td>否</td><td>是</td><td>-</td></tr></tbody></table><table><thead><tr><th>容器</th><th>find</th><th>count</th><th>at</th><th>[]</th></tr></thead><tbody><tr><td>vector</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>map</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>unordered_map</td><td>否</td><td>否</td><td>否</td><td>是，如果创建了新元素且 size &#x2F; bucket_count &gt; max_load_factor</td></tr></tbody></table><p>小彭老师编写好了迭代器失效表，方便你记忆:</p><table><thead><tr><th>容器</th><th>push_back</th><th>insert</th><th>erase</th><th>reserve</th></tr></thead><tbody><tr><td>vector</td><td>是，如果 size &gt; capacity</td><td>是，如果插入位置在当前迭代器之前，或 size &gt; capacity</td><td>是，如果删除的元素在当前迭代器之前，或刚好是当前迭代器指向的</td><td>是</td></tr><tr><td>map</td><td>-</td><td>否</td><td>是，如果删除的刚好是当前迭代器指向的元素</td><td>-</td></tr><tr><td>unordered_map</td><td>-</td><td>是，如果 size &#x2F; bucket_count &gt; max_load_factor</td><td>是，如果删除的刚好是当前迭代器指向的元素</td><td>是</td></tr></tbody></table><p>也可以查看官方版《迭代器失效表》：<a href="https://en.cppreference.com/w/cpp/container#Iterator_invalidation">https://en.cppreference.com/w/cpp/container#Iterator_invalidation</a></p><h3 id="负载率（load-factor）"><a href="#负载率（load-factor）" class="headerlink" title="负载率（load_factor）"></a>负载率（load_factor）</h3><p>计算公式：负载因子(load_factor) &#x3D; 当前元素数量(size) ÷ 当前桶的数量(bucket_count)</p><p>插入新元素后，当检测到负载因子大于最大负载因子（默认 1.0）时，就会自动进行 rehash 操作。</p><p>为了避免重复小规模扩容浪费时间，这次 rehash 会一次性扩容两倍（跟 vector 的 push_back 扩容类似）。</p><blockquote><p>最大负载因子可以通过 max_load_factor 函数调整。当前负载因子可以通过 load_factor 函数查询。</p></blockquote><p>直观理解：当每个桶平均都有一个元素时，unordered_map 就会认为已经很满了，就会扩容并重新分配位置。</p><blockquote><p>由于默认最大负载因子是 1.0，所以扩容条件等价于 size &gt; bucket_count</p></blockquote><hr><h3 id="rehash-函数"><a href="#rehash-函数" class="headerlink" title="rehash 函数"></a>rehash 函数</h3><p>在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。<a href="https://142857.red/book/stl_map/#fn:1">1</a></p><blockquote><p>除了扩容时自动的 rehash，确认数据插入完毕不会再改动时，我们也可以手动调用 rehash() 函数来优化容器中元素的排布，提升性能。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    umap.<span class="built_in">emplace</span>(i, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> pair = umap.<span class="built_in">equal_range</span>(<span class="number">49</span>);  <span class="comment">//获取键为 49 的键值对所在的区间，由于不是 multimap，区间大小只能为 0 或 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123; <span class="comment">//输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">umap.<span class="built_in">rehash</span>(<span class="number">10</span>); <span class="comment">//手动调用 rehash() 函数重哈希为 10 个桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123; <span class="comment">// 重哈希之后，之前保存的迭代器可能会发生变化</span></span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">49</span> </span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><h3 id="hash-需要特化"><a href="#hash-需要特化" class="headerlink" title="hash 需要特化"></a>hash 需要特化</h3><p>基于红黑树的映射表 map 只需支持比较运算的 less 即可，而 unordered_map 需要哈希和相等两个 trait，他们分别名叫 std::hash 和 std::equal_to。</p><p>虽然两者都是仿函数，但也有很多区别：</p><ol><li>hash 只接受一个参数，而 equal_to 接受两个参数。</li><li>hash 返回 size_t，而 equal_to 返回 bool 类型。</li><li>equal_to 有默认的实现，那就是调用运算符 &#x3D;&#x3D;。而 hash 没有默认实现，也没相应的运算符，只能手动特化。</li></ol><p>正因为如此，通常我们需要让一个类（例如 Student）支持 equal_to 或 less 这些有相应运算符的仿函数时，直接在类型内部定义 <code>operator==</code> 或 <code>operator&lt;</code> 即可，而 hash 则是只能用特化的方法才能支持上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;t)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 有待实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;x, T <span class="type">const</span> &amp;y)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有些类型能用作 map 的键，但不能用作 unordered_map 的键。这是因为偷懒的标准库没对他们的 hash 特化！</p><p>例如 tuple 支持 &lt; 运算符，支持 less。</p><p>但是 tuple 没有 hash 的特化，不支持 hash。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tup;</span><br><span class="line"><span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(tup);  <span class="comment">// 编译期报错：查无此函数！</span></span><br><span class="line">unordered_map&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="给-tuple-等复合类型自定义哈希函数"><a href="#给-tuple-等复合类型自定义哈希函数" class="headerlink" title="给 tuple 等复合类型自定义哈希函数"></a>给 tuple 等复合类型自定义哈希函数</h3><p>和 less 的情形一样，也是有三种解决方案：</p><ol><li>自定义一个 hash 的特化，equal_to 的特化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(x.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::equal_to&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><ol><li>自定义一个 hash 的仿函数类，一个 equal_to 的仿函数类，然后传入 unordered_map 做模板参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(x.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EqualStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Student, <span class="type">int</span>, HashStudent, EqualStudent&gt; stutab;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果 Student 已经定义了 <code>operator==</code>，则这里不用 EqualStudent，默认的 equal_to 会自动调用 &#x3D;&#x3D; 运算符的。</p></blockquote><ol><li>对于 tuple 而言，tuple 已经有了 &#x3D;&#x3D; 运算符，不用特化 equal_to 了，只需要特化或指定 hash 即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) ^ ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><h4 id="试试看效果吧！"><a href="#试试看效果吧！" class="headerlink" title="试试看效果吧！"></a>试试看效果吧！</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) ^ ...); <span class="comment">// 把任意多个元素哈希通过“位异或(^)”拼凑成一个单独的哈希</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// std::apply 会把 tuple 里的元素全部展开来调用 hash_combine，相当于 Python 里的 *args</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">64</span>)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(t);</span><br><span class="line">    <span class="built_in">print</span>(t, <span class="string">&quot;的哈希值是:&quot;</span>, h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">42</span>, <span class="number">64</span>&#125; 的哈希值是: <span class="number">106</span></span><br></pre></td></tr></table></figure><p>这里的计算是：42 ^ 64 &#x3D; 106，位异或的知识可以去 Bing 搜索一下，或者问一下 GPT，CS 学生应该都知道的。</p><h3 id="更好的-hash-combine"><a href="#更好的-hash-combine" class="headerlink" title="更好的 hash_combine"></a>更好的 hash_combine</h3><p>但是简简单单用一个位异或 ^ 来把两个成员的哈希组合起来，有个严重的问题，如果 <code>tuple&lt;int, int&gt;</code> 里的两个成员值刚好一样，则其两个哈希值也会一样，那么他们通过位异或 ^ 合并的结果就会始终为 0。</p><p>例如不论 (42, 42) 还是 (64, 64) 这两个 tuple，他们的哈希值都会为 0。明明具体值不同哈希值却相同，这就是发生了哈希冲突，这会严重影响 unordered_map 的性能，是必须避免的。</p><p>用 + 来组合也有这个问题，如果第一个成员刚好是另一个的相反数，或只要是两个数加起来和相等，就会冲突。</p><p>例如如果我们用 unordered_map 构建一张地图的话，就发现当玩家在往斜上方移动时就会变得特别卡顿，原来是因为玩家的历史轨迹刚好是一条 y &#x3D; x 的曲线，斜率为 1，由于我们采用 ^ 来组合哈希，就导致刚好这条线上所有的点都会塌缩到 0 号桶去，让 unordered_map 退化成了 O(N)O(N) 复杂度。</p><h4 id="最先进的是-boost-hash-combine-的方法"><a href="#最先进的是-boost-hash-combine-的方法" class="headerlink" title="最先进的是 boost::hash_combine 的方法"></a>最先进的是 boost::hash_combine 的方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">    ((h ^= std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) + <span class="number">0x9e3779b9</span> + (h &lt;&lt; <span class="number">6</span>) + (h &gt;&gt; <span class="number">2</span>)), ...);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">64</span>)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(t);</span><br><span class="line">    <span class="built_in">print</span>(t, <span class="string">&quot;的哈希值是:&quot;</span>, h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">42</span>, <span class="number">64</span>&#125; 的哈希值是: <span class="number">175247763666</span></span><br></pre></td></tr></table></figure><p>可以看到随机性大大提升了。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>用 hash_combine 改进刚刚 Student 的哈希函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash_combine</span>(<span class="built_in">hash</span>&lt;string&gt;()(x.name), <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id), <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理可得 array 的特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h ^= <span class="built_in">hasher</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><p>采用素数乘方法来提升哈希函数的均匀性和随机性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h = h * <span class="number">18412483</span> + <span class="built_in">hasher</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure><p>采用最高级的，基于位运算的，最高效的，boost::hash_combine 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h ^= <span class="built_in">hasher</span>(t) + <span class="number">0x9e3779b9</span> + (h &lt;&lt; <span class="number">6</span>) + (h &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2快速搭建CUDA体验环境</title>
      <link href="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Windows11或Windows 10 21H2版本以上操作系统，具有 Nvidia 的 GPU，且已安装显卡驱动</li><li>安装了WSL2，且准备好了Ubuntu或其他Linux操作系统</li></ul><p>之后的操作都将基于WSL2中的Ubuntu环境。</p><h2 id="环境验证"><a href="#环境验证" class="headerlink" title="环境验证"></a>环境验证</h2><p>打开Windows的Powershell，输入<code>nvidia-smi</code>检查自己的显卡驱动、CUDA支持。</p><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_22-24-57.png" class="" title="Clip_2024-10-29_22-24-57"><p>注意左上角的 <strong>CUDA version 12.6</strong> 指的是当前环境所支持的CUDA的最高版本。如图，我当前的环境最高支持到12.6</p><ul><li>目前我只用这个环境学习、测试CUDA编程，因此可以直接选择CUDA最新版本12.6</li><li>如果还需要使用Pytorch、TensorRT等深度学习相关内容，请先确认这些环境的需求。</li><li>原因是，CUDA一般更新后，Pytorch、TensorRT过一段时间才会跟进更新。防止出现装好CUDA后，发现Pytorch没有对应版本的尴尬。</li></ul><p>之后进入WSL2的Linux环境，再次输入<code>nvidia-smi</code>验证WSL2能否正常连接 GPU</p><ul><li>Windows 11 和 Windows 10 版本 21H2 已经支持在 WSL2 实例内直通 NVIDIA CUDA </li><li>为减少麻烦，就不再照顾使用旧系统版本的同学</li></ul><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_22-39-39.png" class="" title="Clip_2024-10-29_22-39-39"><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><ul><li><a href="https://developer.nvidia.com/cuda-downloads">CUDA Toolkit最新版本链接</a></li><li><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit历史版本链接</a></li></ul><p>确定好需要的版本，打开上面的链接，进入相应的下载页面</p><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_22-48-40.png" class="" title="Clip_2024-10-29_22-48-40"><ul><li>在WSL2环境中安装的应该是Linux版本</li><li>选择自己的处理器架构，在Windows终端输出**<code>systeminfo</code>**可以很快查看。</li><li>之后选择自己的操作系统发布版本，注意！！！WSL中的Ubuntu是特殊发布WSL-Ubuntu</li><li>最后的 Installer Type，local会将安装包下载到本地再执行安装；network命令稍简单但容易收到网络影响；runfile应该是一个执行脚本，直接自动化全部过程（我没有尝试过）。</li><li>建议使用local版本，受网络状况影响小，甚至可以在宿主机Windows端下载好文件拷贝到虚拟机中安装</li></ul><p>下面是 CUDA 12.6 local版本安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin</span><br><span class="line">sudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.6.2/local_installers/cuda-repo-wsl-ubuntu-12-6-local_12.6.2-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-wsl-ubuntu-12-6-local_12.6.2-1_amd64.deb</span><br><span class="line">sudo cp /var/cuda-repo-wsl-ubuntu-12-6-local/cuda-*-keyring.gpg /usr/share/keyrings/</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda-toolkit-12-6</span><br></pre></td></tr></table></figure><p>请依次执行</p><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>成功执行上面的命令后，在虚拟机终端运行<code>nvcc --version</code>验证是否安装成功</p><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_23-12-13.png" class="" title="Clip_2024-10-29_23-12-13"><p>如果显示找不到nvcc命令，则可能是环境变量没有正确设置，在当前用户的<code>.bashrc</code>文件添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-12.6/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-12.6/lib64:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><ul><li><p>注意路径需要切换成你安装的版本</p></li><li><p>nvcc 其实就是CUDA程序的编译器哦</p></li></ul><h2 id="Hello-world-from-GPU！"><a href="#Hello-world-from-GPU！" class="headerlink" title="Hello world from GPU！"></a>Hello world from GPU！</h2><p>接下来我们就可以开始体验 CUDA 程序了！</p><p>一个简单的程序，我们直接使用CMake构建项目。（不会真有人CUDA程序用nvcc命令行编译吧。。）</p><p>文件结构如下：</p><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_23-18-38.png" class="" title="Clip_2024-10-29_23-18-38"><ul><li>你只需要关注CMakeLists.txt文件和src文件夹</li><li>include文件夹下是我们以后可能遇到的，这里你暂时不需要</li><li>src文件夹下就是我们的CUDA源码文件，以.cu结尾，这里你只需要创建mytext.cu文件就可以</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是CMakeLists.txt文件内容，关于现代CMake可以查看我的另一篇文章</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定CUDA标准版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="comment"># 设置为发布模式</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(cuda_test LANGUAGES CXX CUDA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加src目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;src/*.cu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(cuda_test <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是mytest.cu文件的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__host__ __device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU architecture %d!\n&quot;</span>, __CUDA_ARCH__);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用CMake构建并编译，关于现代CMake的内容可以阅读我的另一篇博客：<a href="https://blog.csdn.net/lurenze/article/details/143109755">现代CMake高级内容</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目根目录</span></span><br><span class="line">cd 你的目录/cuda_test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMake构建工程</span></span><br><span class="line">cmake -B build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译可执行程序</span></span><br><span class="line">cmake --build build/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行编译出的程序</span></span><br><span class="line">./build/cuda_test</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><img src="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/Clip_2024-10-29_23-32-37.png" class="" title="Clip_2024-10-29_23-32-37"><p>其中 <code>Hello, world from GPU architecture 520!</code>正是来自GPU的消息！</p><ul><li>这里的520可不是在爱你昂，这是CUDA程序的版本标识</li><li>想要了解更多，参考我的博客：<a href="https://blog.csdn.net/lurenze/category_12818209.html">GPU编程专栏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GPU编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> GPU编程 </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA开始的GPU编程</title>
      <link href="/2024/10/27/CUDA/CUDA%E5%BC%80%E5%A7%8B%E7%9A%84GPU%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/10/27/CUDA/CUDA%E5%BC%80%E5%A7%8B%E7%9A%84GPU%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA开始的GPU编程"><a href="#CUDA开始的GPU编程" class="headerlink" title="CUDA开始的GPU编程"></a>CUDA开始的GPU编程</h1><p>前置条件：</p><ul><li>熟悉C&#x2F;C++编程、熟悉STL、函数模板等</li><li>Nvidia GTX900及以上显卡、CUDA 11及以上</li><li>CMake 3.18及以上</li></ul><p><em>由于文本编辑器不持支CUDA代码块，文中CUDA代码将使用cpp代码块进行高亮显示，请注意区分</em></p><h2 id="第0章：Hello-world-from-GPU"><a href="#第0章：Hello-world-from-GPU" class="headerlink" title="第0章：Hello, world from GPU!"></a>第0章：Hello, world from GPU!</h2><h3 id="CMake中启用CUDA支持"><a href="#CMake中启用CUDA支持" class="headerlink" title="CMake中启用CUDA支持"></a>CMake中启用CUDA支持</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellocuda LANGUAGES CXX CUDA)<span class="comment"># 添加CUDA支持</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cu)<span class="comment"># 添加.cu源文件</span></span><br></pre></td></tr></table></figure><p>最新版的 CMake（3.18 以上），只需在 LANGUAGES 后面加上 CUDA 即可启用。</p><p>然后在 add_executable 里直接加你的 .cu 文件，和 .cpp 一样。</p><h3 id="CUDA编译器兼容C-17"><a href="#CUDA编译器兼容C-17" class="headerlink" title="CUDA编译器兼容C++17"></a>CUDA编译器兼容C++17</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cu这是一个.cu文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CUDA 的语法，基本完全兼容 C++。包括 C++17 新特性，都可以用。甚至可以把任何一个 C++ 项目的文件后缀名全部改成 .cu，都能编译出来。</p><p>这是 CUDA 的一大好处，CUDA 和 C++ 的关系就像 C++ 和 C 的关系一样，大部分都兼容，因此能很方便地重用 C++ 现有的任何代码库，引用 C++ 头文件等。</p><p>host 代码和 device 代码写在同一个文件内，这是 OpenCL 做不到的。</p><h3 id="编写一段在GPU上运行的代码"><a href="#编写一段在GPU上运行的代码" class="headerlink" title="编写一段在GPU上运行的代码"></a>编写一段在GPU上运行的代码</h3><p>定义函数 kernel，前面加上 <code>__global__</code> 修饰符，即可让他在 GPU 上执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行一下试试呢</span></span><br></pre></td></tr></table></figure><p>不过调用 kernel 时，不能直接 kernel()，而是要用 <code>kernel&lt;&lt;&lt;1, 1&gt;&gt;&gt;()</code> 这样的三重尖括号语法。为什么？这里面的两个 1 有什么用？稍后会说明。</p><p>运行以后，就会在 GPU 上执行 printf 了。（较旧的CUDA版本不支持直接打印）</p><p>这里的 kernel 函数在 GPU 上执行，称为核函数，用 <code>__global__</code> 修饰的就是核函数。</p><h3 id="运行没反应？同步一下！"><a href="#运行没反应？同步一下！" class="headerlink" title="运行没反应？同步一下！"></a>运行没反应？同步一下！</h3><p>如果直接编译运行刚刚那段代码，是不会打印出 Hello, world! 的。</p><p>这是因为 GPU 和 CPU 之间的通信，为了高效，是<strong>异步</strong>的。也就是 CPU 调用 <code>kernel&lt;&lt;&lt;1, 1&gt;&gt;&gt;()</code> 后，并不会立即在 GPU 上执行完毕，再返回。实际上只是把 kernel 这个任务推送到 GPU 的执行队列上，然后立即返回，并不会等待执行完毕。</p><p>因此可以调用 <code>cudaDeviceSynchronize()</code>，让 CPU 陷入等待，等 GPU 完成队列的所有任务后再返回。从而能够在 main 退出前等到 kernel 在 GPU 上执行完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br></pre></td></tr></table></figure><h3 id="定义在GPU上的设备函数"><a href="#定义在GPU上的设备函数" class="headerlink" title="定义在GPU上的设备函数"></a>定义在GPU上的设备函数</h3><p><code>__global__</code> 用于定义核函数，他在 <strong>GPU 上执行</strong>，从 CPU 端通过三重尖括号语法调用，可以有参数，不可以有返回值。</p><p>而 <code>__device__</code> 则用于定义设备函数，他<strong>在 GPU 上执行</strong>，但是<strong>从 GPU 上调用</strong>的，而且<strong>不需要三重尖括号</strong>，和普通函数用起来一样，可以有参数，有返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;<span class="comment">//内联修饰符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello, world!</span></span><br></pre></td></tr></table></figure><p>即：host 可以调用 global；global 可以调用 device；device 可以调用 device。</p><h3 id="声明为内联函数"><a href="#声明为内联函数" class="headerlink" title="声明为内联函数"></a>声明为内联函数</h3><p>CUDA提供<code>__inline</code>关键字提示内联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ __inline__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>没有下划线的<code>inline</code></strong> 在现代 C++ 中的效果是声明一个函数为 weak 符号，和性能优化意义上的内联无关。</p><ul><li><p><code>inline</code> 在现代 C++ 中的主要作用是<strong>允许函数在多个编译单元中定义而不产生链接错误</strong>，而不再主要用于提示编译器进行函数的内联优化</p></li><li><p><code>inline</code> 函数在编译过程中，编译器会将该函数的符号标记为“弱符号”（weak symbol）。这意味着，如果同一个 <code>inline</code> 函数在多个编译单元中被定义，链接器会将这些定义视为等价的，并只保留一个定义，而不是报重复定义错误。这在多文件编译中避免了链接错误。</p></li><li><p>在现代 C++ 中，编译器的优化技术已经足够智能，能够自动决定是否将某个函数内联。</p></li></ul><p>优化意义上的内联指把函数体直接放到调用者那里去。</p><p>因此 CUDA 编译器提供了一个“私货”关键字：<code>__inline__</code> 来声明一个函数为内联。不论是 CPU 函数还是 GPU 函数都可以使用，只要你用的 CUDA 编译器。GCC 编译器相应的私货则是 <code>__attribute__((“inline”))</code>。</p><p>注意，声明为 <code>__inline__</code> <strong>不一定</strong>就保证内联了，如果函数太大编译器可能会放弃内联化。因此 CUDA 还提供 <code>__forceinline__</code> 这个关键字来强制一个函数为内联。GCC 也有相应的 <code>__attribute__((“always_inline”))</code>。</p><p>此外，还有 <code>__noinline__</code> 来禁止内联优化。</p><h3 id="定义在-cpu-上的主机函数"><a href="#定义在-cpu-上的主机函数" class="headerlink" title="定义在 cpu 上的主机函数"></a>定义在 cpu 上的主机函数</h3><p><code>__device__</code> 将函数定义在 GPU 上，而 <code>__host__</code> 则相反，将函数定义在 CPU 上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__host__ <span class="type">void</span> <span class="title">say_hello_host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello_host</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello, world from GPU!</span></span><br><span class="line"><span class="comment">//Hello, world from CPU!</span></span><br></pre></td></tr></table></figure><p>CUDA 完全兼容 C++，因此任何函数如果没有指明修饰符，则默认就是 <code>__host__</code>，即 CPU 上的函数。</p><h3 id="同时定义在-CPU-和-GPU-上"><a href="#同时定义在-CPU-和-GPU-上" class="headerlink" title="同时定义在 CPU 和 GPU 上"></a>同时定义在 CPU 和 GPU 上</h3><p>这两个修饰符并不冲突，通过 <code>__host__ __device__</code> 这样的双重修饰符，可以把函数同时定义在 CPU 和 GPU 上，这样 CPU 和 GPU 都可以调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello_host</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello, world from GPU!</span></span><br><span class="line"><span class="comment">//Hello, world from CPU!</span></span><br></pre></td></tr></table></figure><p>此时，编译后会生成两个版本，CPU 会直接调用<code>__host__</code>版本， GPU 调用<code>__device__</code>版本</p><h3 id="给constexpr加点料"><a href="#给constexpr加点料" class="headerlink" title="给constexpr加点料"></a>给<code>constexpr</code>加点料</h3><p>CUDA提供了一个实验性选项<code>--expt-relaxed-constexpr</code></p><p>在CMake中配置使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellocuda LANGUAGES CXX CUDA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cu)</span><br><span class="line"><span class="keyword">target_compile_options</span>(main PUBLIC $&lt;$&lt;COMPILE_LANGUAGE:CUDA&gt;:--expt-relaxed-constexpr&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>这里使用了一个生成表达式语法，只对当前编译的语言是CUDA是起效</p></li><li><p>constexpr 函数在<strong>编译期</strong>执行</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr 函数在编译期执行</span></span><br><span class="line"><span class="comment">// 这个函数没有使用 __host__ 和 __device__ 修饰符，但是被两端成功调用</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">cuthead</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">cuthead</span>(<span class="string">&quot;Gello, world!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">cuthead</span>(<span class="string">&quot;Cello, world!\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// ello, world!</span></span><br><span class="line"><span class="comment">// ello, world!</span></span><br></pre></td></tr></table></figure><p>上面的<code>cuthead()</code>函数没有使用 <code>__host__</code> 和 <code>__device__</code> 修饰符，但是被两端成功调用。</p><p>这样相当于把 constexpr 函数自动变成 <code>__host__ __device__</code>修饰，从而两端都可以调用。</p><p>因为 constexpr 通常都是一些可以内联的函数，数学计算表达式之类的，一个个加上修饰太累了，所以产生了这个需求。</p><p>不过必须指定 <code>--expt-relaxed-constexpr</code> 这个选项才能用这个特性，我们可以用 CMake 的生成器表达式来实现只对 .cu 文件开启此选项（不然给到 gcc 就出错了）。</p><p>当然，constexpr 里没办法调用 printf，也不能用 <code>__syncthreads</code> 之类的 GPU 特有的函数，因此也不能完全替代 <code>__host__</code> 和 <code>__device__</code>。</p><h3 id="多段编译"><a href="#多段编译" class="headerlink" title="多段编译"></a>多段编译</h3><p>通过<code>#ifdef</code>指令针对CPU和GPU生成不同的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__host__ __device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CUDA 编译器具有多段编译的特点。</p><p>一段代码，会<strong>先送到 CPU 上的编译器</strong>（通常是系统自带的编译器比如 gcc 和 msvc）生成 CPU 部分的指令码。然后<strong>再送到 GPU 编译器</strong>生成 GPU 指令码。最后再链接成同一个文件，看起来好像只编译了一次一样，实际上你的代码会被预处理很多次。</p><p>在 GPU 编译模式下会定义 <code>__CUDA_ARCH__</code> 这个宏，利用 <code>#ifdef</code> 判断该宏是否定义，就可以判断当前是否处于 GPU 模式，从而实现一个函数针对 GPU 和 CPU 生成两份源码级不同的代码。</p><p><strong><code>__CUDA_ARCH__</code>是个版本号</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__host__ __device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU architecture %d!\n&quot;</span>, __CUDA_ARCH__);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello, world from GPU architecture 520 !</span></span><br><span class="line"><span class="comment">// Hello, world from CPU !</span></span><br></pre></td></tr></table></figure><p>其实 <code>__CUDA_ARCH__</code> 是一个整数，表示当前编译所针对的 GPU 的架构版本号是多少。这里是 520 表示版本号是 5.2.0，最后一位始终是 0 不用管，我们通常简称他的版本号为 52 就行了。</p><p>这个版本号是编译时指定的版本，不是运行时检测到的版本。编译器默认就是最老的 52，能兼容所有 GTX900 以上显卡。</p><h3 id="通过CMake设置架构版本号"><a href="#通过CMake设置架构版本号" class="headerlink" title="通过CMake设置架构版本号"></a>通过CMake设置架构版本号</h3><p>可以用 CMAKE_CUDA_ARCHITECTURES 这个变量，设置要针对哪个架构生成 GPU 指令码。</p><p>我的的显卡是 RTX4050，他的版本号是 89，因此最适合他用的指令码版本是 89。</p><p>如果不指定，编译器默认的版本号是 52，他是针对 GTX900 系列显卡的。</p><p>不过英伟达的架构版本都是向前兼容的，即版本号为 89 的 RTX4050 也可以运行版本号为 52 的指令码，虽然不够优化，但是至少能用。也就是要求：<strong>编译期指定的版本 ≤ 运行时显卡的版本</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定CUDA标准版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="comment"># 设置CUDA架构版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_ARCHITECTURES <span class="number">86</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(cuda_test LANGUAGES CXX CUDA)</span><br></pre></td></tr></table></figure><ul><li>可以在Nvidia官网查看自己的GPU架构，我的RTX4050是8.9</li><li><a href="https://developer.nvidia.com/cuda-gpus#collapseOne">官网链接</a></li></ul><img src="/2024/10/27/CUDA/CUDA%E5%BC%80%E5%A7%8B%E7%9A%84GPU%E7%BC%96%E7%A8%8B/Clip_2024-10-26_00-44-54.png" class="" title="Clip_2024-10-26_00-44-54"><p><strong>坑点！版本号不能太新了</strong></p><p><em>由于我的显卡是目前最新架构，无法复现这个错误，请自行测试</em></p><p>假设你的显卡是RTX3000系列，这里设置了 RTX4000 系列的架构版本号 89，在 RTX3000系上就运行不出结果。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定CUDA标准版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="comment"># 设置CUDA架构版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_ARCHITECTURES <span class="number">89</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(cuda_test LANGUAGES CXX CUDA)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__host__ __device__ <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from GPU architecture %d!\n&quot;</span>, __CUDA_ARCH__);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world from CPU!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello, world from CPU !</span></span><br></pre></td></tr></table></figure><p>最坑的是不会报错！也不输出任何东西！就像没有那个 kernel 函数一样！所以一定要注意调对版本号，否则<strong>只有 CPU 上的代码被执行了</strong>。</p><h4 id="指定多个版本号"><a href="#指定多个版本号" class="headerlink" title="指定多个版本号"></a>指定多个版本号</h4><p>可以指定多个版本号，之间用分号分割。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CUDA_ARCHITECTURES <span class="number">52</span>;<span class="number">70</span>;<span class="number">75</span>;<span class="number">86</span>;<span class="number">89</span>)</span><br></pre></td></tr></table></figure><p>运行时可以自动选择最适合当前显卡的版本号，通常用于打包发布的时候。</p><p>不过这样会导致 GPU 编译器重复编译很多遍，每次针对不同的架构，所以编译会变得非常慢，生成的可执行文件也会变大。</p><p>通常在自己的电脑上用时，只要根据自己显卡的指定一个版本号即可。</p><p>如果 CMakeLists.txt 里没有指定，也可以从命令行参数指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_CUDA_ARCHITECTURES=&quot;52;70;75;86;89&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的运行输出：</span></span><br><span class="line">ming@MING:~/project/cuda/cuda_test$ ./build/mytest </span><br><span class="line">Hello, world from GPU architecture 890!</span><br><span class="line">Hello, world from CPU!</span><br></pre></td></tr></table></figure><h2 id="第一章：线程与板块"><a href="#第一章：线程与板块" class="headerlink" title="第一章：线程与板块"></a>第一章：线程与板块</h2><h3 id="三重尖括号里的数字"><a href="#三重尖括号里的数字" class="headerlink" title="三重尖括号里的数字"></a>三重尖括号里的数字</h3><p>刚刚说了 CUDA 的核函数调用时需要用 kernel&lt;&lt;&lt;1, 1&gt;&gt;&gt;() 这种奇怪的语法，这里面的数字代表什么意思呢？</p><p>不妨把 &lt;&lt;&lt;1, 1&gt;&gt;&gt; 改成 &lt;&lt;&lt;1, 3&gt;&gt;&gt; 试试看。你会看到 Hello, world! 打印了三遍！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>原来，三重尖括号里的第二个参数决定着启动 kernel 时所用 GPU 的<strong>线程</strong>数量。</p><p>GPU 是为并行而生的，可以开启很大数量的线程，用于处理大吞吐量的数据。</p>]]></content>
      
      
      <categories>
          
          <category> GPU编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> GPU编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解STL-set系列容器与迭代器分类</title>
      <link href="/2024/10/23/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%89%E3%80%81set%E7%B3%BB%E5%88%97%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/"/>
      <url>/2024/10/23/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%89%E3%80%81set%E7%B3%BB%E5%88%97%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h2><table><thead><tr><th>迭代器类型</th><th>描述</th><th><strong>提供的运算符重载</strong></th><th><strong>具有此迭代器的容器</strong></th><th><strong>相应的 C++20 concept</strong></th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读访问序列，允许单次读取每个元素</td><td>*（可读取），!&#x3D;，&#x3D;&#x3D;，++（一次性）</td><td><code>istream_iterator</code></td><td><code>input_iterator</code></td></tr><tr><td>输出迭代器</td><td>只写访问序列，允许将数据写入到序列中</td><td>*（可写入），!&#x3D;，&#x3D;&#x3D;，++（一次性）</td><td><code>back_insert_iterator</code></td><td><code>output_iterator</code></td></tr><tr><td>前向迭代器</td><td>允许读写访问，支持多次读取同一元素</td><td>*，!&#x3D;，&#x3D;&#x3D;，++</td><td><code>forward_list</code></td><td><code>forward_iterator</code></td></tr><tr><td>双向迭代器</td><td>支持前向和后向遍历</td><td>*，!&#x3D;，&#x3D;&#x3D;，++，–</td><td><code>set</code>，<code>map</code>，<code>list</code></td><td><code>bidirectional_iterator</code></td></tr><tr><td>随机访问迭代器</td><td>支持直接访问序列中的任意元素，提供随机访问能力</td><td>*，!&#x3D;，&#x3D;&#x3D;，++，–，+，-，+&#x3D;，-&#x3D;，[]</td><td><code>vector</code>，<code>array</code>，<code>deque</code></td><td><code>random_access_iterator</code></td></tr><tr><td>迭代器外包装</td><td>封装原始迭代器，增强功能（如反向遍历、过滤等）</td><td>与所包装的迭代器保持一致</td><td><code>reverse_iterator</code>，<code>filter_iterator</code></td><td>与所包装的迭代器一致</td></tr></tbody></table><ul><li>“一次性”的理解：单向性和不可逆性</li><li>每个元素只能被访问一次，调用<code>++</code>会使这个迭代器指向下一个元素</li></ul><p>包含关系：前向迭代器＞双向迭代器＞随机访问迭代器</p><p>这意味着如果一个STL模板函数（比如std::find）要求迭代器是<strong>前向迭代器</strong>即可，那么也可以给他随机访问迭代器，因为<strong>前向迭代器</strong>是<strong>随机访问迭代器</strong>的子集。</p><p>例如，vector 和 list 都可以调用 std::find（set 则直接提供了 find 作为成员函数）</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>打印<strong>任意</strong> 包含<code>begin</code>、<code>end</code>的STL 容器的黑科技</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> = <span class="type">const</span> <span class="type">char</span> *&gt;</span><br><span class="line"><span class="keyword">struct</span> __printer_test_c_str &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__printer_test_c_str</span>&lt;T, <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">c_str</span>())&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> = <span class="number">0</span>, <span class="type">int</span> = <span class="number">0</span>, <span class="type">int</span> = <span class="number">0</span>,</span><br><span class="line">         <span class="keyword">class</span> = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;std::ostream &amp;&gt;() &lt;&lt; *++std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">begin</span>()),</span><br><span class="line">         <span class="keyword">class</span> = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">begin</span>() != std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">end</span>()),</span><br><span class="line">         <span class="keyword">class</span> = <span class="keyword">typename</span> __printer_test_c_str&lt;T&gt;::type&gt;</span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, T <span class="type">const</span> &amp;v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        os &lt;&lt; *it;</span><br><span class="line">        <span class="keyword">for</span> (++it; it != v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            os &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><p><code>set</code>容器是一个存储不重复元素的<strong>集合</strong>。</p><ul><li><p><strong>唯一性</strong>：<code>set</code>中的元素是唯一的，不能重复。</p></li><li><p><strong>自动排序</strong>：<code>set</code>中的元素根据键值自动进行排序，默认使用升序排列。</p></li><li><p><strong>动态大小</strong>：<code>set</code>可以根据需要动态调整大小，自动管理内存。</p></li></ul><h3 id="set和vector的区别"><a href="#set和vector的区别" class="headerlink" title="set和vector的区别"></a><code>set</code>和<code>vector</code>的区别</h3><p>都是能存储一连串数据的容器。</p><ul><li><p>区别1：set会自动给其中的元素<strong>从小到大排序</strong>，而vector会保持插入时的顺序。</p></li><li><p>区别2：set会把重复的元素去除，只保留一个，即<strong>去重</strong>。</p></li><li><p>区别3：vector中的元素在内存中是连续的，可以高效地按<strong>索引</strong>随机访问，set则不行。</p></li><li><p>区别4：set中的元素可以高效地按<strong>值</strong>查找，而 vector 则低效。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// vector=&#123;9,8,5,2,1,1&#125;</span></span><br><span class="line"><span class="comment">// set=&#123;1,2,5,8,9&#125;排序并去重</span></span><br></pre></td></tr></table></figure><h3 id="set的排序："><a href="#set的排序：" class="headerlink" title="set的排序："></a><code>set</code>的排序：</h3><h4 id="string会按“字典序”排列"><a href="#string会按“字典序”排列" class="headerlink" title="string会按“字典序”排列"></a>string会按“字典序”排列</h4><p>set 会从小到大排序，对 int 来说就是数值的大小比较。那么对字符串类型 string 要怎么排序呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; a = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    set&lt;string&gt; b = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// vector=&#123;arch,any,zero,Linux&#125;</span></span><br><span class="line"><span class="comment">// set=&#123;Linux,any,arch,zero&#125;</span></span><br></pre></td></tr></table></figure><p>其实 string 类定义了运算符重载 &lt;，他会按<strong>字典序</strong>比较两个字符串。所谓字典序就是优先比较两者第一个字符（按 ASCII 码比较），如果相等则继续比较下一个，不相等则直接以这个比较的结果返回。如果比到末尾都相等且字符串长度一样，则视为相等。</p><ul><li>警告：千万别用 set&lt;char *&gt; 做字符串集合。这样只会按字符串指针的地址去判断相等，而不是所指向字符串的内容。</li></ul><h4 id="自定义排序函数"><a href="#自定义排序函数" class="headerlink" title="自定义排序函数"></a>自定义排序函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyComp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string <span class="type">const</span> &amp;a, string <span class="type">const</span> &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;string, MyComp&gt; b = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// set=&#123;Linux,any,arch,zero&#125;</span></span><br></pre></td></tr></table></figure><p>set 作为模板类，其实有两个模板参数：set&lt;T, CompT&gt;</p><p>第一个 T 是容器内元素的类型，例如 int 或 string 等。</p><p>第二个 CompT 定义了你想要的<strong>比较函子</strong>，set 内部会调用这个函数来决定怎么排序。</p><p>如果 CompT 不指定，默认会直接用运算符 <code>&lt;</code> 来比较。</p><p>这里我们定义个 MyComp 作为比较函子，和默认的一样用 &lt; 来比较，所以没有变化。</p><p><strong>相等怎么判断？</strong></p><p>恶搞一下，这里我们把比较函子 MyComp 定义成只比较字符串第一个字符 a[0] &lt; b[0]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyComp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string <span class="type">const</span> &amp;a, string <span class="type">const</span> &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; <span class="comment">//只比较第一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;string, MyComp&gt; b = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// set=&#123;Linux,arch,zero&#125;</span></span><br></pre></td></tr></table></figure><p>神奇的一幕发生了，“any” 不见了！为什么？因为去重！</p><p>为什么 set 会把 “arch” 和 “any” 视为相等的元素？明明内容都不一样？</p><p>首先搞懂 set 内部是怎么确定两个元素 a 和 b 相等的：</p><p><code>!(a &lt; b) &amp;&amp; !(b &lt; a)</code></p><p>也就是说他 set 内部没有用到 <code>==</code> 运算符，而是调用了两次比较函子来判断的。逻辑是：</p><p>若 <strong>a不小于b且b不小于a</strong>，则视为<strong>a等于b</strong>，所以这就是为什么 set 只需要一个比较函子，不需要相等函子的原因。</p><p>所以我们这里写了 <code>a[0] &lt; b[0]</code> 就相当于让相等条件变成了 <code>a[0] == b[0]</code>。也就是说只要第一个字符相等就视为字符串相等，所以 “arch” 和 “any” 会被视为相等的元素，从而被 set 给去重了！</p><ul><li>扩展知识：其实，<code>map&lt;K, T&gt;</code> 无非就是个只比较 K 无视 T 的 <code>set&lt;pair&lt;K, T&gt;&gt;</code>，顺手还加了一些方便的函数，比如 <code>[]</code> 和 <code>at</code></li></ul><p><strong>小技巧：大小写不敏感的set容器</strong></p><p>既然已经知道了set容器进行比较的原理，我们就可以在比较函子中进行一些操作，让”linux”和”Linux”被视为相同的元素，只保存一个，即大小写不敏感。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyComp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string a, string b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转换为小写</span></span><br><span class="line">        std::<span class="built_in">transform</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), a.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        std::<span class="built_in">transform</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;string, MyComp&gt; b = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>, <span class="string">&quot;linUX&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//set=&#123;any,arch,Linux,zero&#125;</span></span><br></pre></td></tr></table></figure><h3 id="set的迭代器"><a href="#set的迭代器" class="headerlink" title="set的迭代器"></a><code>set</code>的迭代器</h3><h5 id="set和vector迭代器的相同点："><a href="#set和vector迭代器的相同点：" class="headerlink" title="set和vector迭代器的相同点："></a><strong>set和vector迭代器的相同点：</strong></h5><p>上一篇我们讨论了迭代器：vector 具有 <code>begin()</code> 和 <code>end()</code> 两个成员函数，他们分别返回指向数组<strong>头部元素</strong>和<strong>尾部再之后一格元素</strong>的迭代器对象。</p><p>vector 作为连续数组，他的迭代器基本等效于指针。</p><p>set 也有 <strong>begin()</strong> 和 <strong>end()</strong> 函数，他返回的迭代器对象重载了 ***** 来访问指向的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator a_it = a.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector[0]=&quot;</span> &lt;&lt; *a_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator b_it = b.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set[0]=&quot;</span> &lt;&lt; *b_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// vector[0]=1</span></span><br><span class="line"><span class="comment">// set[0]=1</span></span><br></pre></td></tr></table></figure><h5 id="set和vector迭代器的不同点："><a href="#set和vector迭代器的不同点：" class="headerlink" title="set和vector迭代器的不同点："></a><strong>set和vector迭代器的不同点：</strong></h5><p>set 的迭代器对象也重载了 <strong>++</strong> 为红黑树的遍历。</p><p>vector 提供了 <strong>+</strong> 和 <strong>+&#x3D;</strong> 的重载，而 set 没有。这是因为 vector 中的元素在内存中是连续的，可以<strong>随机访问</strong>。而 set 是不连续的，所以不能随机访问，只能<strong>顺序访问</strong>。</p><p>set容器随机访问的开销很大，为了防止滥用，set直接放弃重载<code>+</code>运算符，因此无法通过<code>迭代器 + 偏移量</code>的方式来访问元素。</p><p>所以这里调用 b.begin() + 3，就出错了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator b_it = b.<span class="built_in">begin</span>() + <span class="number">3</span>;<span class="comment">//error: no match for &#x27;operator+&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="多次调用-实现-同样的效果"><a href="#多次调用-实现-同样的效果" class="headerlink" title="多次调用++实现+同样的效果"></a><strong>多次调用<code>++</code>实现<code>+</code>同样的效果</strong></h5><p>set 迭代器没有重载 + 运算符，因为他不是随机迭代器。</p><p>那如果我确实需要让 set 迭代器向前移动 3 格怎么办？</p><p>可以调用三次 ++ 运算，实现和 + 3 同样的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator a_it = a.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector[3]=&quot;</span> &lt;&lt; *a_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//set&lt;int&gt;::iterator b_it = b.begin() + 3;</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator b_it = b.<span class="built_in">begin</span>();</span><br><span class="line">    ++b_it;</span><br><span class="line">    ++b_it;</span><br><span class="line">    ++b_it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set[3]=&quot;</span> &lt;&lt; *b_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// vector[3]=4</span></span><br><span class="line"><span class="comment">// set[3]=4</span></span><br></pre></td></tr></table></figure><p>vector 迭代器的 + n 复杂度是 O(1)。而 set 迭代器模拟出来的 + n 复杂度为 O(n)。虽然低效，但至少可以用了。</p><h3 id="迭代器的帮手函数"><a href="#迭代器的帮手函数" class="headerlink" title="迭代器的帮手函数"></a>迭代器的帮手函数</h3><h4 id="1-std-next：获取迭代器的下一个位置"><a href="#1-std-next：获取迭代器的下一个位置" class="headerlink" title="1. std::next：获取迭代器的下一个位置"></a>1. <code>std::next</code>：获取迭代器的下一个位置</h4><p><code>std::next</code> 函数用于获取指定迭代器向前移动指定步数后的新迭代器，而不会改变原迭代器。它适用于所有类型的迭代器，包括输入迭代器、前向迭代器、双向迭代器和随机访问迭代器。</p><ul><li>作用：<ul><li>对于随机访问迭代器，它会直接使用 <code>+</code> 运算符。</li><li>对于不支持 <code>+</code> 运算符的迭代器（如前向迭代器和双向迭代器），则会依次调用 <code>++</code> 运算符，直至移动完成。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> a_it = std::<span class="built_in">next</span>(a.<span class="built_in">begin</span>(), <span class="number">3</span>);  <span class="comment">// 相当于 a_it + 3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector[3] = &quot;</span> &lt;&lt; *a_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b_it = std::<span class="built_in">next</span>(b.<span class="built_in">begin</span>(), <span class="number">3</span>);  <span class="comment">// 相当于 ++b_it 三次</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set[3] = &quot;</span> &lt;&lt; *b_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// vector[3] = 4</span></span><br><span class="line"><span class="comment">// set[3] = 4</span></span><br></pre></td></tr></table></figure><ul><li><strong>实现思想</strong>： <code>std::next</code> 判断迭代器类型，若是随机访问迭代器则直接使用 <code>+</code>，否则循环调用 <code>++</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">next</span><span class="params">(<span class="keyword">auto</span> it, <span class="type">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it is random_access) &#123;</span><br><span class="line">        <span class="keyword">return</span> it + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-std-advance：就地移动迭代器"><a href="#2-std-advance：就地移动迭代器" class="headerlink" title="2. std::advance：就地移动迭代器"></a>2. <code>std::advance</code>：就地移动迭代器</h4><p>与 <code>std::next</code> 不同，<code>std::advance</code> 是<strong>就地修改</strong>传入的迭代器，而不是返回一个新的迭代器。它适用于需要修改迭代器本身的场景。</p><ul><li><p>作用：</p><ul><li><p>如果迭代器支持 <code>+=</code> 运算符，则直接使用该运算符。</p></li><li><p>否则会像 <code>std::next</code> 一样，逐步调用 <code>++</code>。</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> a_it = a.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(a_it, <span class="number">3</span>);  <span class="comment">// 等价于 a_it += 3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector[3] = &quot;</span> &lt;&lt; *a_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b_it = b.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(b_it, <span class="number">3</span>);  <span class="comment">// 会调用三次 ++b_it</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set[3] = &quot;</span> &lt;&lt; *b_it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// vector[3] = 4</span></span><br><span class="line"><span class="comment">// set[3] = 4</span></span><br></pre></td></tr></table></figure><ul><li><strong>实现思想</strong>： <code>std::advance</code> 会直接修改传入的迭代器，而不返回新的迭代器：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(<span class="keyword">auto</span> &amp;it, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it is random_access) &#123;</span><br><span class="line">        it += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-next-和-advance-对负数的支持"><a href="#3-next-和-advance-对负数的支持" class="headerlink" title="3. next 和 advance 对负数的支持"></a>3. <code>next</code> 和 <code>advance</code> 对负数的支持</h4><ul><li><strong>负数支持</strong>：如果迭代器类型是<strong>双向迭代器</strong>或更高级别，<code>next</code> 和 <code>advance</code> 支持负数，表示迭代器向前移动。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">next</span>(iter, <span class="number">-3</span>);  <span class="comment">// 相当于 iter - 3</span></span><br></pre></td></tr></table></figure><p>对于更简便的使用，<code>std::prev</code> 提供了向前移动的功能。</p><h4 id="4-std-prev：向后移动迭代器"><a href="#4-std-prev：向后移动迭代器" class="headerlink" title="4. std::prev：向后移动迭代器"></a>4. <code>std::prev</code>：向后移动迭代器</h4><p><code>std::prev</code> 是 <code>std::next</code> 的逆操作，用于向后移动迭代器。其内部实现类似于 <code>std::next(it, -n)</code>，可以有效替代手动的负数操作。</p><ul><li><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">prev</span><span class="params">(<span class="keyword">auto</span> it, <span class="type">int</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">next</span>(it, -n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-std-distance：计算两个迭代器之间的距离"><a href="#5-std-distance：计算两个迭代器之间的距离" class="headerlink" title="5. std::distance：计算两个迭代器之间的距离"></a>5. <code>std::distance</code>：计算两个迭代器之间的距离</h4><p><code>std::distance</code> 用于计算两个迭代器之间的距离。对于随机访问迭代器，它的计算是常数时间；对于其他类型的迭代器，它会逐步计算两者的差距。</p><ul><li><strong>示例</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> a_size = std::<span class="built_in">distance</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());  <span class="comment">// 调用 a.end() - a.begin()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; a_size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b_size = std::<span class="built_in">distance</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());  <span class="comment">// 逐步计算距离</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set size = &quot;</span> &lt;&lt; b_size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// vector size = 7</span></span><br><span class="line"><span class="comment">// set size = 7</span></span><br></pre></td></tr></table></figure><ul><li><strong>实现思想</strong>： <code>std::distance</code> 会根据迭代器的类型，使用高效或逐步的方式计算迭代器之间的距离。</li></ul><h4 id="注意上面所有提到的实现思想都是伪代码"><a href="#注意上面所有提到的实现思想都是伪代码" class="headerlink" title="注意上面所有提到的实现思想都是伪代码"></a><strong>注意上面所有提到的实现思想都是伪代码</strong></h4><p>感兴趣的可以查看的源码，下面是<code>std::distance</code>的实现，它使用了一个辅助函数<code>std::__distance</code>以及<code>__iterator_category</code>来获取迭代器的类别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> _GLIBCXX17_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(_InputIterator __first, _InputIterator __last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// concept requirements -- taken care of in __distance</span></span><br><span class="line">    <span class="keyword">return</span> std::__distance(__first, __last,</span><br><span class="line">                           std::__iterator_category(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> _GLIBCXX_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::iterator_category</span><br><span class="line">__iterator_category(<span class="type">const</span> _Iter&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::<span class="built_in">iterator_category</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inset-函数"><a href="#inset-函数" class="headerlink" title="inset()函数"></a><code>inset()</code>函数</h3><h4 id="向set中插入元素"><a href="#向set中插入元素" class="headerlink" title="向set中插入元素"></a>向<code>set</code>中插入元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>可以通过调用 insert 往 set 中添加一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入之前: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入之后: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 插入之前: &#123;1, 2, 4&#125;</span></span><br><span class="line"><span class="comment">// 插入之后: &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>用户无需关心插入的位置，例如插入元素 3 时，set 会自动插入到 2 和 4 之间，从而使元素总是从小到大排列。</p><p>刚刚说过 set 具有<strong>自动去重</strong>的功能，如果插入的元素已经在 set 中存在，则不会完成插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入之前: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入之后: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 插入之前: &#123;1, 2, 4&#125;</span></span><br><span class="line"><span class="comment">// 插入之后: &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>例如往集合 {1,2,4} 中插入 4 则什么也不会发生，因为 4 已经在集合中了。</p><h4 id="insert-的第一个返回值：指向插入-现有元素的迭代器"><a href="#insert-的第一个返回值：指向插入-现有元素的迭代器" class="headerlink" title="insert 的第一个返回值：指向插入&#x2F;现有元素的迭代器"></a>insert 的第一个返回值：指向插入&#x2F;现有元素的迭代器</h4><p><strong>第一个返回值是一个迭代器</strong>，分两种情况讨论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> res1 = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入3成功吗：&quot;</span> &lt;&lt; res1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3所在的位置：&quot;</span> &lt;&lt; *res1.first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> res2 = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;再次插入3成功吗：&quot;</span> &lt;&lt; res2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3所在的位置：&quot;</span> &lt;&lt; *res2.first &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 插入3成功吗：1</span></span><br><span class="line"><span class="comment">// 3所在的位置：3</span></span><br><span class="line"><span class="comment">// 再次插入3成功吗：0</span></span><br><span class="line"><span class="comment">// 3所在的位置：3</span></span><br></pre></td></tr></table></figure><p>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</p><p>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</p><h4 id="insert的第二个返回值：是否插入成功"><a href="#insert的第二个返回值：是否插入成功" class="headerlink" title="insert的第二个返回值：是否插入成功"></a>insert的第二个返回值：是否插入成功</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> res4 = b.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入4成功吗：&quot;</span> &lt;&lt; res4.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> res3 = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入3成功吗：&quot;</span> &lt;&lt; res3.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 插入4成功吗：0</span></span><br><span class="line"><span class="comment">// 插入3成功吗：1</span></span><br></pre></td></tr></table></figure><p>insert 函数的返回值是一个 <code>pair</code> 类型，也就是说他同时返回了两个值。其中<strong>第二个返回值是</strong> <strong>bool</strong> <strong>类型，指示了插入是否成功</strong>。</p><p>若元素在 set 容器中已存有相同的元素，则插入失败，这个 bool 值为 false；如果元素在 set 中不存在，则插入成功，这个 bool 值为 true。</p><h4 id="补充内容："><a href="#补充内容：" class="headerlink" title="补充内容："></a>补充内容：</h4><ul><li>pair 类似于 python 里的元组，不过固定只能有两个元素，自从 C++11 引入了能支持任意多元素的 tuple 以来，就没 pair 什么事了……但是为了兼容 pair 还是继续存在着。pair 是个模板类，根据尖括号里你给定的类型来替换这里的 _T1 和 _T2。例如 pair&lt;iterator, bool&gt; 就会变成：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">iterator first;</span><br><span class="line"><span class="type">bool</span> second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>C++17 提供了结构化绑定(structual binding)的语法，可以取出一个 POD 结构体的所有成员，pair 也不例外。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [ok, it] = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">auto</span> tmp = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> ok = tmp.first;</span><br><span class="line"><span class="keyword">auto</span> it = tmp.second;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [it1, ok1] = b.<span class="built_in">insert</span>(<span class="number">3</span>);<span class="comment">//使用结构化绑定语法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入3成功吗：&quot;</span> &lt;&lt; ok1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3所在的位置：&quot;</span> &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> [it2, ok2] = b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;再次插入3成功吗：&quot;</span> &lt;&lt; ok2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3所在的位置：&quot;</span> &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 插入3成功吗：1</span></span><br><span class="line"><span class="comment">// 3所在的位置：3</span></span><br><span class="line"><span class="comment">// 再次插入3成功吗：0</span></span><br><span class="line"><span class="comment">// 3所在的位置：3</span></span><br></pre></td></tr></table></figure><h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a><code>find()</code>函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>set 有一个 find函数。只需给定一个参数，他会寻找 set 中与之相等的元素。</p><p>如果找到，则返回指向找到元素的迭代器。</p><p>如果找不到，则返回 end() 迭代器。</p><p>刚刚说过，end() 指向的是 set 的<strong>尾部再之后一格</strong>元素，他指向的是一个不存在的地址，不可能有任何元素在那里！因此 end() 常被标准库用作一个标记，来表示找不到的情况。</p><ul><li>Python 中的 find 找不到元素时会返回 -1 来表示，也是这个思想。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = b.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2所在位置：&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;比2小的数：&quot;</span> &lt;&lt; *<span class="built_in">prev</span>(it) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;比2大的数：&quot;</span> &lt;&lt; *<span class="built_in">next</span>(it) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 2所在位置：2</span></span><br><span class="line"><span class="comment">// 比2小的数：1</span></span><br><span class="line"><span class="comment">// 比2大的数：4</span></span><br></pre></td></tr></table></figure><p><strong>判断某个元素是否存在</strong></p><p>因此，可以用这个写法：</p><p><code>set.find(x) !=set.end()</code></p><p>来判断集合 set 中是否存在元素 x。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">find</span>(<span class="number">2</span>) != b.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中存在2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中没有2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">find</span>(<span class="number">8</span>) != b.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中存在8&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中没有8&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 集合中存在2</span></span><br><span class="line"><span class="comment">// 集合中没有8</span></span><br></pre></td></tr></table></figure><p>这是个固定的写法，虽然要调用两个函数看起来好像挺麻烦，但是大家都在用。</p><p>还有一种更直观的写法：</p><p><code>set.count(x) != 0</code></p><p>count 返回的是一个 int 类型，表示<strong>集合中相等元素的个数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">count</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中存在2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中没有2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">count</span>(<span class="number">8</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中存在8&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;集合中没有8&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 集合中存在2</span></span><br><span class="line"><span class="comment">// 集合中没有8</span></span><br></pre></td></tr></table></figure><p>等等，不是说 set 具有<strong>去重</strong>的功能，不会有重复的元素吗？为什么标准库让 count 计算个数而不是直接返回 bool…因为他们考虑到接口的泛用性，毕竟 multiset 就不去重。对于能去重的 set，<strong>count只可能返回0或1</strong>。</p><p>个数为 <strong>0</strong> 就说明集合中<strong>没有</strong>该元素。个数为 <strong>1</strong> 就说明集合中<strong>存在</strong>该元素。</p><p>因为 int 类型能隐式转换为 bool，所以 !&#x3D; 0 可以省略不写。</p><h3 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a><code>erase()</code>函数</h3><h4 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h4><p>以<strong>元素值</strong>作为参数传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删之前：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> num = b.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删之后：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删了 &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 删之前：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 删之后：&#123;1, 2, 3, 5&#125;</span></span><br><span class="line"><span class="comment">// 删了 1 个元素</span></span><br></pre></td></tr></table></figure><p>set.erase(x) 可以删除集合中值为 x 的元素。</p><p>erase 返回一个整数，表示被他删除元素的个数。</p><ul><li><p>个数为 <strong>0</strong> 就说明集合中<strong>没有</strong>该元素，删除失败。</p></li><li><p>个数为 <strong>1</strong> 就说明集合中<strong>存在</strong>该元素，删除成功。</p></li></ul><p>这里的“个数”和 count 的情况很像，因为 set 中不会有重复的元素，所以 <strong>erase</strong> <strong>只可能返回</strong> <strong>0</strong> <strong>或</strong> <strong>1</strong>，表示是否删除成功。</p><p>erase 还<strong>支持迭代器</strong>作为参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">find</span>(<span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除元素4：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删最小元素：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(b.<span class="built_in">end</span>()));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删最大元素：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 删除元素4：&#123;1, 2, 3, 5&#125;</span></span><br><span class="line"><span class="comment">// 删最小元素：&#123;2, 3, 5&#125;</span></span><br><span class="line"><span class="comment">// 删最大元素：&#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure><p><code>set.erase(it)</code> 可以删除集合位于 it 处的元素。用法举例：</p><ul><li><code>set.erase(set.find(x))</code> 会<strong>删除集合中值为</strong> <strong>x</strong> <strong>的元素</strong>，和 set.erase(x) 等价。</li><li><code>set.erase(set.begin())</code> 会<strong>删除集合中最小的元素</strong>（因为 set 具有自动排序的特性，排在最前面的元素一定是最小的那个）</li><li><code>set.erase(std::prev(set.end()))</code> 会<strong>删除集合中最大的元素</strong>（因为自动排序的特性，排在最后面的元素一定是最大的那个）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ！错误操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyComp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string &amp;lhs, <span class="type">const</span> std::string &amp;rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs &lt; rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;std::string, MyComp&gt; b = &#123;<span class="string">&quot;arch&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;Linux&quot;</span>, <span class="string">&quot;linUX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误的修改方式：直接使用const_cast强制转换后修改</span></span><br><span class="line">    *<span class="built_in">const_cast</span>&lt;std::string *&gt;(&amp;(*b.<span class="built_in">find</span>(<span class="string">&quot;any&quot;</span>))) = <span class="string">&quot;zebra&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后的set = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;found = &quot;</span> &lt;&lt; b.<span class="built_in">count</span>(<span class="string">&quot;zebra&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// set = &#123;Linux, any, arch, linUX, zero&#125; </span></span><br><span class="line"><span class="comment">// 修改后的set = &#123;Linux, zebra, arch, linUX, zero&#125; </span></span><br><span class="line"><span class="comment">// found = 0</span></span><br></pre></td></tr></table></figure><h4 id="删除指定区间（隐患操作）"><a href="#删除指定区间（隐患操作）" class="headerlink" title="删除指定区间（隐患操作）"></a>删除指定区间（隐患操作）</h4><p><code>erase</code> 方法支持输入<strong>两个迭代器</strong>作为参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator erase(iterator first, iterator last);</span><br></pre></td></tr></table></figure><p>使用 <code>set.erase(beg, end)</code> 可以删除集合中从 <code>beg</code> 到 <code>end</code> 之间的元素，包含 <code>beg</code>，不包含 <code>end</code>。即它是一个**前开后闭区间 [beg, end)**，这符合标准库的一贯设计风格。</p><p><strong>示例代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">find</span>(<span class="number">2</span>), b.<span class="built_in">find</span>(<span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除[2, 4)之间的元素：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 删除[2, 4)之间的元素：&#123;1, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码会<strong>删除 set 中所有满足 2 ≤ x &lt; 4 的元素</strong>。由于 <code>set</code> 有自动排序的特性，删除 <code>2</code> 和 <code>4</code> 之间的元素即为删除 <code>2 ≤ x &lt; 4</code> 的元素。</p><h5 id="隐患警告："><a href="#隐患警告：" class="headerlink" title="隐患警告："></a>隐患警告：</h5><ul><li><strong>注意</strong>：<code>beg</code> 必须在 <code>end</code> 之前，否则会导致崩溃。</li><li>如果集合中没有 <code>2</code>，<code>find(2)</code> 将返回 <code>end()</code>，而 <code>find(4)</code> 会返回指向 <code>4</code> 的迭代器。此时 <code>find(2)</code> 的迭代器在 <code>find(4)</code> 之后，违反了“<strong>beg 必须在 end 之前</strong>”的规则，可能导致程序崩溃。</li></ul><p><strong>示例代码（隐患演示）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 没有2</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">find</span>(<span class="number">2</span>), b.<span class="built_in">find</span>(<span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除[2, 4)之间的元素：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0, 1, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// free() : invalid pointer</span></span><br><span class="line"><span class="comment">// Aborted(core dumped)</span></span><br></pre></td></tr></table></figure><h5 id="使用-lower-bound-和-upper-bound-函数"><a href="#使用-lower-bound-和-upper-bound-函数" class="headerlink" title="使用 lower_bound() 和 upper_bound() 函数"></a>使用 <code>lower_bound()</code> 和 <code>upper_bound()</code> 函数</h5><p>为了安全地删除指定区间的元素，可以使用以下两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">bool</span> success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过测试&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">check</span>(b.<span class="built_in">find</span>(<span class="number">2</span>) == b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">check</span>(b.<span class="built_in">lower_bound</span>(<span class="number">2</span>) == b.<span class="built_in">find</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">check</span>(b.<span class="built_in">upper_bound</span>(<span class="number">2</span>) == b.<span class="built_in">find</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0, 1, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 通过测试</span></span><br><span class="line"><span class="comment">// 通过测试</span></span><br><span class="line"><span class="comment">// 通过测试</span></span><br></pre></td></tr></table></figure><ul><li><code>find(x)</code> 找到第一个<strong>等于</strong> <code>x</code> 的元素。</li><li><code>lower_bound(x)</code> 找到第一个<strong>大于等于</strong> <code>x</code> 的元素。</li><li><code>upper_bound(x)</code> 找到第一个<strong>大于</strong> <code>x</code> 的元素。</li></ul><p>当找不到时，它们都会返回 <code>end()</code>。</p><h5 id="正确从-set-中删除指定范围的元素"><a href="#正确从-set-中删除指定范围的元素" class="headerlink" title="正确从 set 中删除指定范围的元素"></a>正确从 <code>set</code> 中删除指定范围的元素</h5><p>可以使用 <code>lower_bound()</code> 和 <code>upper_bound()</code> 来安全删除指定区间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">lower_bound</span>(<span class="number">2</span>), b.<span class="built_in">upper_bound</span>(<span class="number">4</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除[2, 4]之间的元素：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0, 1, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 删除[2, 4]之间的元素：&#123;0, 1, 5&#125;</span></span><br></pre></td></tr></table></figure><p>在此代码中，<code>a.erase(a.lower_bound(2), a.upper_bound(4));</code> 会<strong>删除 set 中所有满足 2 ≤ x ≤ 4 的元素</strong>，使得区间变为 [2, 4]，即<strong>闭区间</strong>。</p><h3 id="set增删改查总结"><a href="#set增删改查总结" class="headerlink" title="set增删改查总结"></a>set增删改查总结</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>实现方法</strong></th></tr></thead><tbody><tr><td>增</td><td>a.insert(x)</td></tr><tr><td>删</td><td>a.erase(x)  或者  a.erase(a.find(x))</td></tr><tr><td>改</td><td>一旦插入就无法修改，只能先删再增</td></tr><tr><td>查</td><td>a.find(x)  !&#x3D; a.end() 或者  a.count(x)</td></tr></tbody></table><p>可以看到没有直接的修改，为什么？</p><p>正如上面提到的，set内部是需要排序的，如果你直接修改某个元素，就会破坏顺序</p><h3 id="set-的遍历"><a href="#set-的遍历" class="headerlink" title="set()的遍历"></a><code>set()</code>的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; b= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始结合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    <span class="type">int</span> value = *it;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历方法和vector一样，只需要背板上面的操作。我们需要讨论的是这种设计的思想是什么。</p><h4 id="从c语言指针到迭代器"><a href="#从c语言指针到迭代器" class="headerlink" title="从c语言指针到迭代器"></a>从c语言指针到迭代器</h4><p>上一张我们提到，迭代器就是在<strong>模仿</strong> C 语言指针。</p><p>回想一下 C 语言咋遍历数组的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> value = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的范围是 [0, n)。</p><p>因为这里 arr[i] 等价于 *(arr + i)，所以索性用 arr + i 作为迭代的变量，避免一次加法的开销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *p = arr; p &lt; arr + n;p++)&#123;</span><br><span class="line">    <span class="type">int</span> value = *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的范围变成 [arr, arr + n)。</p><p>n 总是大于 0 的。p 的初值 arr 总是小于末值 arr + n，所以把 <code>p &lt; arr + n</code> 改成 <code>p != arr + n</code> 是一样的，还高效一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *p = arr; p != arr + n; p++) &#123;</span><br><span class="line">  <span class="type">int</span> value = *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们提过建议用<strong>前置 ++</strong> 运算符，区别我们上一篇说过（后置++先保存变量用于返回，再原地自增）。前置比较高效且符合逻辑，后置对 C 语言八股文考试有用（个人拙见）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *p = arr; p &lt; arr + n;++p)&#123;</span><br><span class="line">    <span class="type">int</span> value = *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，到了这一步c++的<strong>迭代器模式</strong>也就呼之欲出了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator p = arr.<span class="built_in">begin</span>(); p != arr.<span class="built_in">end</span>(); ++p) &#123;</span><br><span class="line">  <span class="type">int</span> value = *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>begin 和 end 返回了迭代器类，这个类具有运算符重载，使得他能模仿指针的行为，从而尽可能在不同容器之间重用算法（例如 std::find 和 std::reverse），而不必修改算法的代码本身，是 STL 库解耦思想的体现。</p><h4 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h4><p>为了减少重复打代码的痛苦，C++11 引入了个语法糖：<strong>基于范围的for循环</strong>(range-based for loop)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (类型 变量名 : 可迭代对象)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value: b) &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合 : &#123;0,1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这种写法，无非就是刚才那一大堆代码的简写。</p><p>基于范围的 for 循环只是一个简写，他会遍历整个区间 [begin, end)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">lower_bound</span>(<span class="number">2</span>); it != b.<span class="built_in">upper_bound</span>(<span class="number">4</span>); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> value = *it;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0,1,3,4,5&#125;</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>有时写完整版会有更大的自由度，也就是说这里的 begin 和 end 可以替换为其他位置的迭代器（如 find&#x2F;lower_bound&#x2F;upper_bound）</p><p>比如用 lower_bound 和 upper_bound 返回的迭代器，选择满足 <code>2 ≤ x ≤ 4</code> 的元素来打印。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(b.lower_bound(<span class="number">2</span>), b.upper_bound(<span class="number">4</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;结果数组：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0, 1, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 结果数组：&#123;3, 4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="set-和其他容器之间的转换"><a href="#set-和其他容器之间的转换" class="headerlink" title="set 和其他容器之间的转换"></a>set 和其他容器之间的转换</h3><p>我们说过 <strong>vector 的构造函数</strong>也能接受两个前向迭代器作为参数，set 的迭代器符合这个要求。</p><ul><li><p><code>template &lt;class ForwardIt&gt;</code></p><p><code>explicit vector(ForwardIt beg, ForwardIt end);</code></p></li><li><p>没错，vector 的构造函数可以接受任何前向迭代器。不一定是 vector 自己的迭代器哦，任何前向迭代器！</p></li><li><p>而 set 是双向迭代器，覆盖了前向迭代器，满足要求。</p></li></ul><p>所以可以把 set 中的一个区间（<strong>2 ≤ x ≤ 4</strong>）拷贝到 vector 中去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;结果数组：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;0, 1, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 结果数组：&#123;0, 1, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><p>相当于过滤出所有 <strong>2 ≤ x ≤ 4</strong> 的元素了。</p><p>如果是 <code>vector(b.begin(),b.end())</code>那就毫无保留地把 set 的全部元素都拷贝进 vector 了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;结果集合：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以反过来，把 vector 转成 set。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(ForwardIt beg, ForwardIt end)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(arr.begin(), arr.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;结果集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始数组：&#123;9, 8, 5, 2, 1, 1&#125;</span></span><br><span class="line"><span class="comment">// 结果集合：&#123;1, 2, 5, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><h5 id="set的妙用：排序"><a href="#set的妙用：排序" class="headerlink" title="set的妙用：排序"></a>set的妙用：排序</h5><p><em>请先忘掉<code>std::sort()</code>（bushi</em></p><p>把 vector 转成 set 会让元素自动<strong>排序</strong>和<strong>去重</strong>。</p><p>我们其实可以利用这一点，把 vector 转成 set 再转回 vector，这样就实现去重了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(arr.begin(), arr.end())</span></span>;</span><br><span class="line">    arr.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序&amp;去重后的数组：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始数组：[9, 8, 5, 2, 1, 1]</span></span><br><span class="line"><span class="comment">// 排序&amp;去重后的数组：[1, 2, 5, 8, 9]</span></span><br></pre></td></tr></table></figure><p>当然这个操作是远不如<code>std::sort</code>效率高，只有偶尔的场景可能遇到。</p><h3 id="清空set所有元素"><a href="#清空set所有元素" class="headerlink" title="清空set所有元素"></a>清空set所有元素</h3><p>如下，清空set有三种方式</p><ul><li><code>b = &#123;&#125;;</code></li><li><code>b.erase(b.begin(), b.end());</code></li><li><code>b.clear();</code></li></ul><p>最常用的是调用 clear 函数。</p><p>这和 vector 的 clear 函数名字是一样的，方便记忆，也是STL的设计哲学。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// b = &#123;&#125;;</span></span><br><span class="line">    <span class="comment">// b.erase(b.begin(), b.end());</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;清空后集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 清空后集合：&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="set的大小（元素个数）"><a href="#set的大小（元素个数）" class="headerlink" title="set的大小（元素个数）"></a>set的大小（元素个数）</h3><p>和 vector 一样，set 也有个 size() 函数查询其中元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;元素个数：&quot;</span> &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 元素个数：5</span></span><br></pre></td></tr></table></figure><h2 id="multiset：set的不去重版本"><a href="#multiset：set的不去重版本" class="headerlink" title="multiset：set的不去重版本"></a>multiset：set的不去重版本</h2><h3 id="不去重的set"><a href="#不去重的set" class="headerlink" title="不去重的set"></a>不去重的set</h3><p>set 具有<strong>自动排序，自动去重，能高效地查询</strong>的特点。其中<strong>去重</strong>和数学的<strong>集合</strong>很像。</p><p>还有一种不会去重的版本，那就是 <code>multiset</code>，他允许重复的元素，但仍保留<strong>自动排序，能高效地查询</strong>的特点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> <span class="comment">// multiset的头文件也是set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// set: &#123;1 2 3&#125;</span></span><br><span class="line"><span class="comment">// multiset: &#123;1 1 2 2 3&#125;</span></span><br></pre></td></tr></table></figure><p>特点：因为 multiset <strong>不会去重</strong>，但又<strong>自动排序</strong>，所以其中所有相等的元素都会紧挨着，例如 {1, 2, 2, 4, 6}。</p><h3 id="查找multiset中的等值区间"><a href="#查找multiset中的等值区间" class="headerlink" title="查找multiset中的等值区间"></a>查找multiset中的等值区间</h3><p>刚刚说了 multiset 里相等的元素都是紧挨着排列的。</p><p>所以可以用 upper_bound 和 lower_bound 函数获取所有相等值的区间，并进行相应操作。</p><p>[lower_bound, upper_bound)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(b.<span class="built_in">lower_bound</span>(<span class="number">2</span>), b.<span class="built_in">upper_bound</span>(<span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除2以后：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 1, 2, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 删除2以后：&#123;1, 1, 3&#125;</span></span><br></pre></td></tr></table></figure><p>对于 lower_bound 和 upper_bound 的参数相同的情况，可以用 <strong>equal_range</strong> 一次性求出两个边界，获得等值区间，更高效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> r = b.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line">    b.<span class="built_in">erase</span>(r.first, r.second);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除2以后：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 1, 2, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 删除2以后：&#123;1, 1, 3&#125;</span></span><br></pre></td></tr></table></figure><p>equal_range（等值区间）和调用两次 lower_bound（大于等于起点）upper_bound（大于起点）的不同：</p><ul><li><p>当指定的值找不到时，equal_range 返回两个 end() 迭代器，代表空区间。</p></li><li><p>lower&#x2F;upper_bound 却会正常返回指向大于等于&#x2F;大于指定值的迭代器。</p></li></ul><p>原因：equal_range 的用途都是返回一个用来遍历的区间，两个迭代器是一起用的，不会单独用。所以为了高效，找不到等值元素会直接返回空区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> r = b.<span class="built_in">equal_range</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; boolalpha; <span class="comment">// 输出bool值时，用true和false而不是1和0</span></span><br><span class="line">    cout &lt;&lt; (r.first == b.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (r.second == b.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1,1,2,2,3&#125;</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>equal_range 返回的等值区间，可以求长度，也可以遍历。</p><ul><li><p>对 multiset 而言遍历似乎没什么用，反正都是一堆相等的元素。</p></li><li><p>求长度也没什么用，可以用 count 替代，总之就是非常尴尬。</p></li></ul><p>但之后说到 multimap 的时候这个函数就会很有用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> r = b.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">size_t</span> n = std::<span class="built_in">distance</span>(r.first, r.second);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等于2的元素个数：&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = r.first; it != r.second; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> value = *it;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 1, 2, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 等于2的元素个数：2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="删除-multiset-中的等值元素"><a href="#删除-multiset-中的等值元素" class="headerlink" title="删除 multiset 中的等值元素"></a>删除 multiset 中的等值元素</h3><p>erase 只有一个参数的版本，会把所有等于 2 的元素删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>例如：b.erase(2) 等价于b.erase(b.lower_bound(2), b.upper_bound(2));</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除2以后：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1, 1, 2, 2, 3, 2&#125;</span></span><br><span class="line"><span class="comment">// 删除2以后：&#123;1, 1, 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="multiset中等值元素个数"><a href="#multiset中等值元素个数" class="headerlink" title="multiset中等值元素个数"></a>multiset中等值元素个数</h3><p>count(x) 返回 multiset 中等于 x 的元素个数（如果找不到则返回 0）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp;val)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等于2的元素个数：&quot;</span> &lt;&lt; b.<span class="built_in">count</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等于1的元素个数：&quot;</span> &lt;&lt; b.<span class="built_in">count</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1,1,1,2,2,3&#125;</span></span><br><span class="line"><span class="comment">// 等于2的元素个数：2</span></span><br><span class="line"><span class="comment">// 等于1的元素个数：3</span></span><br></pre></td></tr></table></figure><ul><li>刚刚说 set（具有去重功能）的 count 只会返回 0 或 1。而 multiset（没有去重功能）的 count 可以返回任何 ≥ 0 的数。</li></ul><h3 id="multiset-中的find-函数"><a href="#multiset-中的find-函数" class="headerlink" title="multiset 中的find()函数"></a>multiset 中的<code>find()</code>函数</h3><p>multiset 允许多个重复的元素存在，那么 find 会返回哪一个？第一个！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始集合：&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集合中存在2：&quot;</span> &lt;&lt; (b.<span class="built_in">find</span>(<span class="number">2</span>) != b.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集合中存在1：&quot;</span> &lt;&lt; (b.<span class="built_in">find</span>(<span class="number">1</span>) != b.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个1在头部：&quot;</span> &lt;&lt; (b.<span class="built_in">find</span>(<span class="number">1</span>) == b.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原始集合：&#123;1,1,1,2,2,3&#125;</span></span><br><span class="line"><span class="comment">// 集合中存在2：true</span></span><br><span class="line"><span class="comment">// 集合中存在1：true</span></span><br><span class="line"><span class="comment">// 第一个1在头部：true</span></span><br></pre></td></tr></table></figure><p>find(x) 会返回第一个等于 x 的元素的迭代器。找不到也是返回 end()</p><h3 id="multiset增删改查操作总结"><a href="#multiset增删改查操作总结" class="headerlink" title="multiset增删改查操作总结"></a>multiset增删改查操作总结</h3><table><thead><tr><th align="left"><strong>操作</strong></th><th align="left"><strong>实现方法</strong></th></tr></thead><tbody><tr><td align="left">增</td><td align="left">a.insert(x)</td></tr><tr><td align="left">删</td><td align="left">a.erase(x)  或者  a.erase(a.lower_bound(x), a.upper_bound(x))</td></tr><tr><td align="left">改</td><td align="left">一旦插入就无法修改，只能先删再增</td></tr><tr><td align="left">查</td><td align="left">a.find(x)  !&#x3D; a.end() 或者  a.count(x)</td></tr></tbody></table><p>依旧没有直接的修改操作，原因与set容器相同。</p><h2 id="unordered-set-无序集合"><a href="#unordered-set-无序集合" class="headerlink" title="unordered_set 无序集合"></a>unordered_set 无序集合</h2><p>C++11 新增了一个 <code>unordered_set</code> 容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unordered_set: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// set: &#123;1, 2, 4, 5, 7, 8&#125;</span></span><br><span class="line"><span class="comment">// unordered_set: &#123;7, 5, 8, 2, 4, 1&#125;</span></span><br></pre></td></tr></table></figure><p><code>set</code> 会让元素从小到大排序，而 <code>unordered_set</code> <strong>不会排序</strong>，里面的元素都是<strong>完全随机的顺序</strong>，与插入的顺序也不一样。</p><ul><li>虽然你可能观察到有时刚好与插入的顺序相反，但这只是巧合，具体顺序与 glibc 实现有关。</li></ul><p><code>set</code> 基于红黑树实现，相当于二分查找树；而 <code>unordered_set</code> 基于散列哈希表实现，正是哈希函数导致了随机的顺序。</p><h2 id="set-系列成员函数总结"><a href="#set-系列成员函数总结" class="headerlink" title="set 系列成员函数总结"></a>set 系列成员函数总结</h2><table><thead><tr><th><strong>函数</strong></th><th><strong>含义</strong></th><th><strong>set</strong></th><th><strong>multiset</strong></th><th><strong>unordered_set</strong></th></tr></thead><tbody><tr><td>insert(x)</td><td>插入一个元素 x</td><td>√</td><td>√</td><td>√</td></tr><tr><td>erase(x)</td><td>删除所有等于 x 的元素</td><td>√</td><td>√</td><td>√</td></tr><tr><td>count(x)</td><td>有多少个等于 x 的元素</td><td>√（0或1）</td><td>√</td><td>√（0或1）</td></tr><tr><td>find(x)</td><td>指向第一个等于 x 的元素</td><td>√</td><td>√</td><td>√</td></tr><tr><td>lower_bound(x)</td><td>指向第一个大于等于 x 的元素</td><td>√</td><td>√</td><td>×</td></tr><tr><td>upper_bound(x)</td><td>指向第一个大于 x 的元素</td><td>√</td><td>√</td><td>×</td></tr><tr><td>equal_range(x)</td><td>所有等于 x 的元素所组成的区间</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="不同版本的-set-容器比较"><a href="#不同版本的-set-容器比较" class="headerlink" title="不同版本的 set 容器比较"></a>不同版本的 set 容器比较</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>去重</strong></th><th><strong>有序</strong></th><th><strong>查找</strong></th><th><strong>插入</strong></th></tr></thead><tbody><tr><td>vector</td><td>×</td><td>×</td><td>O(n)</td><td>O(1) ~ O(n)</td></tr><tr><td>set</td><td>√</td><td>√</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multiset</td><td>×</td><td>√</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_set</td><td>√</td><td>×</td><td>O(1)</td><td>O(1)</td></tr><tr><td>unordered_multiset</td><td>×</td><td>×</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th><strong>类型</strong></th><th><strong>头文件</strong></th><th><strong>lower&#x2F;upper_bound</strong></th><th><strong>equal_range</strong></th><th><strong>find</strong></th></tr></thead><tbody><tr><td>vector</td><td><code>&lt;vector&gt;</code></td><td>√，O(logn)</td><td>√，O(logn)</td><td>√，O(n)</td></tr><tr><td>set</td><td><code>&lt;set&gt;</code></td><td>√，O(logn)</td><td>√，O(logn)</td><td>√，O(logn)</td></tr><tr><td>multiset</td><td><code>&lt;set&gt;</code></td><td>√，O(logn)</td><td>√，O(logn)</td><td>√，O(logn)</td></tr><tr><td>unordered_set</td><td><code>&lt;unordered_set&gt;</code></td><td>×，因为是无序的</td><td>√，O(1)</td><td>√，O(1)</td></tr><tr><td>unordered_multiset</td><td><code>&lt;unordered_set&gt;</code></td><td>×，因为是无序的</td><td>√，O(1)</td><td>√，O(1)</td></tr></tbody></table><p><code>vector</code> 适合按<strong>索引</strong>查找，通过运算符 <code>[]</code>。</p><p><code>set</code> 适合按<strong>值相等</strong>查找，以及按<strong>值大于&#x2F;小于</strong>查找，分别通过函数 <code>find</code>、<code>lower_bound</code> 和 <code>upper_bound</code>。</p><p><code>unordered_set</code> 只适合按<strong>值相等</strong>查找，通过函数 <code>find</code>。</p><p>小贴士：<code>unordered_set</code> 的性能在数据量足够大（&gt;1000）时，平均查找时间比 <code>set</code> 短，但不保证稳定。</p><p>我个人推荐使用久经考验的 <code>set</code>，在数据量小时更高效。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解STL-前言</title>
      <link href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/"/>
      <url>/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p><p>STL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p><p>使用 STL 的好处:</p><ul><li><strong>代码复用</strong>：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li><li><strong>性能优化</strong>：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li><li><strong>泛型编程</strong>：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li><li><strong>易于维护</strong>：STL 的设计使得代码更加模块化，易于阅读和维护。</li></ul><p>C++ 标准模板库的核心包括以下重要组件组件：</p><table><thead><tr><th align="center">组件</th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">容器（Containers）</td><td align="left">容器是 STL 中最基本的组件之一，提供了各种数据结构，包括向量（vector）、链表（list）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器。</td></tr><tr><td align="center">算法（Algorithms）</td><td align="left">STL 提供了大量的算法，用于对容器中的元素进行各种操作，包括排序、搜索、复制、移动、变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</td></tr><tr><td align="center">迭代器（iterators）</td><td align="left">迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL 提供了多种类型的迭代器，包括随机访问迭代器、双向迭代器、前向迭代器和输入输出迭代器等。</td></tr><tr><td align="center">函数对象（Function Objects）</td><td align="left">函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL 提供了多种函数对象，包括一元函数对象、二元函数对象、谓词等，可以满足不同的需求。</td></tr><tr><td align="center">适配器（Adapters）</td><td align="left">适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL 提供了多种适配器，包括栈适配器（stack adapter）、队列适配器（queue adapter）和优先队列适配器（priority queue adapter）等。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解STL-vector容器与迭代器入门</title>
      <link href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="显式构造"><a href="#显式构造" class="headerlink" title="显式构造"></a>显式构造</h4><h5 id="指定一个参数-explicit-vector-size-t-n"><a href="#指定一个参数-explicit-vector-size-t-n" class="headerlink" title="指定一个参数 explicit vector(size_t n)"></a>指定一个参数 <code>explicit vector(size_t n)</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>vector 的功能是长度可变的数组，他里面的数据存储在堆上。</p><ul><li><p>使用<code>sizeof(vector)</code>会得到vector的大小是24，即三个指针的大小</p></li><li><p>第一个指针指向堆上内存的起始地址</p></li><li><p>第二个指针标志着有效元素结束位置</p></li><li><p>第三个指针指向分配给<code>vector</code>的总容量位置，表示<code>vector</code>可以存储多少元素而不需要重新分配内存</p></li></ul><p>vector 是一个模板类，第一个模板参数是数组里元素的类型。</p><p>例如，声明一个元素是 int 类型的动态数组 a：<code>vector&lt;int&gt; a;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure><p>vector 可以在构造时指定初始长度。</p><p>例如，要创建一个长度为 4 的 int 型数组：<code>vector&lt;int&gt; a(4);</code></p><p>之后可以通过 a.size() 获得数组的长度。比如上面的代码会得到 4。</p><p><strong>另外：</strong></p><ul><li><p>vector 的这个显式构造函数，默认会把所有元素都初始化为 0（不必手动去 memset）。</p></li><li><p>•如果是其他自定义类，则会调用元素的默认构造函数（例如：数字类型会初始化为 0，string 会初始化为空字符串，指针类型会初始化为 nullptr）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span><span class="comment">//自定义打印，详见本节小技巧</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="指定两个参数-explicit-vector-size-t-n-int-const-val"><a href="#指定两个参数-explicit-vector-size-t-n-int-const-val" class="headerlink" title="指定两个参数 explicit vector(size_t n, int const &amp;val)"></a>指定两个参数 <code>explicit vector(size_t n, int const &amp;val)</code></h5><p>这个显式构造函数还可以指定第二个参数，这样就可以用 0 以外的值初始化整个数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">233</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure><p>比如要创建 4 个 233 组成的数组就可以写：</p><p><code>vector&lt;int&gt; a(4, 233);</code></p><p>等价于</p><p><code>vector&lt;int&gt; a = &#123;233, 233, 233, 233&#125;;</code></p><h4 id="初始化列表构造"><a href="#初始化列表构造" class="headerlink" title="初始化列表构造"></a>初始化列表构造</h4><p><code>vector(initializer_list&lt;int&gt; list);</code></p><p>除了先指定大小再一个个构造之外，还可以直接利用初始化列表（C++11 新特性）在构造时就初始化其中元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如创建具有 6, 1, 7, 4 四个元素的 vector：</p><p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p><p>和刚刚先创建再赋值的方法相比更直观。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化表达式的<strong>等号</strong>可以写也可以不写：</p><p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p><p><code>vector&lt;int&gt; a&#123;6, 1, 7, 4&#125;;</code></p><p>都是等价的。</p><p><strong>注意，</strong>这意味着如果用花括号的 <code>&#123;4&#125; </code>初始化：</p><p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p><p>会得到长度为 1 只有一个元素 4 的数组。</p><p>如果需要长度为 4，元素全部为 0 的数组，必须用圆括号<code> ()</code> 而不是花括号 <code>&#123;&#125;</code>，这样才能保证调用他的显式<code>（explicit）</code>构造函数：</p><p><code>vector&lt;int&gt; a(4);</code></p><p>会得到长度为 4 元素全为 0 的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 4</span></span><br><span class="line"><span class="comment">// a.size() = 1</span></span><br></pre></td></tr></table></figure><p>这在对于<strong>只能用花括号初始化</strong>的类成员来说，就有很大问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p><p>会得到长度为 1 只有一个元素 4 的数组。</p><p>但还是可以用这种写法强制调用显式构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vector&lt;int&gt; a = vector&lt;int&gt;(4);</code></p><p>会得到长度为 4 元素全为 0 的数组。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>添加一个运算符重载用于打印 vector 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, vector&lt;T&gt; <span class="type">const</span> &amp;v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        os &lt;&lt; *it;</span><br><span class="line">        <span class="keyword">for</span> (++it; it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; *it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><p><code>int &amp;operator[](size_t i) noexcept;</code></p><p><code>int const &amp;operator[](size_t i) const noexcept;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br></pre></td></tr></table></figure><p>要访问 vector 里的元素，只需用 [] 运算符：</p><ul><li><p>例如 a[0] 访问第 0 个元素（人类的第一个）</p></li><li><p>例如 a[1] 访问第 1 个元素（人类的第二个）</p></li></ul><p><strong>值得注意</strong>的是，<code>[]</code> 运算符在索引超出数组大小时并不会直接报错，这是为了性能的考虑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1000] = &quot;</span> &lt;&lt; a[<span class="number">1000</span>] &lt;&lt; endl;<span class="comment">// 越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br><span class="line"><span class="comment">//a[100] = 0//越界访问</span></span><br></pre></td></tr></table></figure><p>如果你不小心用<code> []</code>访问了越界的索引，可能会覆盖掉别的变量导致程序行为异常，或是访问到操作系统未映射的区域导致奔溃。</p><h3 id="at-函数"><a href="#at-函数" class="headerlink" title="at()函数"></a><code>at()</code>函数</h3><p><code>int &amp;at(size_t i);</code></p><p><code>int const &amp;at(size_t i) const;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(0) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(2) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(3) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1000) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1000</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a.at(0) = 0</span></span><br><span class="line"><span class="comment">// a.at(1) = 0</span></span><br><span class="line"><span class="comment">// a.at(2) = 0</span></span><br><span class="line"><span class="comment">// a.at(3) = 0</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"><span class="comment">//   what():  vector::_M_range_check: __n (which is 1000) &gt;= this-&gt;size() (which is 4)</span></span><br></pre></td></tr></table></figure><p>为了防止不小心越界，可以用 <code>a.at(i)</code> 替代 <code>a[i]</code>，&#96;&#96;at<code> 函数会检测索引 i 是否越界，如果他发现索引</code> i &gt;&#x3D; a.size() <code>则会抛出异常 </code>std::out_of_range<code>让程序提前终止（或者被</code>try-catch &#96;捕获），配合任意一款调试器，就可以很快速地定位到出错点。</p><p>不过 <code>at</code> 需要额外检测下标是否越界，虽然更安全方便调试，但和 <code>[]</code> 相比有一定性能损失。</p><ul><li>上面只演示了读取操作，当然可以使用<code>[]</code>和<code>at</code>进行写入操作</li></ul><h3 id="resize-函数"><a href="#resize-函数" class="headerlink" title="resize()函数"></a><code>resize()</code>函数</h3><p><code>void resize(size_t n);</code></p><p>除了可以在构造函数中指定数组的大小，还可以之后再通过 resize 函数设置大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure><p>这在无法一开始就指定大小的情况下非常方便。</p><p>当然，resize 也有一个接受第二参数的重载，他会用这个参数的值填充所有新建的元素。</p><p><code>void resize(size_t n, int const &amp;val);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure><p>调用 resize(n) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用</strong> <strong>0</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p><p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p><p><code>a.resize(4);</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 0, 0&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,0,0&#125;</span></span><br></pre></td></tr></table></figure><p>调用 <code>resize(n)</code> 的时候，如果数组已有超过 n 个元素，假设是 m 个，则他<strong>会删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p><p><code>a.resize(4);</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>调用第二个重载 resize(n, val) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用第二个参数</strong> <strong>val</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p><p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p><p><code>a.resize(4, 233);</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 233, 233&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,233,233&#125;</span></span><br></pre></td></tr></table></figure><p>调用第二个重载 resize(n, val) 的时候，如果数组已有超过 n 个元素，假设是 m 个，则第二参数 val 会被<strong>无视</strong>，<strong>删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p><p><code>a.resize(4, 233);</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a><code>clear()</code>函数</h3><p><code>void clear() noexcept</code></p><p>vector 的 clear 函数可以<strong>清空该数组</strong>，也就相当于把长度设为零，变成空数组。例如：</p><p><code>a.clear();</code></p><p>等价于：</p><p><code>a.resize(0);  或  a = &#123;&#125;;</code></p><p>通常用于后面需要重新 push_back，因此可以 clear 来把数组设为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>clear配合resize</strong></p><p>resize 会保留原数组的前面部分不变，只在后面填充上 0。(具有一定软弱性)</p><p>如果需要把原数组前面的部分也填充上 0，可以<strong>先</strong> <strong>clear</strong> <strong>再</strong> <strong>resize</strong>，这是一个常见的组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a><code>push_back()</code>函数</h3><p><code>void push_back(int const &amp;val);</code></p><p><code>void push_back(int &amp;&amp;val); // C++11 新增</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p>可以<strong>在数组的末尾追加</strong>一个数。例如：</p><p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p><p><code>a.push_back(3);</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p><h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a><code>pop_back()</code>函数</h3><p><code>void pop_back() noexcept</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure><p>pop_back 函数则是和 push_back 唱反调，他是<strong>在数组的末尾删除</strong>一个数。例如：</p><p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p><p><code>a.pop_back();</code></p><p>等价于：</p><p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p><h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a><code>back()</code>函数</h3><p><code>int &amp;back() noexcept;</code></p><p><code>int const &amp;back() const noexcept</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> val = a.<span class="built_in">back</span>();</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//back = 3</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure><p>要注意的是 <code>pop_back</code> 函数的返回类型是 <code>void</code>，也就是没有返回值，如果需要获取删除的值，可以在 <code>pop_back()</code> 之前先通过 <code>back()</code> <strong>获取末尾元素的值</strong>，实现 pop 效果。</p><p><code>a.back();</code></p><p>等价于：</p><p><code>a[a.size() - 1]</code></p><h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a><code>front()</code>函数</h3><p><code>int &amp;front() noexcept;</code></p><p><code>int const &amp;front() const noexcept;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[a.size() - 1] = &quot;</span> &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.front() = &quot;</span> &lt;&lt; a.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.back() = &quot;</span> &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 1</span></span><br><span class="line"><span class="comment">// a[a.size() - 1] = 3</span></span><br><span class="line"><span class="comment">// a.front() = 1</span></span><br><span class="line"><span class="comment">// a.back() = 3</span></span><br></pre></td></tr></table></figure><p>和 <code>back()</code> 相对的还有一个 <code>front()</code>。</p><p><code>back()</code> 返回<strong>末尾元素</strong>的引用 <code>a[a.size() - 1]</code>。</p><p>而 <code>front()</code> 返回<strong>首个元素</strong>的引用 <code>a[0]</code>。</p><p><code>a.front();</code></p><p>等价于：</p><p><code>a[0]</code></p><h3 id="data-获取首地址指针"><a href="#data-获取首地址指针" class="headerlink" title="data()获取首地址指针"></a><code>data()</code>获取首地址指针</h3><p><code>int *data() noexcept;</code></p><p><code>int const *data() const noexcept;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//int n = a.size();</span></span><br><span class="line">    <span class="comment">//memset(p, -1, sizeof(int) * n);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>data() 会返回指向数组中<strong>首个元素的指针</strong>，也就是等价于 &amp;a[0]。由于 vector 是连续存储的数组，因此只要得到了首地址，下一个元素的地址只需指针 +1 即可。</p><p>因为指针的 p[i] 相当于 *(p + i)，因此可以把 data() 返回的首地址指针当一个数组来访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;-1,-1,-1,-1,-1&#125;</span></span><br></pre></td></tr></table></figure><p>data() 返回的<strong>首地址指针</strong>，通常配合 size() 返回的<strong>数组长度</strong>一起使用（连续的动态数组只需要知道首地址和数组长度即可完全确定）。</p><p>用他来获取一个 C 语言原始指针 int *，很方便用于调用 C 语言的函数和 API 等，同时还能享受到 vector 容器 RAII 的安全性。</p><h3 id="RAII思想避免内存泄露"><a href="#RAII思想避免内存泄露" class="headerlink" title="RAII思想避免内存泄露"></a>RAII思想避免内存泄露</h3><p>RAII: 资源获取即初始化，使用局部对象来管理资源的技术称为资源获取即初始化。利用栈对象自动销毁的特点来实现，<strong>通过构造函数获取资源，通过析构函数释放资源</strong>。</p><p>如果用 new&#x2F;delete 或者 malloc&#x2F;free 就很容易出现忘记释放内存的情况，造成内存泄露。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pixels = <span class="keyword">new</span> <span class="type">char</span>[camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>];<span class="comment">//使用new</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels));</span><br><span class="line"><span class="keyword">delete</span> pixels;<span class="comment">//容易忘记释放</span></span><br></pre></td></tr></table></figure><p>而 vector 会在离开作用域时，自动调用解构函数，释放内存，就不必手动释放了，更安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">pixels</span><span class="params">(camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>)</span></span>;<span class="comment">//使用vector</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels.<span class="built_in">data</span>()));<span class="comment">//通过.data配合c语言操作</span></span><br><span class="line"><span class="comment">//vector离开作用域时，自动释放，.data获取的指针也会失效</span></span><br></pre></td></tr></table></figure><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>C++ 中最神奇的运算符 <code>&#125;</code></p><p> <code>&#125;</code> 标志着一个语句块的结束，在这里，他会调用所有身处其中的对象的解构函数。比如这里的 <code>vector</code>，他的解构函数会释放动态数组的内存（即自动 delete）。</p><p><code>vector</code> 会在退出作用域时释放内存，这时候所有指向其中元素的指针，包括 <code>data()</code> 都会失效。因此如果你是在语句块内获取的 <code>data()</code> 指针，语句块外就无法访问了。</p><p>可见 <code>data()</code> 指针是对 <code>vector</code> 的一种引用，实际对象生命周期仍由 <code>vector</code> 类本身管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021无效数</span></span><br></pre></td></tr></table></figure><h4 id="延续生命周期"><a href="#延续生命周期" class="headerlink" title="延续生命周期"></a>延续生命周期</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt; holder;//全局变量，main退出释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; holder;<span class="comment">//与p生命周期相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        holder = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>如果需要在一个语句块外仍然保持 data() 对数组的弱引用有效，可以把语句块内的 vector 对象移动到外面的一个 vector 对象上。vector 在移动时指针不会失效，例如：</p><p><code>a = move(b)</code></p><p>则会把 b 变成空数组，a 指向原来 b 所包含的元素数组，且地址不变。</p><p>之后即使不直接使用外面的那个临时对象 a，也可以继续通过 data() 指针来访问数据。</p><p>也可以移动到一个全局变量的 vector 对象。这样数组就会一直等到 main 退出了才释放。</p><ul><li>C++ 规定全局变量都会在进入 main 函数<strong>之前</strong>构造，main 函数返回之后解构</li></ul><h3 id="resize-和内存管理"><a href="#resize-和内存管理" class="headerlink" title="resize()和内存管理"></a><code>resize()</code>和内存管理</h3><h4 id="resize到更大尺寸会导致data失效"><a href="#resize到更大尺寸会导致data失效" class="headerlink" title="resize到更大尺寸会导致data失效"></a>resize到更大尺寸会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">1024</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021</span></span><br></pre></td></tr></table></figure><p>当 resize 的目标长度<strong>大于</strong>原有的容量时，就需要<strong>重新分配一段更大的连续内存</strong>，并把<strong>原数组长度的部分移动过去</strong>，多出来的部分则用 0 来填充。这就导致元素的地址会有所改变，从而过去 data 返回的指针以及所有的迭代器对象，都会失效。</p><h4 id="resize到更小尺寸不会导致data失效"><a href="#resize到更小尺寸不会导致data失效" class="headerlink" title="resize到更小尺寸不会导致data失效"></a>resize到更小尺寸不会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当 resize 的目标长度<strong>小于</strong>原有的容量时，不需要重新分配一段连续的内存也不会造成元素的移动（这个设计是为了性能考虑），所以指向元素的指针不会失效。他只是会把数组的长度标记为新长度，后面<strong>空闲出来那一段内存不会释放掉</strong>，继续留在那里，直到 vector 对象被解构。</p><p><strong>重新resize到原来也不会导致data失效</strong></p><ul><li>调用了 a.resize(2) 之后，数组的<strong>容量</strong>仍然是 5，因此重新扩容到 5 是不需要重新分配内存的，也就不会移动元素导致指针失效。</li></ul><h4 id="capacity-函数查询实际的最大容量"><a href="#capacity-函数查询实际的最大容量" class="headerlink" title="capacity()函数查询实际的最大容量"></a><code>capacity()</code>函数查询实际的最大容量</h4><p><code>size_t capacity() const noexcept;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 7/10</span></span><br></pre></td></tr></table></figure><p>可以用 capacity() 函数查询已经分配内存的大小，即<strong>最大容量</strong>。</p><p>而 size() 返回的其实是已经存储了数据的<strong>数组长度</strong>。</p><p>可以发现当 resize 指定的新<strong>长度</strong>一个超过原来的最大<strong>容量</strong>时时，就会重新分配一段更大<strong>容量</strong>的内存来存储数组，只有这时才会移动元素的位置（data 指针失效）。</p><h4 id="resize-的优化策略"><a href="#resize-的优化策略" class="headerlink" title="resize()的优化策略"></a><code>resize()</code>的优化策略</h4><p>注意这里 resize(7) 之后容量实际上扩充到了 10 而不是刚好 7，为什么？</p><p>因为标准库的设计者非常聪明，他料想到了你 resize(7) 以后可能还会来个 resize(8) 甚至 resize(9) 之类的。为了减少重复分配的次数，他有一个策略：当 resize 后的新尺寸变化较小时，则<strong>自动扩容至原尺寸的两倍</strong>。</p><p>这里我们的原大小是 5，所以 resize(7) 会扩充<strong>容量</strong>到 10，但是<strong>尺寸</strong>为 7。</p><ul><li><p>尺寸总是小于等于容量。</p></li><li><p>尺寸范围内都是已初始化的内存(零)。</p></li><li><p>寸到容量之间的范围是未初始化的。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 12/12</span></span><br></pre></td></tr></table></figure><p>不过如果 <code>resize</code> 后的尺寸还超过了原先尺寸的两倍，就没有这个效果了。</p><p>也就是说 <code>resize(n)</code> 的逻辑是扩容至 <code>max(n, capacity * 2)</code>。</p><h4 id="reserve-预留一定容量，避免之后重复分配"><a href="#reserve-预留一定容量，避免之后重复分配" class="headerlink" title="reserve()预留一定容量，避免之后重复分配"></a><code>reserve()</code>预留一定容量，避免之后重复分配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">12</span>);<span class="comment">//预留12</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 0x1a8d4b9eb90 5/5</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 2/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 12/12</span></span><br></pre></td></tr></table></figure><p>内存分配是需要一定时间的。如果我们程序员能预料到数组最终的大小，可以用 <code>reserve</code> 函数<strong>预留</strong>一定的容量，这样之后就不会出现容量不足而需要动态扩容影响性能了。</p><p>例如这里我们一开始预留了 12 格容量，这样从 5 到 12 的时候就不必重新分配。此外，还要注意 <code>reserve</code> 时也会移动元素。</p><h4 id="shrink-t0-fit-释放多余的容量"><a href="#shrink-t0-fit-释放多余的容量" class="headerlink" title="shrink_t0_fit()释放多余的容量"></a><code>shrink_t0_fit()</code>释放多余的容量</h4><p>刚刚说过，当 <code>resize</code> 到一个更小的大小上时，多余的容量不会释放，而是继续保留。如担心内存告急可以用 <code>shrink_to_fit</code> 释放掉多余的容量，只保留刚好为 size() 大小的容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 5/5</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 12/12</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 4/12</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 4/4</span></span><br></pre></td></tr></table></figure><p><code>shrink_to_fit</code> 会重新分配一段更小内存，他同样是会把元素移动到新内存中的，因此迭代器和指针也会失效。</p><h3 id="一个小工具：mallochook"><a href="#一个小工具：mallochook" class="headerlink" title="一个小工具：mallochook"></a>一个小工具：mallochook</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/sjp38/mallochook/blob/master/mallochook.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __unix__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">static</span> <span class="type">malloc_t</span> malloc_fn = (<span class="type">malloc_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc_fn</span>(size);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[32mmalloc(%zu) = %p\033[0m\n&quot;</span>, size, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">free_t</span> free_fn = (<span class="type">free_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[31mfree(%p)\033[0m\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free_fn</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了追踪所有的内存分配与释放，我们试着重写一下 malloc 和 free 函数。</p><p>这样当 vector 容器分配或是释放内存的时候，我们就能轻松看到。</p><p>不过这个只能 Linux 系统可以用哦</p><h3 id="puch-back-的问题"><a href="#puch-back-的问题" class="headerlink" title="puch_back()的问题"></a><code>puch_back()</code>的问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab167f12a0</span></span><br><span class="line"><span class="comment">// malloc(4) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// malloc(8) = 0xaaab16802ed0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ed0)</span></span><br><span class="line"><span class="comment">// malloc(32) = 0xaaab16802ef0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(64) = 0xaaab16802f20</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ef0)</span></span><br><span class="line"><span class="comment">// malloc(128) = 0xaaab16802f70</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f20)</span></span><br><span class="line"><span class="comment">// malloc(256) = 0xaaab16803000</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f70)</span></span><br><span class="line"><span class="comment">// malloc(512) = 0xaaab16803110</span></span><br><span class="line"><span class="comment">// free(0xaaab16803000)</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab16803320</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaab16803110)</span></span><br></pre></td></tr></table></figure><p>由于不知道你究竟会推入多少个元素，vector 的初始容量是零，而 push_back 和 resize 一样，每次遇到容量不足时，都会扩容两倍，例如上面的输出。</p><p>这也体现了<strong>实际容量</strong><code>(capacity)</code>和数组大小<code>(size)</code>分离的好处，如果死板地让分配的内存容量始终等于当前数组大小（很多同学都号称自己实现过 <code>vector</code>，都是这种写法），那么如果要用 push_back 推入 n 个元素，就需要重新分配内存 n 次，移动元素 n(n+1)&#x2F;2 次。</p><p>而像标准库这样允许数组大小和实际容量不同，这样 push_back 在容量不足的时候就可以一次性扩容两倍，只需重新分配 logn 次，移动元素 2n-1 次。</p><h4 id="解决：reserve"><a href="#解决：reserve" class="headerlink" title="解决：reserve()"></a>解决：<code>reserve()</code></h4><p>因此，如果你早就知道要推入元素的数量，可以调用 reserve 函数先预留那么多的<strong>容量</strong>，等待接下来的推入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 预留空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaaf6e992a0</span></span><br><span class="line"><span class="comment">// malloc(400) = 0xaaaaf6eaaeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaaf6eab050</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaaaf6eaaeb0)</span></span><br></pre></td></tr></table></figure><p>这样之后 push_back 时，就不会一次次地扩容两倍慢慢成长到 128，避免重新分配内存和移动元素，更高效。</p><p>比如这里我们可以提前知道循环会执行 100 次，因此 reserve(100) 就可以了。</p><p>可以看到只有一次 malloc(400)，之后那次 malloc(1024) 是 cout 造成的，不必在意。</p><h3 id="clear-的问题"><a href="#clear-的问题" class="headerlink" title="clear()的问题"></a><code>clear()</code>的问题</h3><p>刚刚说过，<code>clear</code> 相当于 <code>resize(0)</code>，所以他也不会实际释放掉内存，**容量(capacity)<strong>还是摆在那里，clear 仅仅只是把</strong>数组大小(size)**标记为 0 而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaae7f4d2a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaaae7f5eeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaae7f5eed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// after clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaaae7f5eeb0)</span></span><br></pre></td></tr></table></figure><p>这可能导致在低端平台上内存告急，这是因为尽管你已经 clear 掉 vector 了而实际容量还在并没有释放。</p><h4 id="解决：shrink-to-fit"><a href="#解决：shrink-to-fit" class="headerlink" title="解决：shrink_to_fit()"></a>解决：<code>shrink_to_fit()</code></h4><p>要真正释放掉内存，可以在 clear 之后再调用 shrink_to_fit，这样才会让容量也变成 0（这时 vector 的 data 会返回 nullptr）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab077092a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab0771aeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab0771aed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaab0771aeb0)</span></span><br><span class="line"><span class="comment">// after clear, capacity=0</span></span><br></pre></td></tr></table></figure><p>当然，vector 对象解构时也会彻底释放内存，这个不用操心。clear 配合 shrink_to_fit 只是提前释放而已。</p><h2 id="迭代器入门"><a href="#迭代器入门" class="headerlink" title="迭代器入门"></a>迭代器入门</h2><h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><h4 id="迭代器结构的出现"><a href="#迭代器结构的出现" class="headerlink" title="迭代器结构的出现"></a>迭代器结构的出现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">char</span>&gt; <span class="type">const</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道，可以使用一个函数来封装打印操作，但是这样的缺点是它智能打印<code>vector</code>类型，没法打印<code>string</code>类型，要想支持<code>string</code>只能再实现另一个<code>print</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>());</span><br><span class="line">    string b = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(b.<span class="built_in">data</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>vector</code> 和 <code>string</code> 的底层都是连续的稠密数组，他们都有 <code>data()</code> 和 <code>size()</code> 函数。</p><p>因此可改用<strong>首地址指针</strong>和<strong>数组长度</strong>做参数：</p><p><code>print(char const *a, size_t n);</code></p><p>这样 <code>print</code> 在无需知道容器具体类型的情况下，只用最简单的接口（首地址指针）就完成了遍历和打印的操作。</p><p>使用<strong>指针</strong>和<strong>长度</strong>做接口的好处是，可以通过给指针加减运算，选择其中一部分连续的元素来打印，而不一定全部打印出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如这里我们选择打印<strong>前三个元素</strong>（去掉了最后一个元素，但不必用 <code>pop_back</code> 修改数组，只要传参数的时候修改一下<strong>长度</strong> 部分即可）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>() + <span class="number">1</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择打印<strong>后三个元素</strong>（去掉了第一个元素，但不必用 <code>erase</code> 修改数组，只要传参数的时候同时修改<strong>指针</strong>和<strong>长度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们发现，<strong>首地址指针</strong>和<strong>数组长度</strong>看起来不太对称。</p><p><code>print(char const *begptr, size_t size);</code></p><p>不妨改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>如何？</p><p><code>print(char const *begptr, size_t endptr);</code></p><p>注意看，我们在 print 里也不是用<strong>数组下标</strong>去迭代，而是用<strong>指针</strong>作为迭代变量了。</p><h4 id="首指针-尾指针"><a href="#首指针-尾指针" class="headerlink" title="首指针 + 尾指针"></a>首指针 + 尾指针</h4><p>改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>以后，要特别注意一点：<strong>尾地址指针</strong>实际上是指向末尾元素再往后后一个元素的指针！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*begptr = &quot;</span> &lt;&lt; *begptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*endptr = &quot;</span> &lt;&lt; *endptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*(endptr - 1) = &quot;</span> &lt;&lt; *(endptr<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// *begptr = h</span></span><br><span class="line"><span class="comment">// *endptr = ?随机值</span></span><br><span class="line"><span class="comment">// *(endptr - 1) = l</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure><p>也就是说<strong>尾地址指针</strong>所指向的地方是无效的内存 <code>a + a.size()</code>，<strong>尾地址指针减1</strong>才是真正的末尾元素指针 <code>a + a.size() - 1</code>。</p><p>为什么要这样设计？因为如果用 a + <code>a.size() - 1</code> 也就是 <code>&amp;a.back()</code> 作为尾地址指针，将无法表示<strong>数组长度为</strong> <strong>0</strong> 的情况。</p><p>而让<strong>尾地址指针</strong>往后移动一格的设计，使得数组长度为 0 就是 <code>begptr == endptr</code> 的情况，非常容易判断。</p><p>更方便的是你可以通过指针的减法运算： endptr - begptr 来算出数组的长度！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> size = endptr - begptr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;begptr - endptr = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// begptr - endptr = 4</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure><p>for 循环里也很容易写，判断是否继续循环的条件为 <code>ptr != endptr</code> 就行了。</p><h4 id="模板实现"><a href="#模板实现" class="headerlink" title="模板实现"></a>模板实现</h4><p>最后，我们可以让<strong>首指针</strong>和<strong>尾指针</strong>声明为模板参数，这样不论指针是什么类型，都可以使用 print 这个模板函数来打印。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *abegptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *aendptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(abegptr, aendptr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bbegptr = b.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bendptr = b.<span class="built_in">data</span>() + b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(bbegptr, bendptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="不连续内存的容器"><a href="#不连续内存的容器" class="headerlink" title="不连续内存的容器"></a>不连续内存的容器</h4><p><strong>首指针</strong>和<strong>尾指针</strong>的组合的确能胜任 vector 这种连续数组，但是对于 list 这种不连续的内存的容器就没辙了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();<span class="comment">//No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.data + a.<span class="built_in">size</span>();<span class="comment">// No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，list 没有 data() 这个成员函数，因为他根本就不连续。</p><h4 id="首迭代器-尾迭代器"><a href="#首迭代器-尾迭代器" class="headerlink" title="首迭代器 + 尾迭代器"></a>首迭代器 + 尾迭代器</h4><p>然而 list 却提供了 begin() 和 end() 函数，他们会返回两个 list<char>::iterator 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator begptr = a.<span class="built_in">begin</span>();</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator endptr = a.<span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure><p>这个 <code>list&lt;char&gt;::iterator</code> 是一个特殊定义过的类型，其具有 <code>!=</code> 和 <code>++</code> 以及 <code>*</code> 这些<code>**</code><strong>运算符的重载</strong>。所以用起来就像普通的指针一样。而这些运算符重载，却会<strong>把<code>++</code>对应到链表的<code>curr=curr-&gt;next</code>上</strong>。</p><p>这样一个用起来就像普通的指针，但内部却通过运算符重载适配不同容器的特殊类，就是<strong>迭代器(iterator)<strong>，迭代器是 STL 中</strong>容器</strong>和<strong>算法</strong>之间的桥梁。</p><p>如果让我们来写 list 容器和他的迭代器，他的内部具体实现可能是这样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head + size&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterate_over_list</span><span class="params">(List&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> curr = list.head; curr != <span class="literal">nullptr</span>; curr = curr-&gt;next) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的这些运算符，都是约定俗成的，其根本目的在于模仿指针的行为，方便来自 C 语言的程序员快速上手掌握 C++ 标准库。</p><p>虽然你也可以用直观的函数名 <code>advance()</code> 代替 <code>++</code>，用 deref() 代替 <code>*</code>，equal_to() 代替 <code>==</code>。但是模仿指针行为的这些运算符，已然成为了 C++ 事实上的标准，而且也非常简洁明了。</p><p>因此所有的用户和库，都会按照这套运算符标准来实现和使用迭代器，建立起了沟通的桥梁，节省了各自创立一套规范的成本。</p><h4 id="迭代器中-的前置和后置"><a href="#迭代器中-的前置和后置" class="headerlink" title="迭代器中++的前置和后置"></a>迭代器中<code>++</code>的前置和后置</h4><p>迭代器的自增运算符分为 <code>++p</code> 和 p++ 两种写法。他们都会产生 <code>p = p + 1</code> 的效果，但是有一个细微的区别，就是他们<strong>被作为表达式时的返回值</strong>。</p><ul><li><p>**前置自增 <code>++p</code>**：此运算符会先将迭代器<code>p</code>自增，然后返回自增后的迭代器本身。由于返回的是左值引用，因此可以继续进行自增操作，例如<code>++++p</code>。</p></li><li><p>**后置自增 <code>p++</code>**：此运算符会先返回自增前的迭代器值，然后再执行自增。返回值是一个右值，不能被修改。</p></li></ul><p>正因如此，后置自增需要先保存旧的迭代器，然后自增自己，再返回旧迭代器，可能<strong>会比较低效</strong>。</p><p>在 C++ 中我们推荐尽可能地多用前置自增 ++p。</p><ul><li><p>在运算符重载上，沙雕的C++ 标准委员会规定，<code>operator++(int)</code> 这个重载是后置自增 <code>p++</code>，不带任何参数的<code>operator++()</code> 这个重载是前置自增，之所以这样是因为同名函数只能通过参数列表类型来区分，这个 int 类型参数没有任何实际意义，只是为了区分不同的重载……**编译器会在p++的时候自动改成调用p.operator++(0)**，这个0只是为了区分重载</p></li><li><pre><code class="cpp">Iterator &amp;operator++()&#123;    curr = curr-&gt;next;    return *this;&#125;Iterator operator++(int)&#123;    Iterator tmp = *this;    this-&gt;operator++();    return tmp;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## vector容器中的迭代器</span><br><span class="line"></span><br><span class="line">#### `begin()`和`end()`函数</span><br><span class="line"></span><br><span class="line">`begin()` 可以获取指向第一个元素所在位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">`end()` 可以获取指向最后一个元素下一个位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">迭代器的作用类似于一个位置标记符。</span><br><span class="line"></span><br><span class="line">虽然对于 `vector` 来说只需要下标（index）就能标记位置了，例如 Python 中也是通过 0 表示第一个元素，-1 表示最后一个元素：`a[0] a[1] a[-1]`</span><br><span class="line"></span><br><span class="line">而 C++ 的特色就是采用了迭代器（iterator）来标记位置，他实际上是一个指针，这样的好处是：不需要指定原来的容器本身，就能知道指定的位置。</span><br><span class="line"></span><br><span class="line">一对迭代器 `begin` 和 `end` 就标记了一个区间（range）。区间可以是一个容器的全部，例如 `&#123;a.begin(), a.end()&#125;` 区间；也可以是一个容器的部分，例如 `&#123;a.begin() + 1, a.end() - 1&#125;` 相当于去头去尾后的列表，相当于 Python 中的 `a[1:-1]`。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;printer.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator b = a.begin();</span><br><span class="line">    vector&lt;int&gt;::iterator e = a.end();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*b = &quot; &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 1) = &quot; &lt;&lt; *(b + 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 2) = &quot; &lt;&lt; *(b + 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 2) = &quot; &lt;&lt; *(e - 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 1) = &quot; &lt;&lt; *(e - 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*e = &quot; &lt;&lt; *e &lt;&lt; endl;//直接访问end是一个无效地址</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">// a = &#123;1,2,3,4,5,6&#125;</span><br><span class="line">// *b = 1</span><br><span class="line">// *(b + 1) = 2</span><br><span class="line">// *(b + 2) = 3</span><br><span class="line">// *(e - 2) = 5</span><br><span class="line">// *(e - 1) = 6</span><br><span class="line">// *e = -450617339随机数</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>begin</code> 可以获取指向<strong>第一个元素所在位置</strong>的迭代器。可以通过 <code>*a.begin()</code> 来访问第一个元素。</p><p>迭代器支持加法运算，例如 <code>*(a.begin() + 1)</code> 就是访问数组的第二个元素了，和 a[1] 等价。</p><p><code>end</code> 可以获取指向<strong>最后一个元素下一个位置</strong>的迭代器。也就是说 <code>end</code> 指向的位置是不可用的！如需访问最后一个元素必须用 <code>*(a.end() - 1)</code> 才行。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/image-20241022221652364.png" class="" title="image-20241022221652364"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator b = a.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator e = a.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[0] = &quot;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[1] = &quot;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[2] = &quot;</span> &lt;&lt; b[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-2] = &quot;</span> &lt;&lt; e[<span class="number">-2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-1] = &quot;</span> &lt;&lt; e[<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[0] = &quot;</span> &lt;&lt; e[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// b[0] = 1</span></span><br><span class="line"><span class="comment">// b[1] = 2</span></span><br><span class="line"><span class="comment">// b[2] = 3</span></span><br><span class="line"><span class="comment">// e[-2] = 5</span></span><br><span class="line"><span class="comment">// e[-1] = 6</span></span><br><span class="line"><span class="comment">// e[0] = -1739380936</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>冷知识</strong>，迭代器实际上还可以用 <code>[]</code> 运算符访问。</p><p>例如这里的 <code>b[i]</code> 就和 <code>*(b + i)</code> 等价。</p><p>不过只有 vector 这种连续的可随机访问容器的迭代器有 <code>+</code> 和 <code>[]</code> 运算符，对于 list 则只有 <code>*</code> 和 +<code>+</code> 和 <code>--</code> 运算符可以用，这是迭代器的两个分类，详见下一章。</p><p>自此，迭代器对象和容器本身的主要区别就在于：</p><p>迭代器不掌握生命周期，从而迭代器的拷贝是平凡的<strong>浅拷贝</strong>，方便传参。但也带来了缺点，因为迭代器是一个对原容器的弱引用，如果原容器解构或发生内存重分配，迭代器就会失效。</p><h4 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a><code>insert()</code>函数</h4><h5 id="头部插入"><a href="#头部插入" class="headerlink" title="头部插入"></a>头部插入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//b = &#123;233,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><p>我们知道 <code>push_back</code> 可以往尾部插入数据，那么如何往<strong>头部</strong>插入数据呢？用<code>insert</code>函数，他的第一个参数是要插入的位置（用迭代器表示），第二个参数则是要插入的值。</p><p>注意这个函数的复杂度是 O(n)，n 是从<strong>插入位置<code>pos</code></strong> 到<strong>数组末尾<code>end</code></strong> 的距离。没错，他会插入位置后方的元素整体向后移动一格，是比较低效的，因此为了高效，我们尽量只往尾部插入元素。如果需要高效的头部插入，可以考虑用 <code>deque</code> 容器，他有高效的 <code>push_front</code> 函数替代。</p><p><code>insert</code> 在容量不足时，同样会造成重新分配以求扩容，会移动其中所有元素，这时所有之前保存的迭代器都会失效。</p><h5 id="特定位置插入"><a href="#特定位置插入" class="headerlink" title="特定位置插入"></a>特定位置插入</h5><p><code>iterator insert(const_iterator pos, int const &amp;val);</code></p><p><code>iterator insert(const_iterator pos, int &amp;&amp;val); // C++11</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//  = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,233,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><p>如果要插入到一个特定位置，可以用迭代器的加法来获取某一位置的迭代器。</p><p>例如 <code>a.begin() + 3</code> 就会指向第三个元素，那么用这个作为 <code>insert</code> 的参数就会把 <code>233</code> 这个值插到第三个元素的位置之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置是倒数第二个</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,233,5,6&#125;</span></span><br></pre></td></tr></table></figure><p><code>a.begin()</code> 可以插入到开头位置。</p><p><code>a.begin() + 1</code> 可以插入到第二个元素位置。</p><p><code>a.end()</code> 可以插入到最末尾（append）。</p><p><code>a.end() - 1</code> 则是插入到倒数第一个元素前。</p><p><code>end()</code> 迭代器的减法和是 Python 中负数作为下标的情况很像的，不过 C++ 更加明确是从 end 开始往前数的。</p><h5 id="重复插入多个相同的值"><a href="#重复插入多个相同的值" class="headerlink" title="重复插入多个相同的值"></a>重复插入多个相同的值</h5><p><code>iterator insert(const_iterator pos, size_t n, int const &amp;val);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,233,233,233,1,2,3,4,,5,6&#125;</span></span><br></pre></td></tr></table></figure><p>insert 还有一个特殊的功能，就是他可以插入一个元素很多遍！只需多指定一个参数来表示插入多少遍，语法如下：</p><p><code>a.insert(插入位置, 重复多少次, 插入的值);</code></p><ul><li>你可能会担心，刚刚不是说在头部 insert 是 O(n) 复杂度嘛？那如果再重复 n 次岂不是 O(n²) 复杂度了？</li><li>当然不会，<code>insert</code> 的这个重载会一次性批量让 <code>pos</code> 之后的元素移动 n 格，不存在反复移动 1 格的情况，最坏复杂度仍然是 O(n)。如果你自己写个 for 循环反复调 <code>insert</code> 那的确是会 O(n²) 了，这就是为什么 <code>insert</code> 提供这个高效的重载专门负责重复插入的操作。</li></ul><h5 id="直接插入一个初始化列表"><a href="#直接插入一个初始化列表" class="headerlink" title="直接插入一个初始化列表"></a>直接插入一个初始化列表</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><p>insert 还可以直接插入一个 <code>&#123;&#125;</code> 的列表！</p><p>这个花括号 <code>&#123;&#125;</code> 形成的列表就是传说中的**初始化列表(initializer-list)**，是 C++11 新增的功能，例如这里这个列表的类型是 <code>std::initializer_list&lt;int&gt;</code>。</p><p><code>a.insert(插入位置, &#123;插入值1, 插入值2, ...&#125;);</code></p><p>这个的最坏复杂度同样是 O(n) 的，并且因为其内部预先知道了要插入列表的长度，会一次性完成扩容，比重复调用 push_back 重复扩容要高效很多。</p><h5 id="直接插入另一个vector"><a href="#直接插入另一个vector" class="headerlink" title="直接插入另一个vector"></a>直接插入另一个vector</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p><p>能否传入一个vector作为参数呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b); <span class="comment">//直接传入vector对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// test.cpp: In function ‘int main()’:</span></span><br><span class="line"><span class="comment">// test.cpp:12:13: error: no matching function for call to ‘std::vector&lt;int&gt;::insert(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;&amp;)’</span></span><br><span class="line"><span class="comment">//    12 |     a.insert(a.begin(), b); //直接传入vector对象</span></span><br></pre></td></tr></table></figure><p>不可以，因为<code>vector</code>和<code>initializer_list</code>不是同一个类型。</p><p>那要如何插入另一个数组，或者说把a和b两个数组进行合并？</p><p><strong>通过迭代器</strong></p><p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p><p><code>iterator insert(const_iterator pos, It beg, It end);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());    <span class="comment">//传入区间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">//b = 233 666 985 211</span></span><br><span class="line"><span class="comment">//a = 233 666 985 211 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure><p>记得 C++ 的迭代器思想是，<strong>容器</strong>和<strong>算法</strong>之间的交互不是通过容器对象本身，而是他的迭代器，因此 <code>insert</code> 设计时就决心不支持直接接受 <code>vector</code> 作参数，而是接受他的两个迭代器组成的区间！好处有：</p><ol><li><p>可以批量插入从来自另一个不同类型的容器，例如 list<int>，只要元素类型相等，且符合迭代器规范。</p></li><li><p>我可以自由选择对方容器的一个子区间（通过迭代器加减法）内的元素来插入，而不是死板的只能全部插入。</p></li></ol><p>刚才 <code>a.insert(a.begin(), b.begin(), b.end())</code> 会把 b 插入在原先 a 元素之前，相当于Python的 a &#x3D; b + a。</p><p>可以改用 <code>a.insert(a.end(), b.begin(), b.end())</code> 把 b 插入到 a 元素之后，相当于Python的 <code>a += b</code>，这样性能更好（只要容量足够就无需移动 a 的全部元素）。</p><p>当然也可以 <code>a.insert(a.begin() + 3, b.begin(), b.end())</code> 这样只插入到指定位置中间，Python似乎没有这个操作。</p><h5 id="数据源可是是不同类型"><a href="#数据源可是是不同类型" class="headerlink" title="数据源可是是不同类型"></a>数据源可是是不同类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure><p>对方容器也可以是<strong>不同类型</strong>的，最底线的要求是只要他的迭代器有 <code>++</code> 和 <code>*</code> 运算符即可。</p><p>例如上面的 <code>list&lt;int&gt;::iterator</code> 就符合需求。</p><p><strong>甚至可以是一个c语言风格的数组</strong></p><p>c++11新增两个函数：</p><p><code>template &lt;class T&gt; auto begin(T &amp;&amp;t);</code></p><p><code>template &lt;class T&gt; auto end(T &amp;&amp;t);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(b), std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure><p>因为 C 语言类型没有办法加成员函数 begin 和 end，可以用 <code>std::begin</code> 和 std::end 这两个全局函数代替，当然如果用了 <code>using namespace std</code> 时也可以不写 std:: 前缀。</p><p>这两个函数会对于具有 <code>begin</code> 和 <code>end</code> 成员函数的容器会直接调用，对于 C 语言数组则被特化为返回 <code>b</code> 和 <code>b + sizeof(b)/sizeof(b[0])</code>。</p><h4 id="构造函数也接受迭代器"><a href="#构造函数也接受迭代器" class="headerlink" title="构造函数也接受迭代器"></a>构造函数也接受迭代器</h4><p><code>template &lt;class It&gt;  // 这里 It 可以是其他容器的迭代器类型</code></p><p><code>explicit vector(It beg, It end);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(std::begin(b), std::end(b))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985.211&#125;</span></span><br></pre></td></tr></table></figure><p>vector 容器的构造函数也接受一对迭代器做参数，来初始化其中的元素。同样可以是不同容器的迭代器对象，只要具有 <code>++</code> 和 <code>*</code> 就行了。</p><h4 id="assign-函数"><a href="#assign-函数" class="headerlink" title="assign()函数"></a><code>assign()</code>函数</h4><p>重新分配vector中的值</p><p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p><p><code>void assign(It beg, It end);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    a.<span class="built_in">assign</span>(std::<span class="built_in">begin</span>(b),std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure><p>除了构造函数外，<code>assign</code> 这个成员函数也能在后期把元素覆盖进去。和 <code>insert</code> 不同的是，他会把旧有的数组完全覆盖掉，变成一个新的数组。（清空原来的值，放入新值，注意此时不会重新分配内存）</p><p><code>a.assign(beg, end)</code> 基本和 <code>a = vector&lt;int&gt;(beg, end)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量不会释放掉。</p><p><code>assign</code> 还有一个<code>重载</code>，可以把 <code>vector</code> 批量填满一个特定的值，重复的次数（长度）也是参数里指定。</p><p><code>void assign(size_t n, int const &amp;val);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233, 233, 233, 233&#125;</span></span><br></pre></td></tr></table></figure><p><code>a.assign(n, val)</code> 基本和 <code>a = vector&lt;int&gt;(n, val)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量。</p><p>assign 还可以直接接受一个初始化列表作为参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(&#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a = &#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a = vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;233,666,985,211&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;996,7&#125;</span></span><br><span class="line"><span class="comment">// a.capacity() = 6</span></span><br><span class="line"><span class="comment">// a.capacity() = 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>a.assign(&#123;x, y, ...&#125;)</code> 和 <code>a = &#123;x, y, ...&#125;</code> 完全等价，都会保留原来的容量。而和 <code>a = vector&lt;int&gt;&#123;x, y, ...&#125;</code> 就不等价，这个会重新分配内存。</p><h4 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a><code>erase()</code>函数</h4><h5 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h5><p>erase 函数可以删除指定位置的一个元素（通过迭代器指定）。</p><p><code>iterator erase(const_iterator pos);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5&#125;</span></span><br></pre></td></tr></table></figure><p><code>a.erase(a.begin())</code> 就是删除第一个元素（相当于 pop_front）。</p><p><code>a.erase(a.end() - 1)</code> 就是删除最后一个元素（相当于 pop_back）。</p><p><code>a.erase(a.begin() + 2)</code> 就是删除第三个元素。</p><p>a.erase(a.end() - 2) 就是删除倒数第二个元素。</p><p>erase 的复杂度最坏情况是删除第一个元素 O(n)。如果删的是最后一个元素则复杂度为 O(1)。</p><p>这是因为 erase 会移动 pos 之后的那些元素。</p><h5 id="指定区间"><a href="#指定区间" class="headerlink" title="指定区间"></a>指定区间</h5><p>erase 也可以指定两个迭代器作为参数，表示把这个区间内的对象都删除。</p><p>iterator erase(const_iterator beg, const_iterator end);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><p>比如这里 <code>a.erase(a.begin() + 1, a.begin() + 3)</code> 就删除了 a 的第二个和第三个元素，相当于Python的 <code>del a[1:3]</code>，注意 C++ 的 insert 和 erase 都是就地操作的。</p><p>例如：<code>a.erase(a.begin() + n, a.end())</code> 就和 <code>a.resize(n)</code> 等价，前提是**<code>n小于a.size()</code>**。</p><p>批量删除的最坏复杂度依然是 O(n) 的，不用担心。</p><p>不过这里两个作为 erase 参数的迭代器<strong>必须是自己这个对象的迭代器</strong>，不能是其他容器的，这点和 insert 不一样。</p><p>他返回删除后<code>最后一个元素之后</code>那个位置的迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解STL-std::string用法指南&amp;源码刨析</title>
      <link href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/"/>
      <url>/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ASCII码"><a href="#一、ASCII码" class="headerlink" title="一、ASCII码"></a>一、ASCII码</h2><h3 id="计算机如何表达字符"><a href="#计算机如何表达字符" class="headerlink" title="计算机如何表达字符"></a>计算机如何表达字符</h3><p>众所周知，计算机只能处理二进制整数，字符要怎么办呢？</p><p>于是就有了 ASCII 码表，它规定，每个英文字符（包括大小写字母、数字、特殊符号）都对应着一个整数。在计算机里只要存储这个的整数，就能代表这个字符了。</p><p>例如 32 代表空格，48 代表 ‘0’，65 代表 ‘A’，97 代表 ‘a’……</p><p>32~126 这些整数就用于是表示这些**可显示字符(printable character)**的。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029141908104.png" class="" title="image-20241029141908104"><p>除了可显示字符(printable character)外，ASCII 还规定了一类特殊的**控制字符(control character)**：</p><ul><li><p>0 表示空字符（‘\0’）</p></li><li><p>9 表示 Tab 制表符（‘\t’）</p></li><li><p>10 表示换行（‘\n’）</p></li><li><p>13 表示回车（‘\r’）</p></li><li><p>27 表示 ESC 键（‘\x1b’）</p></li><li><p>127 表示 DEL 键（‘\x7f’）等</p></li></ul><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029141958087.png" class="" title="image-20241029141958087"><p>0~31 和 127 这些整数，就构成了 ASCII 码中控制字符的部分。</p><h3 id="关于控制字符的冷知识"><a href="#关于控制字符的冷知识" class="headerlink" title="关于控制字符的冷知识"></a>关于控制字符的冷知识</h3><p>在 Linux 命令行中启动 cat。</p><p>试试按 Ctrl+R，Ctrl+E，Ctrl+C 等一系列组合键，看到出现了什么？</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029142131414.png" class="" title="image-20241029142131414"><p>可以看到显示的字符变成了 ^R ^E ^C 等……</p><p>这是 Unix 类系统显示控制字符的一种方式。</p><p>众所周知，我们常用 Ctrl+C 来发送中断信号（SIGINT）强制终止程序，这时常常会看到一个 ^C 的字样，就是这样出现的。这里我们的 cat 程序收到 ^C 以后，就直接终止退出了。</p><p>除此之外，因为 ^D 是“传输终止符”，还可以在控制台输入 Ctrl+D 来关闭标准输入流，终止正在读取他的程序。</p><p>常用 Ctrl+D 来快速关闭一个 shell（和输入 exit 命令的效果一样）。</p><p>以及按 Ctrl+I 的效果其实和 Tab 键一样，按 Ctrl+J 的效果和 Enter 键一样，按 Ctrl+H 的效果和退格键一样。</p><p>这是因为 ASCII 表中规定 ^I 就是 ‘\t’，^J 就是 ‘\n’，^H 就是 ‘\b’，所以以前原始的计算机键盘上其实还没有 Enter 键，大家都是按 Ctrl+J 来换行的……</p><p>不过，如果直接在控制台输入 ‘^’ 和 ‘C’ 两个字符并没有 Ctrl+C 的效果哦！因为 ‘^C’ 是 Ctrl+C 输入之后一次性显示出来的，并不是真的说 Ctrl 就是 ‘^’ 这个字符。</p><h2 id="二、C语言字符串"><a href="#二、C语言字符串" class="headerlink" title="二、C语言字符串"></a>二、C语言字符串</h2><h3 id="C-语言中的字符类型-char"><a href="#C-语言中的字符类型-char" class="headerlink" title="C 语言中的字符类型 char"></a>C 语言中的字符类型 char</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = ‘a’;</span><br><span class="line">assert(c == <span class="number">97</span>);</span><br><span class="line">c = c + <span class="number">1</span>;</span><br><span class="line">assert(c == ‘b’);</span><br></pre></td></tr></table></figure><p>C语言中规定字符类型为 char 类型，是个 8 位整数。</p><p>这是因为 ASCII 码只有 0<del>127 这些整数，而 8 位整数的表示范围是 2^8 也就是 0</del>255，足以表示所有 ASCII 字符了（多余的部分实际上被用于表示中文）。</p><p>char 和整数无异，例如 ‘a’ 实际上会被编译器翻译成他对应的 ASCII 码：97。写 ‘a’ 和写 (char)97 是完全一样的，方便阅读的语法糖而已。</p><h3 id="“char即整数”思想"><a href="#“char即整数”思想" class="headerlink" title="“char即整数”思想"></a>“char即整数”思想</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// abcdefghijklmnopqrstuvwxyz</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原字符：%c\n&quot;</span>, c);</span><br><span class="line">    c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    c += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转大写：%c\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原字符：c</span></span><br><span class="line"><span class="comment">// 转大写：C</span></span><br></pre></td></tr></table></figure><h3 id="c语言帮手函数"><a href="#c语言帮手函数" class="headerlink" title="c语言帮手函数"></a>c语言帮手函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原字符：%c\n&quot;</span>, c);</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);<span class="comment">//帮手函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转大写：%c\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原字符：c</span></span><br><span class="line"><span class="comment">// 转大写：C</span></span><br></pre></td></tr></table></figure><h3 id="帮手函数大全"><a href="#帮手函数大全" class="headerlink" title="帮手函数大全"></a>帮手函数大全</h3><ul><li>isupper(c) 判断是否为大写字母（‘A’ &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; ‘Z’）。</li><li>islower(c) 判断是否为小写字母（‘a’ &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; ‘z’）。</li><li>isalpha(c) 判断是否为字母（包括大写和小写）。</li><li>isdigit(c) 判断是否为数字（‘0’ &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; ‘9’）。</li><li>isalnum(c) 判断是否为字母或数字（包括字母和数字）。</li><li>isxdigit(c) 判断是否为十六进制数字（0~9 或 a-f 或 A-F）。</li><li>isspace(c) 判断是否为等价于空格的字符（‘ ’ 或 ‘\t’ 或 ‘\n’ 或 ‘\v’ 或 ‘\r’）。</li><li>iscntrl(c) 判断是否为控制字符（0 &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; 31 或 c &#x3D;&#x3D; 127）。</li><li>toupper(c) 把小写字母转换为大写字母，如果不是则原封不动返回。</li><li>tolower(c) 把大写字母转换为小写字母，如果不是则原封不动返回。</li></ul><h3 id="关于cahr类型的一个冷知识"><a href="#关于cahr类型的一个冷知识" class="headerlink" title="关于cahr类型的一个冷知识"></a>关于cahr类型的一个冷知识</h3><p>C 语言其实只规定了 <strong>unsigned char 是无符号 8 位整数</strong>，<strong>signed char 是有符号 8 位整数</strong>，而 <strong>char 类型只需是 8 位整数即可，可以是有符号也可以是无符号</strong>，任凭编译器决定（C 标准委员会传统异能，khronos 直呼内行）。</p><p>以 GCC 为例，他规定 char 在 x86 架构是有符号的 (char &#x3D; signed char)，而在 arm 架构上则认为是无符号的 (char &#x3D; unsigned char)，因为他认为“arm 的指令集处理无符号8位整数更高效”，所以擅自把 char 魔改成无符号的……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_signed&lt;<span class="type">char</span>&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的 char 是有符号的，我猜你是 x86 架构\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的 char 是无符号的，我猜你是 arm 架构\n&quot;</span>);<span class="comment">//有arm架构电脑的话可以尝试一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 你的 char 是有符号的，我猜你是 x86 架构</span></span><br></pre></td></tr></table></figure><p>顺便一提，C++ 标准保证 char，signed char，unsigned char 是三个完全不同的类型，std::is_same_v 分别判断他们总会得到 false，无论 x86 还是 arm。</p><p>但是奇葩的 C 语言却规定 short，int，long，long long 必须是有符号的 (int &#x3D; signed int)，反而却没有规定他们的位宽（没错，int 可以是 32 位，也可以是 16 位的，标准规定只需满足 char &lt;&#x3D; short &lt;&#x3D; int &lt;&#x3D; long &lt;&#x3D; long long 即可）。</p><h3 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a>C语言中的字符串</h3><p>**字符串(string)<strong>就是由</strong>字符(character)**组成的数组。</p><p>C 语言中，字符串用双引号 <code>“ ”</code> 包裹，字符用单引号 <code>‘ ’</code> 包裹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = ‘h’;</span><br><span class="line"><span class="type">char</span> s[] = “hello”;</span><br></pre></td></tr></table></figure><p>正如 ‘h’ 是个语法糖，等价于 h 的 ASCII 码——整数 104。</p><p>“hello” 也是个语法糖，他等价于数组 {‘h’, ‘e’, ‘l’, ‘l’, ‘o’, 0}。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> s[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符：%c\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符：h</span></span><br><span class="line"><span class="comment">// 字符串：hello</span></span><br></pre></td></tr></table></figure><p>hello 每个字符都连续地排列在这个数组中，那么末尾的 0 是怎么回事？</p><p>原来 C 语言的字符串因为只保留数组的<strong>首地址指针</strong>（指向第一个字符的指针），在以 <code>char *</code> 类型传递给其他函数时，其数组的长度无法知晓。为了确切知道数组在什么地方结束，<strong>规定用 ASCII 码中的“空字符”也就是 0 来表示数组的结尾</strong>。这样只需要一个首地址指针就能表示一个动态长度的数组，高，实在是高。</p><h3 id="“0结尾字符串”应用举例"><a href="#“0结尾字符串”应用举例" class="headerlink" title="“0结尾字符串”应用举例"></a>“0结尾字符串”应用举例</h3><p>利用 C 语言字符串“以0结尾”这个特点，我们可以在一个本来非0的字符处写入0，来提前结束字符串。例如在第 n 个字符写入0，就会只保留前 n 个字符作为一个子字符串，删除后半部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;魔改前：%s\n&quot;</span>, s);</span><br><span class="line">    s[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;魔改后：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 魔改前：hello</span></span><br><span class="line"><span class="comment">// 魔改后：hel</span></span><br></pre></td></tr></table></figure><p>C 语言所谓的字符串类型 char * 实际上就是个首地址指针，如果让首地址指针向前移动 n 位，那就实现删除前 n 个字符的效果，而不用实际修改数组本身（更高效）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;魔改前：%s\n&quot;</span>, s);</span><br><span class="line">    <span class="type">char</span> *p = s + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;魔改后：%s\n&quot;</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 魔改前：hello</span></span><br><span class="line"><span class="comment">// 魔改后：lo</span></span><br></pre></td></tr></table></figure><h3 id="C语言转义符"><a href="#C语言转义符" class="headerlink" title="C语言转义符"></a>C语言转义符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello\nworld&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串：%s\n&quot;</span>, s);</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//可以切换为\t \b \r \\ \0等查看效果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符: [%c]\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//字符串：hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//字符：[</span></span><br><span class="line"><span class="comment">//]\n换行作用</span></span><br></pre></td></tr></table></figure><p>常见的转义符：</p><ul><li>‘\n’ 换行符：另起一行（光标移到下一行行首）</li><li>‘\r’ 回车符：光标移到行首（覆盖原来的字符）</li><li>‘\t’ 缩进符：光标横坐标对齐到 8 的整数倍</li><li>‘\b’ 退格符：光标左移，删除上个字符</li><li>‘\’ 反斜杠：表示这个是真的 \，不是转义符</li><li>‘\”’ 双引号：在字符串常量中使用，防止歧义</li><li>‘\’’ 单引号：在字符常量中使用，防止歧义</li><li>‘\0’ 空字符：标记字符串结尾，等价于 0</li></ul><p><strong>注意：’\0’ 和整数 0 等价，但和 ‘0’ 不等价。‘0’ 相当于他的 ASCII 码 48。而 ‘\0’ 就是整数 0。</strong></p><h3 id="和-的异同"><a href="#和-的异同" class="headerlink" title="% 和 \ 的异同"></a><code>%</code> 和 <code>\</code> 的异同</h3><p><code>%</code> 没什么好神秘的，他就是一个普通的字符。仅仅只是 printf 和 scanf 这些特定的函数会对 <code>%</code> 特殊处理而已。</p><p>而 <code>\</code> 比较厉害，他是编译器内部专门为他“开了个后门”。</p><p>编译器检测到字符串中出现 \ 就会把下一个字符特殊处理。而 <code>%</code>，编译器并不会特殊处理 <code>%</code>，是 printf 函数内部在运行时处理了 <code>%</code> 的下一个字符。</p><p><code>%</code> 就像你和同学随手“拉钩”定下的约定，这是 printf 约定俗成的。<code>\</code> 就像正式合同，有法律效力的，这是 C 语言编译器规定好的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = &#123;<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(s, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h2 id="三、C-字符串类"><a href="#三、C-字符串类" class="headerlink" title="三、C++字符串类"></a>三、C++字符串类</h2><h3 id="std-string应运而生"><a href="#std-string应运而生" class="headerlink" title="std::string应运而生"></a>std::string应运而生</h3><p>C语言字符串操作繁琐，封装的 std::string 应运而生：</p><p>string 可以从 **const char *** 隐式构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s = “hello”;</span><br></pre></td></tr></table></figure><p>string 具有 +、+&#x3D;、&#x3D;&#x3D; 等直观的运算符重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(“hello”) + <span class="built_in">string</span>(“world”) == <span class="built_in">string</span>(“helloworld”)</span><br></pre></td></tr></table></figure><p>string 符合 vector 的接口，例如 begin&#x2F;end&#x2F;size&#x2F;resize……</p><p>string 有一系列成员函数，例如 find&#x2F;replace&#x2F;substr……</p><p>string 可以通过 s.c_str() 重新转换回古板的 const char *。</p><p>string 在离开作用域时自动释放内存 (RAII)，不用手动 free</p><h3 id="C-字符串和C字符串的不同"><a href="#C-字符串和C字符串的不同" class="headerlink" title="C++字符串和C字符串的不同"></a>C++字符串和C字符串的不同</h3><p>C 语言字符串是单独一个 **char *ptr**，自动以 ‘\0’ 结尾。</p><p>C++ 字符串是 string 类，其成员有两个：<code>char *ptr</code>; <code>size_t len</code>;</p><ul><li>第二个成员用来确定结尾的位置，不需要 ‘\0’ 结尾。</li></ul><p>因此 string 类从 C 字符串构造时，可以额外指定一个长度：</p><ul><li><code>string(“hello”, 3)</code> 会得到 “hel”</li><li>↑ len为 3，ptr指向 ’h’，只保留前三个字符</li><li><code>string(“hello”, 12)</code> 会得到 “hello\0[数据删除]”</li><li>↑ len为 12，ptr指向 ’h’，超出了 6 个字符，<strong>内存读越界（出错）</strong></li><li><code>string(“hello\0world!”, 12)</code> 会得到 “hello\0world!”</li><li>↑ len为 12，ptr指向 ’h’，字符串内可以包含 ‘\0’，cout 能正常打印完整字符串</li></ul><h3 id="iostream应运而生"><a href="#iostream应运而生" class="headerlink" title="iostream应运而生"></a>iostream应运而生</h3><p>printf 指定类型繁琐，泛型的 iostream 应运而生。</p><p>printf 必须告诉他是字符串（%s）还是整数（%d）还是字符（%c），必须和右边的参数一致，初学者容易搞错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s3 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s1) + <span class="built_in">strlen</span>(s2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(s3, s1);</span><br><span class="line">    <span class="built_in">strcat</span>(s3, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s3);</span><br><span class="line">    <span class="built_in">free</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure><p>而且即使搞错了也能正常编译通过（一些高级的编译器会给出警告），但是运行结果不对，或者还有可能崩溃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">// Segmentation fault (core dumped)</span></span><br></pre></td></tr></table></figure><p>得益于 C++ 的重载技术，cout 不用你手动指定类型，他会自动识别参数的类型，帮你调用相应的格式化函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    string s3 = s1 + s2;<span class="comment">// 重载 +</span></span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure><h3 id="c-str和data的区别"><a href="#c-str和data的区别" class="headerlink" title="c_str和data的区别"></a><code>c_str</code>和<code>data</code>的区别</h3><p><em><strong>具体区别取决于编译器实现：</strong></em></p><p>s.c_str() 保证返回的是以 0 结尾的字符串首地址指针，总长度为 s.size() + 1。</p><p>s.data() 只保证返回长度为 s.size() 的连续内存的首地址指针，<strong>不保证</strong> 0 结尾。</p><p>把 C++ 的 string 作为参数传入像 printf 这种 C 语言函数时，需要用 s.c_str()。</p><p>如果只是在 C++ 函数之间传参数，直接用 string 或 string const &amp; 即可。</p><p>不建议在c++中还转换成c语言的字符串再操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">legacy_c</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;<span class="comment">// 这个函数是古老的 C 语言遗产</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modern_cpp</span><span class="params">(std::string name)</span></span>;<span class="comment">// 这个函数是现代 C++，便民！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performance_geek</span><span class="params">(std::string <span class="type">const</span> &amp;name)</span></span>;<span class="comment">// 有点追求性能的极客</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performance_nerd</span><span class="params">(std::string_view name)</span></span>;<span class="comment">// 超级追求性能的极客</span></span><br></pre></td></tr></table></figure><p>const char * 可以隐式转换为 string（为了方便）</p><p>string <strong>不可以</strong>隐式转换为 const char *（安全起见）</p><p>如果确实需要从 string 转换为 const char *，请调用 .c_str() 这个成员函数。</p><h3 id="字符串的连接（-运算符）"><a href="#字符串的连接（-运算符）" class="headerlink" title="字符串的连接（+ 运算符）"></a>字符串的连接（<code>+</code> 运算符）</h3><p>C 语言规定，双引号包裹的字符串是 const char * 类型的，他们没有 + 运算符。</p><p>C++ 为了向前兼容，没办法改变 C 语言的这项规定，只能退而求其次，他另外定义了一个 string 类，重载了 + 运算符，并告诉同学们：以后尽量用我这个封装好的类，不要直接用 C 语言的 const char *。</p><p>因此如果需要把两个字符串加在一起，就必须至少有一方是 string 才行。</p><p>可以用 string(“hello”) 这种形式包裹住每个字符串常量，这样就方便用 + 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s3 = <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) + <span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure><p>初学者建议每个字符串都用 string(“…”) 这种形式写，C 语言字符串不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“hello” + “world”<span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">string</span>(“hello”) + “world”<span class="comment">// 正确</span></span><br><span class="line">“hello” + <span class="built_in">string</span>(“world”)<span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">string</span>(“hello”) + <span class="built_in">string</span>(“world”)<span class="comment">// 正确（推荐）</span></span><br></pre></td></tr></table></figure><h3 id="自定义字面量后缀C-14的新特性"><a href="#自定义字面量后缀C-14的新特性" class="headerlink" title="自定义字面量后缀C++14的新特性"></a>自定义字面量后缀C++14的新特性</h3><p>不少同学就觉得这样好麻烦，其他语言都是直接 “hello” 就是字符串类型，C++ 还得套一层壳 string(“hello”) 才能变成安全封装的类型，才能用他的成员函数。</p><p>因此，C++14 引入了一项缓解“键盘压力”的新特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string <span class="keyword">operator</span><span class="string">&quot;&quot;</span>_s(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> len) &#123; <span class="keyword">return</span> <span class="built_in">string</span>(s, len); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s3 = <span class="string">&quot;hello&quot;</span>_s + <span class="string">&quot;world&quot;</span>_s;</span><br><span class="line">  cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure><p>写 <code>“hello”_s</code> 就相当于写 <code>operator“”_s(“hello”, 5)</code>，就相当于 <code>string(“hello”, 5)</code> 了。</p><p>为什么还需要指定长度 5？其实不指定也可以，就是 “hello\0world” 会退化成 “hello”，因为 cpp 字符串没要求一定是 ‘\0’ 结尾，字符串里是可以包含 ‘\0’ 的。</p><p>如果你 <code>using namespace std;</code> 其实标准库已经自动帮你定义好了 <code>“”s</code> 后缀。</p><p>这里 “hello”s 就等价于原本繁琐的 string(“hello”) 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s3 = <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) + <span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure><p>如果你觉得 using namespace std; 太危险了不想用他。</p><p>可以只用 <code>using namespace std::literials;</code></p><p>这个特殊的命名空间里包含了所有的 <code>operator“”</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br></pre></td></tr></table></figure><ul><li>chrono 和 complex 也定义了一些 literials</li></ul><h2 id="四、字符串-数字"><a href="#四、字符串-数字" class="headerlink" title="四、字符串 &lt;—-&gt;数字"></a>四、字符串 &lt;—-&gt;数字</h2><p>java 经典操作：字符串 + 数字 &#x3D; 字符串</p><p>在 java 中，你可以直接把字符串和数字相加，例如：</p><p><code>“you have ” + 42 + “ yuan”</code> 会得到 “you have 42 yuan”。</p><p>他实际上是先把 42 变成 “42”，再把三个字符串相加的，也就是说 java 编译器会偷偷把他转换成：“you have ” + 42.toString() + “ yuan”。</p><p>但是我们说过 cpp 是不喜欢在编译器里开洞的，他的字符串类型 std::string 是在标准库里定义的，并不是在编译器内部定义的（cpp之父：语言本身要和标准库具体实现解耦）如果你嫌弃标准库不好用，也可以定义一个自己的字符串类型 mylib::String 重载个 + 运算符，和标准库的 std::string 其实是同等地位的。</p><p>虽然也可以给 std::string 定义很多个不同的 + 重载，每个针对不同的数字类型（int、float、double）排列组合，但是这样没有可扩展性，而且影响编译速度。</p><p>所以 cpp 说，你必须手动把 42 先转换为字符串，然后再和已有的字符串相加：</p><p><code>“you have ” + std::to_string(42) + “ yuan”</code></p><h3 id="std-to-string-数字转字符串"><a href="#std-to-string-数字转字符串" class="headerlink" title="std::to_string 数字转字符串"></a>std::to_string 数字转字符串</h3><p>std::to_string 是标准库定义的全局函数，他具有9个重载：</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029165914670.png" class="" title="image-20241029165914670"><p>为什么把 to_string 作为全局函数，而不是 string 类的构造函数？</p><ul><li>因为 cpp 之父喜欢解耦，他不想让数字转字符串这个特定的需求，和字符串本身的实现有太多耦合。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">to_string</span>(n) + <span class="string">&quot;yuan&quot;</span>s;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 42 yuan</span></span><br></pre></td></tr></table></figure><h3 id="std-to-wstring-数字转宽字符串"><a href="#std-to-wstring-数字转宽字符串" class="headerlink" title="std::to_wstring 数字转宽字符串"></a>std::to_wstring 数字转宽字符串</h3><p>同理还有 to_wstring，用于把数字转换为 wstring 类型字符串。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029170218293.png" class="" title="image-20241029170218293"><h3 id="std-sto-字符串转数字"><a href="#std-sto-字符串转数字" class="headerlink" title="std::sto* 字符串转数字"></a>std::sto* 字符串转数字</h3><p>std::stoi&#x2F;stof&#x2F;stod 是标准库定义的一系列全局函数：</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029170251604.png" class="" title="image-20241029170251604"><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029170300438.png" class="" title="image-20241029170300438"><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029170304985.png" class="" title="image-20241029170304985"><p>应用举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;42&quot;</span>s;<span class="comment">//字符串是数字</span></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;42 yuan&quot;</span>s;<span class="comment">// 字符串中数字后面还有其他字符</span></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 42成功解析</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;    42 yuan&quot;</span>s;<span class="comment">//数字前面还有一些空格</span></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 42成功解析</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;the 42 yuan&quot;</span>s;<span class="comment">//数字前面有其他字符，则不能解析</span></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::invalid_argument&#x27;</span></span><br><span class="line"><span class="comment">//  what():  stoi</span></span><br></pre></td></tr></table></figure><h3 id="stoi-的第二参数：-pos"><a href="#stoi-的第二参数：-pos" class="headerlink" title="stoi 的第二参数：&amp;pos"></a>stoi 的第二参数：&amp;pos</h3><p>stoi 可以处理数字后面有多余字符的情况，例如 stoi(“42yuan”) 和 stoi(“42”) 等价，都会返回 42。后面的 “yuan” 会被 stoi 略去。</p><p>那如何才能知道哪些字符被 stoi 略去了呢？或者说，<strong>数字部分从哪里结束</strong>？</p><p>这就要用到 stoi 的第二参数，他是一个 size_t 的指针，默认为 nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stoi</span><span class="params">(<span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span> pos = <span class="literal">nullptr</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>若该指针不为 nullptr，则会往他指向的变量写入一个整数，表示<strong>数字部分结束的那个字符所在的位置</strong>，很绕口？来看个例子就懂了。</p><p>例如 stoi(“42yuan”, &amp;pos) 会返回 42，并把 pos 设为 2。因为 ‘y’ 是数字部分结束的地方，而 ‘y’ 是第三个字符，但是计算机数数从 0 开始，所以计算机说这是第 2 个字符，没毛病。</p><ul><li>为什么要指针？因为 stoi 的返回值已经是 int 了，要额外的返回值只能这样。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;42yuan&quot;</span>s;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s, &amp;pos);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;原始字符串: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;数字部分从第&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;个字符结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;数字是&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;剩余的部分是&quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(pos) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原始字符串: 42yuan</span></span><br><span class="line"><span class="comment">// 数字部分从第2个字符结束</span></span><br><span class="line"><span class="comment">// 数字是42</span></span><br><span class="line"><span class="comment">// 剩余的部分是yuan</span></span><br></pre></td></tr></table></figure><h3 id="stoi-抛出异常的情况"><a href="#stoi-抛出异常的情况" class="headerlink" title="stoi 抛出异常的情况"></a>stoi 抛出异常的情况</h3><p>如果字符串的开头不是数字，则 stoi 会抛出 <code>std::invalid_argument</code> 异常，可以用 catch 捕获。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;happy 10th birthday&quot;</span>s;<span class="comment">//数字前面有其他字符，则不能解析</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">stoi</span>(s);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;数字是：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串：happy 10th birthday</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::invalid_argument&#x27;</span></span><br><span class="line"><span class="comment">//  what():  stoi</span></span><br></pre></td></tr></table></figure><p>但是开头可以有空格，例如 stoi(“ 42yuan”) 可以正常得到 42，但 stoi(“my42yuan”) 就会出错。</p><p>开头也可以是正负号（‘+’ 或 ‘-’），会被当成数字的一部分，例如 stoi(“-42”) 会得到 -42。</p><h3 id="stoi-的第三参数：base"><a href="#stoi-的第三参数：base" class="headerlink" title="stoi 的第三参数：base"></a>stoi 的第三参数：base</h3><p>有时候我们的字符串里是十六进制的数字，如何解析呢？例如 “7cfe”。</p><p>这就要用到 stoi 的第三个参数 base 了，他默认为 10，代表十进制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stoi</span><span class="params">(<span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span> pos = <span class="literal">nullptr</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果需要解析十六进制的数字就把 base 设为 16，八进制就让 base 为 8。</p><p>因为指定第三参数前需要先指定第二参数，如果不用第二参数，写个 nullptr 就行了，例如 <code>stoi(“7cfe”, nullptr, 16)</code> 会得到 31198（0x7cfe 的十进制）。</p><p>注意：stoi 默认是十进制的，如果写 <code>stoi(“7cfe”)</code> 会得到 7，因为他只认识 ‘7’ 是数字，把 “cfe” 看做额外字符忽略掉了（因为 c 不是十进制意义下的数字）。</p><p>十六进制的字母无视大小写，例如 stoi(“7CFE”, nullptr, 16) 的也会得到 31198。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;4399cc&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;原始字符串&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;作为十六进制&quot;</span> &lt;&lt; <span class="built_in">stoi</span>(s, <span class="literal">nullptr</span>, <span class="number">16</span>) &lt;&lt; endl;  <span class="comment">// 0x4399cc</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;作为十进制&quot;</span> &lt;&lt; <span class="built_in">stoi</span>(s, <span class="literal">nullptr</span>, <span class="number">10</span>) &lt;&lt; endl;    <span class="comment">// 4399</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;作为八进制&quot;</span> &lt;&lt; <span class="built_in">stoi</span>(s, <span class="literal">nullptr</span>, <span class="number">8</span>) &lt;&lt; endl;     <span class="comment">// 043</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原始字符串4399cc</span></span><br><span class="line"><span class="comment">// 作为十六进制4430284</span></span><br><span class="line"><span class="comment">// 作为十进制4399</span></span><br><span class="line"><span class="comment">// 作为八进制35</span></span><br></pre></td></tr></table></figure><h3 id="冷知识：stod支持科学计数法"><a href="#冷知识：stod支持科学计数法" class="headerlink" title="冷知识：stod支持科学计数法"></a>冷知识：stod支持科学计数法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;+03.14e-03&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  <span class="type">float</span> f = <span class="built_in">stof</span>(s);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;浮点数: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串: +03.14e-03</span></span><br><span class="line"><span class="comment">// 浮点数: 0.00314</span></span><br></pre></td></tr></table></figure><h3 id="to-string-能不能指定十六进制？"><a href="#to-string-能不能指定十六进制？" class="headerlink" title="to_string 能不能指定十六进制？"></a>to_string 能不能指定十六进制？</h3><p>很遗憾，to_string 是个缓解“键盘压力”的帮手函数，功能根本不全。</p><p>用 + 来拼接字符串也只是初学者的做法，他们并不是专业的字符串格式化工具。</p><p>想要完整的功能（<strong>指定多少进制，左右对齐等</strong>），可以用专业的做法：</p><ol><li><p>古代 C 语言的 sprintf</p></li><li><p>古代 C++ 的 stringstream</p></li><li><p>C++20 新增的 std::format</p></li><li><p>第三方库提供的 fmt::format（<a href="https://github.com/fmtlib/fmt%EF%BC%89">https://github.com/fmtlib/fmt）</a></p></li><li><p>参考B站小彭老师在 zeno 里手撸的两个函数（能支持任意 STL 容器的打印）：</p><ol><li><a href="https://github.com/zenustech/zeno/blob/master/zeno/include/zeno/utils/to_string.h">https://github.com/zenustech/zeno/blob/master/zeno/include/zeno/utils/to_string.h</a></li><li><a href="https://github.com/zenustech/zeno/blob/master/zeno/include/zeno/utils/format.h">https://github.com/zenustech/zeno/blob/master/zeno/include/zeno/utils/format.h</a></li></ol></li></ol><h2 id="五、字符串流"><a href="#五、字符串流" class="headerlink" title="五、字符串流"></a>五、字符串流</h2><h3 id="cout-支持十六进制"><a href="#cout-支持十六进制" class="headerlink" title="cout 支持十六进制"></a>cout 支持十六进制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;十六进制：&quot;</span> &lt;&lt; hex &lt;&lt; <span class="number">42</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// 十六进制：2a</span></span><br></pre></td></tr></table></figure><h3 id="使用stringstream-取代-to-string"><a href="#使用stringstream-取代-to-string" class="headerlink" title="使用stringstream 取代 to_string"></a>使用stringstream 取代 to_string</h3><p>官方推荐用 stringstream 取代 to_string</p><p>cout 这么方便，能不能让他不要直接输出到控制台，而是把结果存到一个字符串呢？这正是字符串流 stringstream 的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="string">&quot;十六进制：&quot;</span> &lt;&lt; hex &lt;&lt; <span class="number">42</span>;</span><br><span class="line">  string s = ss.<span class="built_in">str</span>();<span class="comment">//重新获取</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 十六进制：2a</span></span><br></pre></td></tr></table></figure><p>和 cout 完全一样，同样的 &lt;&lt; 和 hex 选项。但是他的输出会保存到一个字符串里。</p><p>调用成员函数 .str() 就能取出这个字符串了。之后这个字符串就可以用作其他用途，比如printf 打印，或者用于查询数据库，都没问题。</p><p>这里比较无聊，最后还是直接输出到了 cout。</p><h3 id="stringstream-也可以取代-stoi"><a href="#stringstream-也可以取代-stoi" class="headerlink" title="stringstream 也可以取代 stoi"></a>stringstream 也可以取代 stoi</h3><p>刚刚展示了 stringstream 模仿 cout 的方法。</p><p>stringstream 也可以模仿 cin，用 &gt;&gt; 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;42yuan&quot;</span>s;</span><br><span class="line">  <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  ss &gt;&gt; num;</span><br><span class="line">  string unit;</span><br><span class="line">  ss &gt;&gt; unit;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;数字：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;单位：&quot;</span> &lt;&lt; unit &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数字：42</span></span><br><span class="line"><span class="comment">// 单位：yuan</span></span><br></pre></td></tr></table></figure><p>总结：</p><p><code>&lt;&lt;</code> 可以模仿 cout，取代 to_string。</p><p><code>&gt;&gt;</code>可以模仿 cin，取代 stoi&#x2F;stof&#x2F;stod。</p><p>最重要的是他支持各种控制选项（如 hex）， 功能性比 to_string 和 stoi 更强大。</p><p>要导入他，只需 <code>#include &lt;sstream&gt;</code> 即可。</p><h2 id="六、字符串常用操作"><a href="#六、字符串常用操作" class="headerlink" title="六、字符串常用操作"></a>六、字符串常用操作</h2><h3 id="at-获取指定位置的字符"><a href="#at-获取指定位置的字符" class="headerlink" title="at 获取指定位置的字符"></a>at 获取指定位置的字符</h3><p>s.at(i) 和 s[i] 都可以获取字符串中的第 i 个字符。</p><p>区别在于 at 如果遇到 i 越界的情况，也就是检测到 <code>i ≥ s.size()</code> 时，会抛出 <code>std::out_of_range</code> 异常终止程序。使用 gdb 等调试器就可以在出这个异常的时候暂停，帮你调试错误。也可以从外部函数 catch 住这个异常（以后再讲）。</p><p>而 <code>[]</code> 则不会抛出异常，他只是简单地给字符串的首地址指针和 i 做个加法运算，得到新的指针并解引用。如果你给的 i 超过了字符串大小 i ≥ s.size()，那程序的行为是未定义的，因为这个地方可能有其他的对象，程序可能会奔溃，也可能行为异常。如果是互联网程序，还可能会被黑客利用，窃取或篡改服务器上的数据。</p><ul><li>那为什么还要 <code>[]</code>？<strong>性能！</strong>at 做越界检测需要额外的开销，<code>[]</code> 不需要。</li><li>所以 <code>[]</code> 更高效，at 更安全。遇到诡异 bug 时，试试把 <code>[]</code> 都改成 at。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第0个字符:  &quot;</span> &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第3个字符:  &quot;</span> &lt;&lt; s[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第16个字符: &quot;</span> &lt;&lt; s[<span class="number">16</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第0个字符:  &quot;</span> &lt;&lt; s.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第3个字符:  &quot;</span> &lt;&lt; s.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第16个字符: &quot;</span> &lt;&lt; s.<span class="built_in">at</span>(<span class="number">16</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第0个字符:  h</span></span><br><span class="line"><span class="comment">// 第3个字符:  l</span></span><br><span class="line"><span class="comment">// 第16个字符: ??</span></span><br><span class="line"><span class="comment">// 第0个字符:  h</span></span><br><span class="line"><span class="comment">// 第3个字符:  l</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"><span class="comment">//   what():  basic_string::at: __n (which is 16) &gt;= this-&gt;size() (which is 10)</span></span><br></pre></td></tr></table></figure><h3 id="获取字符串长度的两种写法。。。"><a href="#获取字符串长度的两种写法。。。" class="headerlink" title="获取字符串长度的两种写法。。。"></a>获取字符串长度的两种写法。。。</h3><p>s.length() 和 s.size() 等价。</p><p>其中 size 是和 vector 一样的名字，方便程序员理解。</p><p>但是为什么标准委员会还要发明一个一模一样的 length？“孔乙己直呼内行”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="substr-切下一段子字符串"><a href="#substr-切下一段子字符串" class="headerlink" title="substr 切下一段子字符串"></a>substr 切下一段子字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型为：</span></span><br><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = <span class="number">-1</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>substr(pos, len) 会截取从第 pos 个字符开始，长度为 len 的子字符串，原字符串不会改变。</p><p>如果原字符串剩余部分长度不足 len，则返回长度小于 len 的子字符串而不会出错。</p><p>如果 pos 超出了原字符串的范围，则抛出 std::out_of_range 异常（和 at 同款的哦）。</p><p>可以指定 len 为 -1（即 string::npos），此时会截取从 pos 开始直到原字符串末尾的子字符串。</p><p>不指定第二参数 len 时，默认的 len 就是 -1（见下方第三个例子）。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) = “ell”</span><br><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">99</span>) = “ello”</span><br><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="built_in">substr</span>(<span class="number">1</span>) = “ello”</span><br><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) = “hel”</span><br><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="built_in">substr</span>(<span class="number">99</span>, <span class="number">3</span>) = 抛出 std::out_of_range 异常</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;从第2个字符开始长为5的子字符串:    &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;从第2个字符开始长为99的子字符串:   &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">99</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;从第2个字符开始直到末尾的子字符串: &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;从头开始长为5的子字符串:           &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;从第100个字符开始长为5的子字符串:  &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">100</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从第2个字符开始长为5的子字符串:    llow</span></span><br><span class="line"><span class="comment">// 从第2个字符开始长为99的子字符串:   lloworld</span></span><br><span class="line"><span class="comment">// 从第2个字符开始直到末尾的子字符串: lloworld</span></span><br><span class="line"><span class="comment">// 从头开始长为5的子字符串:           hell</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"><span class="comment">//   what():  basic_string::substr: __pos (which is 100) &gt; this-&gt;size() (which</span></span><br><span class="line"><span class="comment">//   is 10)</span></span><br></pre></td></tr></table></figure><h3 id="find-寻找子字符串"><a href="#find-寻找子字符串" class="headerlink" title="find 寻找子字符串"></a>find 寻找子字符串</h3><h4 id="单个字符"><a href="#单个字符" class="headerlink" title="单个字符"></a>单个字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find 拥有众多重载，我们一个个来看。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(string_view svt, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(string <span class="type">const</span> &amp;str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>为什么最后两个重载没有标记 noexcept？历史原因，实际上 find 函数都是不会抛出异常的，他找不到只会返回 -1。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;寻找h的结果：&quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;寻找e的结果：&quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;e&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;寻找l的结果：&quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;l&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;寻找o的结果：&quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;寻找H的结果：&quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;H&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;(size_t) -1：&quot;</span> &lt;&lt; (<span class="type">size_t</span>)<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找h的结果：0</span></span><br><span class="line"><span class="comment">// 寻找e的结果：1</span></span><br><span class="line"><span class="comment">// 寻找l的结果：2</span></span><br><span class="line"><span class="comment">// 寻找o的结果：4</span></span><br><span class="line"><span class="comment">// 寻找H的结果：18446744073709551615</span></span><br><span class="line"><span class="comment">// (size_t) -1：18446744073709551615</span></span><br></pre></td></tr></table></figure><p>find(‘c’) 会在字符串中查找字符 ‘c’，如果找到，返回这个字符第一次出现所在的位置。如果找不到，返回 -1。</p><ul><li>注意：如果原字符串中 ‘c’ 出现了多次，则只会返回第一个出现的位置。例如 “icatchthecat”.find(‘c’) 会返回 1，因为他找到的是第二个字符 ‘c’，而计算机数数从 0 开始，所以他认为是第 1 个没毛病。</li></ul><p>find(‘c’, pos) 会在字符串中查找字符 ‘c’，不同的是他会从第 pos 个字符开始，例如 “icatchthecat”.find(‘c’, 3) 会返回 4，因为是从第 3 个字符 ‘t’ 开始查找（人类看来是第四个），所以第一个 ‘c’ 被略过。</p><p>如果 pos 所在的位置刚好就是 ‘c’，那么会返回 pos，例如 “icatchthecat”.find(‘c’, 4) 会返回 4。</p><h4 id="size-t-1-更专业的写法"><a href="#size-t-1-更专业的写法" class="headerlink" title="(size_t)-1 更专业的写法"></a>(size_t)-1 更专业的写法</h4><p>其实 string 类里定义了一个静态常量 npos，其值为 (size_t)-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; boolalpha;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;h: &quot;</span> &lt;&lt; (s.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>) != string::npos) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; (s.<span class="built_in">find</span>(<span class="string">&#x27;z&#x27;</span>) != string::npos) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// h: true</span></span><br><span class="line"><span class="comment">// z: false</span></span><br></pre></td></tr></table></figure><p>我们使用时，可以用 std::string::npos 代替看起来很不专业的 -1。</p><p>因此，要查询一个字符串是否包含某一字符，可以写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(c) != string::npos</span><br><span class="line">s.<span class="built_in">find</span>(c) != s.npos</span><br><span class="line">s.<span class="built_in">find</span>(c) != (<span class="type">size_t</span>)<span class="number">-1</span></span><br><span class="line">s.<span class="built_in">find</span>(c) != <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>都是等价的</p><h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>同理也有 <code>find(&quot;str&quot;, pos)</code> 是从第 pos 个字符开始查找子字符串 “str”，例如</p><p><code>&quot;hellohello&quot;.find(&quot;lo&quot;, 4)</code> 会得到 8，因为 pos 为 4，前四个字符被排除掉了，这样其实等价于 <code>&quot;ohello&quot;.find(&quot;lo&quot;) + 4</code>。</p><p>此外还有 <code>find(&quot;str&quot;, pos, len)</code> 和<code>find(&quot;str&quot;.substr(0, len), pos)</code> 等价，用于要查询的字符串已经确定长度，或者要查询的字符串是个切片（string_view）的情况。若不指定这个长度 len，则默认是 C 语言的 0 结尾字符串，find 还要去求 len &#x3D; strlen(“str”)，相对低效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">  cout &lt;&lt; boolalpha;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;lo: &quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;lo&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;wo: &quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;wo&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ma: &quot;</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;ma&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lo: 3</span></span><br><span class="line"><span class="comment">// wo: 5</span></span><br><span class="line"><span class="comment">// ma: 18446744073709551615</span></span><br></pre></td></tr></table></figure><h4 id="find应用案例：计算子字符串出现了多少次"><a href="#find应用案例：计算子字符串出现了多少次" class="headerlink" title="find应用案例：计算子字符串出现了多少次"></a>find应用案例：计算子字符串出现了多少次</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(string <span class="type">const</span> &amp;str, string <span class="type">const</span> &amp;sub)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> n = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    pos = str.<span class="built_in">find</span>(sub, pos);</span><br><span class="line">    <span class="keyword">if</span> (pos == str.npos) <span class="keyword">break</span>;</span><br><span class="line">    ++n;</span><br><span class="line">    pos += sub.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">count</span>(<span class="string">&quot;helloworld,bellreally&quot;</span>s, <span class="string">&quot;ll&quot;</span>s) &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="反向查找-rfind"><a href="#反向查找-rfind" class="headerlink" title="反向查找 rfind"></a>反向查找 rfind</h4><p>find 是从字符串头部开始查找，返回第一次出现的地方。</p><p>而 rfind 则是从尾部开始查找，返回最后一次出现的地方。</p><p>例如 <code>“helloworld”.rfind(‘l’)</code> 会返回 8，因为 rfind 是优先从尾部开始查找的。</p><p>rfind 和 find 的最坏复杂度都为 O(n)，最好复杂度都为 O(1)。</p><h4 id="find-first-of-寻找集合内任意字符"><a href="#find-first-of-寻找集合内任意字符" class="headerlink" title="find_first_of 寻找集合内任意字符"></a>find_first_of 寻找集合内任意字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(string <span class="type">const</span> &amp;s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p><code>&quot;str&quot;.find_first_of(&quot;chset&quot;, pos)</code> 会从第 pos 个字符开始，在 “str” 中找到第一个出现的 ‘c’ 或 ‘h’ 或 ‘s’ 或 ‘e’ 或 ‘t’ 字符，并返回他所在的位置。如果都找不到，则会返回 -1（string::npos）。</p><p>没错，这个 “chset” 是个字符的<strong>集合</strong>，顺序无所谓，重复没有用。</p><p>如果不指定 pos，默认为 0，从头开始查找。</p><p>其实 <code>s.find_first_of(“chset”)</code> 等价于 <code>min(s.find(‘c’), s.find(‘h’), s.find(‘s’), s.find(‘e’), s.find(‘t’))</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;helloworld&quot;</span>s;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">find_first_of</span>(<span class="string">&quot;onl&quot;</span>);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="应用案例：按空格分割字符串"><a href="#应用案例：按空格分割字符串" class="headerlink" title="应用案例：按空格分割字符串"></a>应用案例：按空格分割字符串</h4><p>刚刚说 ASCII 的时候提到过 isspace 这个函数，他会把 ‘ ’、‘\t’、‘\v’、‘\f’、‘\n’、‘\r’ 识别为空格（因为他们显示出来的确都是空的），我姑且称之为空格类字符（whitespace）。</p><p>如何找到第一个出现的空格类字符？如果要找第一个出现的空格，可以用 s.find(‘ ’)，如果要找到第一个出现的空格类字符？空格类字符是一个集合 {‘ ’, ‘\t’, ‘\v’, ‘\f’, ‘\n’, ‘\r’}，可以作为一个字符串来传给 find_first_of，例如：s.find_first_of(“ \t\v\f\n\r”)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  vector&lt;string&gt; ret;</span><br><span class="line">  <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> newpos = s.<span class="built_in">find_first_of</span>(<span class="string">&quot; \t\v\f\n\r&quot;</span>, pos);</span><br><span class="line">    <span class="keyword">if</span> (newpos == s.npos) &#123;</span><br><span class="line">      ret.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(pos, newpos));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(pos, newpos - pos));</span><br><span class="line">    pos = newpos + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;hello world\tpyb teacher\ngood job&quot;</span>s;</span><br><span class="line">  vector&lt;string&gt; v = <span class="built_in">split</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;vi : v) &#123;</span><br><span class="line">    cout &lt;&lt; vi &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(string) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// pyb</span></span><br><span class="line"><span class="comment">// teacher</span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// job</span></span><br><span class="line"><span class="comment">// 32</span></span><br></pre></td></tr></table></figure><h4 id="find-first-not-of-寻找不在集合内的字符"><a href="#find-first-not-of-寻找不在集合内的字符" class="headerlink" title="find_first_not_of 寻找不在集合内的字符"></a>find_first_not_of 寻找不在集合内的字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;hello world, pyb teacher? good job!&quot;</span>s;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; abcdefghijklmnopqrstuvwxyz&quot;</span>);</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h4 id="举一反三：find-last-of、find-last-not-of"><a href="#举一反三：find-last-of、find-last-not-of" class="headerlink" title="举一反三：find_last_of、find_last_not_of"></a>举一反三：find_last_of、find_last_not_of</h4><ul><li><p>find 的反向版本是 rfind。</p></li><li><p>find_first_of 的反向版本是 find_last_of。</p></li><li><p>find_first_not_of 的反向版本是 find_last_not_of。</p></li></ul><h3 id="replace-替换一段子字符串"><a href="#replace-替换一段子字符串" class="headerlink" title="replace 替换一段子字符串"></a>replace 替换一段子字符串</h3><p><code>replace(pos, len, “str”)</code> 会把从 pos 开始的 len 个字符替换为 “str”。</p><ul><li>例如 “helloworld”.replace(4, 2, “pful”) 会得到 “helpfulworld”。</li></ul><p>如果 len 过大，超出了字符串的长度，则会自动截断，相当于从 pos 开始到末尾都被替换。</p><ul><li>例如 “helloworld”.replace(4, 100, “pful”) 会得到 “helpful”。</li></ul><p>如果 pos 过大，超出了字符串的长度，则抛出 out_of_range 异常。</p><ul><li>例如 “helloworld”.replace(400, 2, “pful”) 会得到异常（和 at 同款）</li></ul><p><strong>启发性提示：</strong>因为 -1 转换为 size_t 后是个很大的数（因为补码的规则，他实际上变成 0xffffffffffffffff），所以可以给 len 指定 -1（或者 string::npos）来迫使 replace 从 4 开始一直到字符串末尾都替换掉，例如<code>“helloworld”.replace(4, -1, “pful”)</code> 会得到 “helpful”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;make pyb happy&quot;</span>s;</span><br><span class="line">  s.<span class="built_in">replace</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="string">&quot;zhxx&quot;</span>);  <span class="comment">// 变成 make zhxx happy</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// make zhxx happy</span></span><br></pre></td></tr></table></figure><p>刚刚的例子 <strong>“helloworld”.replace(4, 2, “pful”)</strong> 会得到 “<strong>helpfulworld</strong>”。</p><ul><li>性能小贴士：string 的本质和 vector 一样，是内存中连续的数组。注意这里原来 [4, 4+2) 这里的子字符串为 “lo”，替换成 “pful”。而因为 “pful” 比 “lo” 宽了 2 格，所以为了预留出这 2 格额外的空间，就得把后面的 “world” 在内存中整体平移了 2 格（和 vector 的 insert 一样）。这意味着 replace 最坏是 <strong>O(n)</strong> 复杂度的。</li><li>然而如果原来的子字符串和新的子字符串一样长度，例如 <code>“helloworld”.replace(4, 2, “pf”)</code> 会得到 “helpfworld” 则后面的 “world” 不需要被平移，是最好的 <strong>O(1)</strong> 复杂度……好吧，其实是 <strong>O(len)</strong> 复杂度，len 就是这里子字符串的长度 2。</li></ul><p>此外，要注意 replace 会<strong>就地修改原字符串</strong>，返回的是指向原对象的引用，并不是一份新的拷贝！这是标准库的设计者为了性能考虑。</p><h4 id="边界情况总结"><a href="#边界情况总结" class="headerlink" title="边界情况总结"></a>边界情况总结</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos, len = <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>如果 pos &gt; s.size()，则抛出 out_of_range 异常。</p><p>如果 pos + len ≥ s.size()，则截断超出的部分，只返回小于 len 的子字符串。</p><p>如果不指定 len 则默认为 -1，这时会一直从 pos 开始到字符串结尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(str, pos = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>如果找不到子字符串 str 则返回 -1（也就是 string::npos）。</p><p>如果 pos ≥ s.size()，则总是返回 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(pos, len, str)</span><br></pre></td></tr></table></figure><p>如果 pos ≥ s.size() 则抛出 out_of_range 异常。</p><p>如果 pos + len &gt; s.size() 则会扩容字符串 s.resize(pos + len)。</p><h3 id="append追加一段字符串"><a href="#append追加一段字符串" class="headerlink" title="append追加一段字符串"></a>append追加一段字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = “hello”;</span><br><span class="line">s += “world”;</span><br></pre></td></tr></table></figure><p>最后 s 会得到 “helloworld”。</p><p>这里的 +&#x3D; 也可以换做 append 函数，基本一样，没什么好说的。</p><p>例如 s.append(“world”) 和 s +&#x3D; “world” 等价。</p><p>区别在于 append 还可以指定第二个参数，限定字符串长度，用于要追加的字符串已经确定长度，或者是个切片的情况（string_view）。</p><p>例如 <code>s.append(“world”, 3)</code> 和 <code>s += string(“world”, 3)</code> 和 <code>s += “wor”</code> 等价。</p><p>性能如何？append 的扩容方式和 vector 的 push_back 一样，每次超过 capacity 就预留两倍空间，所以重复调用 append 的复杂度其实是 <strong>amortized O(n)</strong> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s;</span><br><span class="line"></span><br><span class="line">  s = <span class="string">&quot;hello, &quot;</span>s;</span><br><span class="line">  s.<span class="built_in">append</span>(<span class="string">&quot;world&quot;</span>s);  <span class="comment">// &quot;hello, world&quot;</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  s = <span class="string">&quot;hello, &quot;</span>s;</span><br><span class="line">  s.<span class="built_in">append</span>(<span class="string">&quot;world&quot;</span>);  <span class="comment">// &quot;hello, world&quot;</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  s = <span class="string">&quot;hello, &quot;</span>s;</span><br><span class="line">  s.<span class="built_in">append</span>(<span class="string">&quot;world&quot;</span>s, <span class="number">3</span>);  <span class="comment">// &quot;hello, ld&quot;</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  s = <span class="string">&quot;hello, &quot;</span>s;</span><br><span class="line">  s.<span class="built_in">append</span>(<span class="string">&quot;world&quot;</span>, <span class="number">3</span>);  <span class="comment">// &quot;hello, wor&quot;</span></span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// hello, world</span></span><br><span class="line"><span class="comment">// hello, ld</span></span><br><span class="line"><span class="comment">// hello, wor</span></span><br></pre></td></tr></table></figure><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(string <span class="type">const</span> &amp;str)</span></span>;<span class="comment">// str 是 C++ 字符串类 string 的对象</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>; <span class="comment">// s 是长度为 strlen(s) 的 0 结尾字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(string <span class="type">const</span> &amp;str, <span class="type">size_t</span> len)</span></span>;<span class="comment">// 只保留后 str.size() - len 个字符</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span>;<span class="comment">// 只保留前 len 个字符</span></span><br></pre></td></tr></table></figure><p>前面两个是最常用的版本，和 +&#x3D; 也是等价的。后面两个带 len 的版本很奇怪，他们居然是反过来的：</p><ul><li><p>对于 str 是 string 类型时，会变成保留后半部分。</p></li><li><p>对于 str 是 const char * 类型时，会保留前半部分。</p></li></ul><p>为什么是这样？我们也无从得知，可能是历史原因。猜想是因为 <code>const char *</code> 指针可以自身进行 +&#x3D; 操作来去除开头的任意部分，所以要让 len 控制尾部的部分；而 string 类型可以自身进行 resize 操作来去除尾部的任意部分，所以用 len 控制开头的部分。</p><p>为了一点点破性能，弄这么多重载，不过这些都已经无所谓了，因为 C++17 中有更为直观的 string_view，要切片只需 substr，例如：</p><p><code>s.append(“world”, 3)</code> 改成 <code>s += string_view(“world”).substr(0, 3)</code></p><p><code>s.append(“world”s, 3)</code> 改成 <code>s += string_view(“world”).substr(3)</code></p><p>又高效，又直观易懂，且 substr 附带了自动检查越界的能力，安全。</p><p><code>string_view(“world”)</code> 也可以简写作 <code>“world”sv</code>，我们稍后再详细谈谈。</p><h3 id="insert-插入一段字符串"><a href="#insert-插入一段字符串" class="headerlink" title="insert 插入一段字符串"></a>insert 插入一段字符串</h3><p><code>s.insert(pos, str)</code> 会把子字符串 pos 插入到原字符串中第 pos 个字符和第 pos+1 个字符之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;HELLO&quot;</span>s;</span><br><span class="line">  s.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HEworldLLO</span></span><br></pre></td></tr></table></figure><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, string <span class="type">const</span> &amp;str)</span></span>;<span class="comment">// str 是 C++ 字符串类 string 的对象</span></span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">// s 是长度为 strlen(s) 的 0 结尾字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, string <span class="type">const</span> &amp;str, <span class="type">size_t</span> len)</span></span>;<span class="comment">// 只保留后 str.size() - len 个字符</span></span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span>;<span class="comment">// 只保留前 len 个字符</span></span><br></pre></td></tr></table></figure><p>后两个版本和 append 的情况一样诡异……通常我们只用前两个就行。</p><p>又是一个就地修改字符串，返回指向自身引用的函数……</p><p>当然，更直观的做法，还是 substr 配合 + 运算符（左）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;HELLO&quot;</span>s;</span><br><span class="line">  s = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>) + <span class="string">&quot;world&quot;</span>s + s.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HEworldLLO</span></span><br></pre></td></tr></table></figure><p>同理，可以先转换为 string_view 再 substr，高效切片，没有性能损失（右）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="string">&quot;HELLO&quot;</span>s;</span><br><span class="line">  string_view sv = s;</span><br><span class="line">  string news;</span><br><span class="line">  news += sv.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">  news += <span class="string">&quot;world&quot;</span>sv;</span><br><span class="line">  news += sv.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; news &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HEworldLLO</span></span><br></pre></td></tr></table></figure><h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><h4 id="关于运算符-、-、-、-、"><a href="#关于运算符-、-、-、-、" class="headerlink" title="关于运算符 &#x3D;&#x3D;、!&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;"></a>关于运算符 &#x3D;&#x3D;、!&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;</h4><p>我们 set 那一章说过了，字符串的大于小于运算符，是按字典序比较的。</p><p>他会按<strong>字典序</strong>比较两个字符串。所谓字典序就是优先比较两者第一个字符（按 ASCII 码比较），如果相等则继续比较第二个字符，不相等则直接以这个比较的结果返回，第二个比完比第三个……如果比到末尾全都相等，分两种情况：</p><p>其中一个字符串比较短，则认为长的字符串大于短的字符串。</p><p>两个字符串长度也一样，则认为两者相等。</p><p>例如：</p><ul><li>“azazel” &#x3D; “azazel”     因为完全一样啊        比较了 6 次</li><li>“azazel” &gt; “az”         因为长度 6 &gt; 2        比较了 3 次</li><li>“azazel” &lt; “linux”       因为第一个字符 ‘a’ &lt; ‘l’  比较了 1 次</li><li>“azazel” &gt; “application”  因为第二个字符 ‘z’ &gt; ‘p’  比较了 2 次</li></ul><h4 id="通用的比较函数-compare"><a href="#通用的比较函数-compare" class="headerlink" title="通用的比较函数 compare"></a>通用的比较函数 compare</h4><p>不管是 &gt;、&lt; 还是 &#x3D;&#x3D;，都只能一次比较出一个 bool 结果。</p><p>其实 C 语言的 strcmp(a, b) 不仅可以判断相等，也可以用于字典序比较，返回 -1 代表 a &lt; b，返回 1 代表 a &gt; b，返回 0 代表 a &#x3D;&#x3D; b。</p><p>这就是为什么 strcmp 最常用的写法是 !strcmp(a, b) 判断两者相等。</p><p>因此 string 也有一个成员函数 compare，他也是返回 -1、1、0 表示大小关系。此外，C++20 中引入了 <code>&lt;=&gt;</code> 这个万能比较运算符，意在取代 compare 成为标准，不过这个更加强类型一点。</p><p>总之，a &#x3D;&#x3D; b 和 !a.compare(b) 等价。</p><h4 id="C-20新增：starts-with-和-ends-with"><a href="#C-20新增：starts-with-和-ends-with" class="headerlink" title="C++20新增：starts_with 和 ends_with"></a>C++20新增：starts_with 和 ends_with</h4><p><code>s.starts_with(str)</code> 等价于 <code>s.substr(0, str.size()) == str</code></p><p><code>s.ends_with(str)</code> 等价于 s.substr(str.size()) &#x3D;&#x3D; str</p><p>他们不会抛出异常，只会返回 true 或 false，表示 s 是否以 str 开头。例如：</p><p><code>“hello”.starts_with(“he”)</code> 会得到 true。</p><p><code>“hello”.ends_with(“lo”)</code> 会得到 true。</p><p>其实也有单个字符：“hello”.starts_with(‘h’) 的用法，他等价于 “hello”.size() !&#x3D; 0 &amp;&amp; “hello”[0] &#x3D;&#x3D; ‘h’。</p><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ul><li><p>at, [], data, size, resize, empty, clear</p></li><li><p>capacity, reserve, shrink_to_fit</p></li><li><p>insert, erase, assign, push_back, pop_back, front, back</p></li><li><p>begin, end, rbegin, rend, swap, move</p></li></ul><p>string 在这些函数上都和 <code>vector&lt;char&gt;</code> 一样，vector 那一章讲的几乎全部知识也适用于 string。</p><h2 id="七、字符串胖指针"><a href="#七、字符串胖指针" class="headerlink" title="七、字符串胖指针"></a>七、字符串胖指针</h2><h3 id="0结尾字符串的缺点"><a href="#0结尾字符串的缺点" class="headerlink" title="0结尾字符串的缺点"></a>0结尾字符串的缺点</h3><p>众所周知，要描述一个动态长度的数组（此处为字符串），需要<strong>首地址指针</strong>和<strong>数组长度</strong>两个参数</p><p>这样好麻烦，明明是一个字符串，却要传两个参数进去！能不能简化？</p><p>C 语言认为：假定字符串中的字符不可能出现 ‘\0’，那么可以用 ‘\0’ 作为结尾的标记符，这就是当年最流行的 0 结尾字符串（null-terminated string）方案。</p><p>这就出现了很多</p><ol><li><strong>字符串本身不能含有‘\0’</strong></li></ol><ul><li><p>例如：{‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’, ‘c’, ‘p’, ‘p’} 则只有前五个字符是有效的。</p></li><li><p>因此 printf(“hello\0cpp”); 只会打印 “hello” 而没有 ‘\0’ 后面的字符，因为 printf 只收到了一个首地址指针，他只好把出现 ‘\0’ 的位置当做字符的结尾。</p></li><li><p>对于字符串来说好像无所谓（谁说话会带个 ‘\0’ 啊），但是对于其他类型的数据，比如科学家用一个浮点数组，一不小心算出个 0.0 就自动结束了，不合理。</p></li></ul><ol start="2"><li><p>‘\0’ 本身也是一个字符，<strong>需要占据额外的空间</strong>，因此长度为 n 的字符串实际上需要 n + 1 的内存空间，末尾多出来的那一格空间存放 ‘\0’ 标志结束。</p></li><li><p><strong>计算长度需要耗费时间</strong>，你必须从起始地址开始，一个个向后查找，直到找到 ‘\0’，才能确定字符串在哪里结束，确定他的长度。换言之，strlen 函数的复杂度为 O(n)，如果需要频繁的查询长度，势必会非常低效。</p></li><li><p>若需要<strong>在尾部切片就得修改字符串本身</strong>（写入一个 ‘\0’），影响其他弱引用。</p></li></ol><h3 id="胖指针大法横空出世"><a href="#胖指针大法横空出世" class="headerlink" title="胖指针大法横空出世"></a>胖指针大法横空出世</h3><p>刚刚说了，要描述一个动态长度的数组（此处为字符串），需要<strong>首地址指针</strong>和<strong>数组长度</strong>两个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cihou_array</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>可以把这描述同一个东西的两个参数，打包进一个结构体（struct）里，这样就可以作为一个参数了！虽然本质上是一样的，但是代码变得更易读了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FatPtr</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ptr;</span><br><span class="line">  <span class="type">size_t</span> len;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cihou_array</span><span class="params">(FatPtr fptr)</span></span>;</span><br></pre></td></tr></table></figure><p>这就是 rust 炫耀已久的数组胖指针。C++20 中的 span 也是这个思想。</p><p>他提倡<strong>把</strong> <strong>ptr和len这两个逻辑上相关的参数绑在一起</strong>，避免程序员犯错。</p><p>其实胖指针的思想既不是 rust 原创的，也不是 C++20 以后才出现的。</p><p>为了表示动态长度的数组，C++ 中的 vector 和 string 其实都是胖指针。</p><p>string 和 vector 内部都有三个成员变量：ptr, len, capacity。</p><p>前两个 [ptr, len] 其实就是表示实际有效范围（存储了字符的）的胖指针。</p><p>而 [ptr, capacity] 就是表示实际已分配内存（操作系统认为的）的胖指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"> <span class="type">char</span> *ptr;</span><br><span class="line"> <span class="type">size_t</span> len;</span><br><span class="line"> <span class="type">size_t</span> capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 GCC 的实现中，被换成了三个指针 [ptr, ptr + len, ptr + capacity] 来表示。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029203208053.png" class="" title="image-20241029203208053"><p>但本质上是一样的，你去看 rust，他们的 vec 也是这三个成员，没什么创新的， rust 的贡献，无非是把这个概念定义为专有名词“胖指针”，仅此而已。</p><p>C++ 的 string 克服了 C 语言 0 结尾字符串的缺点：</p><ul><li><p>字符串本身可以含有 ‘\0’ 了，这下任何字符都众生平等。</p></li><li><p>末尾没有 ‘\0’ 额外浪费的空间（除非调用 c_str 时）。</p></li><li><p>长度已经存储在 string 的成员里，size() 是 O(1) 的。</p></li><li><p>在尾部切片可以用 resize() 修改长度，无需写入字符串本身。</p></li></ul><p>string_view 和 span 无非是个弱引用版本，额外增加了在头部切片的能力而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;hello\0cpp&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;hello\0cpp&quot;</span>, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hellocpp</span></span><br></pre></td></tr></table></figure><h3 id="强引用胖指针：string"><a href="#强引用胖指针：string" class="headerlink" title="强引用胖指针：string"></a>强引用胖指针：string</h3><p>刚刚说的 string 容器，是掌握着字符串生命周期（lifespan）的胖指针。</p><p>这种掌管了所指向对象生命周期的指针称为强引用（strong reference）。</p><p>这个强引用的强，体现在哪里？</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029203640008.png" class="" title="image-20241029203640008"><p>当 string 容器被拷贝时，其指向的字符串也会被拷贝（深拷贝）。</p><p>当 string 容器被销毁时，其指向的字符串也会被销毁（内存释放）。</p><h3 id="弱引用胖指针：string-VIEW"><a href="#弱引用胖指针：string-VIEW" class="headerlink" title="弱引用胖指针：string_VIEW"></a>弱引用胖指针：string_VIEW</h3><p>如果把一个强引用的 string 到处拷贝来拷贝去，则其指向的字符串也会被多次拷贝，比较低效。人们常用 string const &amp; 来避免不必要拷贝，但仍比较麻烦。</p><p>因此 C++17 引入了弱引用胖指针 <strong>string_view</strong>，这种弱引用（weak reference）不影响原对象的生命周期，原对象的销毁仍然由强引用控制。</p><p>这个弱引用的弱，体现在哪里？</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241029203818966.png" class="" title="image-20241029203818966"><p>当 string_view 被拷贝时，其指向的字符串仍然是同一个（浅拷贝）。</p><p>当 string_view 被销毁时，其指向的字符串仍存在（弱引用不影响生命周期）。</p><p>举例解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2 = s1;         <span class="comment">// 深拷贝</span></span><br><span class="line">  string_view sv1 = s1;   <span class="comment">// 弱引用</span></span><br><span class="line">  string_view sv2 = sv1;  <span class="comment">// 浅拷贝</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;s1=&quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;s2=&quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sv1=&quot;</span> &lt;&lt; sv1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sv2=&quot;</span> &lt;&lt; sv2 &lt;&lt; endl;</span><br><span class="line">  s1[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;修改s1后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;s1=&quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;s2=&quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sv1=&quot;</span> &lt;&lt; sv1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sv2=&quot;</span> &lt;&lt; sv2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s1=hello</span></span><br><span class="line"><span class="comment">// s2=hello</span></span><br><span class="line"><span class="comment">// sv1=hello</span></span><br><span class="line"><span class="comment">// sv2=hello</span></span><br><span class="line"><span class="comment">// 修改s1后</span></span><br><span class="line"><span class="comment">// s1=Bello</span></span><br><span class="line"><span class="comment">// s2=hello</span></span><br><span class="line"><span class="comment">// sv1=Bello</span></span><br><span class="line"><span class="comment">// sv2=Bello</span></span><br></pre></td></tr></table></figure><p>s2 是对 s1 的深拷贝（调用了 string 的拷贝构造函数）所以 s1 被修改时，s2 仍保持旧的值 “hello” 不变。</p><p>sv1 和 sv2 都是指向 s1 的弱引用，所以 s1 被改写时，sv1 和 sv2 看到的字符串也改写了。</p><h3 id="强弱引用的安全守则"><a href="#强弱引用的安全守则" class="headerlink" title="强弱引用的安全守则"></a>强弱引用的安全守则</h3><p>强引用和弱引用都可以用来访问对象。</p><p><strong>每个存活的对象，强引用有且只有一个。</strong></p><p><strong>但弱引用可以同时存在多个，也可以没有</strong>。</p><p><strong>强引用销毁时，所有弱引用都会失效</strong>。如果强引用销毁以后，仍存在其他指向该对象的弱引用，访问他会导致程序奔溃（野指针）。</p><p><strong>弱引用失效举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string_view sv1 = s1;</span><br><span class="line">  s1[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; sv1 &lt;&lt; endl;  <span class="comment">// 不会失效</span></span><br><span class="line">  s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">  cout &lt;&lt; sv1 &lt;&lt; endl;  <span class="comment">// 失效!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Mello</span></span><br><span class="line"><span class="comment">// hello成功打印是因为小字符串优化，存储在栈内，我们后边会详细解释</span></span><br></pre></td></tr></table></figure><p>被引用的 string 本体修改的时候，原先生成的 string_view 会失效（因为 ptr 和 len 改变了）。</p><p>因此建议创建 string_view 以后，不要改写原字符串。</p><h3 id="常见容器及其相应的弱引用："><a href="#常见容器及其相应的弱引用：" class="headerlink" title="常见容器及其相应的弱引用："></a>常见容器及其相应的弱引用：</h3><table><thead><tr><th><strong>强引用</strong></th><th><strong>弱引用</strong></th></tr></thead><tbody><tr><td>string</td><td>string_view</td></tr><tr><td>wstring</td><td>wstring_view</td></tr><tr><td>vector<T></td><td>span<T></td></tr><tr><td>unique_ptr<T></td><td>T  *</td></tr><tr><td>shared_ptr<T></td><td>weak_ptr<T></td></tr></tbody></table><h3 id="string-view的应用"><a href="#string-view的应用" class="headerlink" title="string_view的应用"></a>string_view的应用</h3><h4 id="字符串用substr切片"><a href="#字符串用substr切片" class="headerlink" title="字符串用substr切片"></a>字符串用substr切片</h4><p>熟悉 Python 的同学对切片(slice)操作肯定不陌生，例如：</p><p><code>“hello”[1:1+3] 会得到 “ell”。</code></p><p>刚刚说到，在 C++ 中，可以用 substr 函数进行切片，例如：</p><p><code>string(“hello”).substr(1, 3) 会得到 “ell”。</code> </p><p>这样其实不是最高效的（性能强迫症狂喜），因为 string.substr 并不是就地修改字符串，他是返回一个全新的 string 对象，然后把原字符串里的 1 到 3 这部分子字符串拷贝到这个新的 string 对象里去。</p><p>这期间涉及了字符串的拷贝，还需要分配额外的内存，有点小浪费。</p><p>如果切下来的子字符串长度是 n，则复杂度为 **O(n)**。</p><h4 id="string-view-高效地切片"><a href="#string-view-高效地切片" class="headerlink" title="string_view 高效地切片"></a>string_view 高效地切片</h4><p>C++17 的设计者们就想：其实我没必要把整个子字符串都拷贝出来，我们只需要保证原来的字符串存在于内存中，让 substr 只是返回切片后的胖指针 [ptr, len]，不就让新字符串和原字符串共享一片内存，实现了零拷贝零分配嘛！</p><p>于是就有了接口和 string 很相似，但是只保留胖指针，而不掌管他所指向内存生命周期的 string_view 类。</p><p>因为不论子字符串多大，真正改变的只有两个变量，所以 string_view 的 substr 函数复杂度为 **O(1)**。</p><h3 id="remove-prefix、remove-suffix"><a href="#remove-prefix、remove-suffix" class="headerlink" title="remove_prefix、remove_suffix"></a>remove_prefix、remove_suffix</h3><p><code>sv.remove_prefix(n) 等价于 sv = sv.substr(n)</code></p><p><code>sv.remove_suffix(n) 等价于 sv = sv.substr(0, n)</code></p><p>没错，他们都是就地修改的。不过这个就地修改的是 string_view 对象本身，而不是修改他指向的字符串，原 string 还是不会变的。</p><p>不同之处在于，<code>substr(pos, len)</code> 遇到 <code>pos &gt; sv.size()</code> 的情况会抛出 out_of_range 异常。而 <code>remove_prefix/suffix</code> 就不会，如果他的 <code>n &gt; sv.size()</code>，则属于未定义行为，可能崩溃。</p><p>总结：remove_prefix&#x2F;suffix 更高效，substr 更安全。</p><p>这和 <code>[]</code> 更高效，<code>at</code> 更安全是一个道理。</p><h3 id="很多-string-的成员函数也支持-string-view"><a href="#很多-string-的成员函数也支持-string-view" class="headerlink" title="很多 string 的成员函数也支持 string_view"></a>很多 string 的成员函数也支持 string_view</h3><p>string 的成员函数 append、replace、find、rfind、find_first_of、+ 和 +&#x3D; 运算符等，其实也支持 string_view 作参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(string_view sv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(string_view sv, <span class="type">size_t</span> pos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>为什么我看官方文档上没写？标准库头文件里也没看到？</p><p>其实是有的，只不过官方为了让 <code>&lt;string&gt;</code> 头文件不依赖于 <code>&lt;string_view&gt;</code> 头文件，把他们写成了模板，并利用类似 SFINAE 的机制给模板参数类型的设了一些限制（相当于把 string_view 定义为一个 concept），所以虽然 <code>&lt;string&gt;</code> 中看不到 string_view 的出现，却能把 string_view 作为参数（ StringViewLike）。</p><h3 id="string-view-和-string-的共同点"><a href="#string-view-和-string-的共同点" class="headerlink" title="string_view 和 string 的共同点"></a>string_view 和 string 的共同点</h3><ul><li><p>at、[]、substr、data、begin、end</p></li><li><p>find、rfind、find_first_of、find_last_of</p></li><li><p>find_first_not_of、find_last_not_of</p></li><li><p>front、back、starts_with、ends_with</p></li><li><p>compare、&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</p></li></ul><p>这些函数和 string 的都是一样的，并且其中 substr 使用string_view更高效（不需要分配一个新 string 对象）。string_view 有的都是这些<strong>只读的</strong>函数；没有的都是 replace、append、insert 这一类<strong>需要修改自身</strong>的函数。</p><h3 id="字符串类型转换规则一览"><a href="#字符串类型转换规则一览" class="headerlink" title="字符串类型转换规则一览"></a>字符串类型转换规则一览</h3><table><thead><tr><th>源类型</th><th>转换方式</th><th>时间复杂度</th><th>目标类型</th></tr></thead><tbody><tr><td><code>const char *</code></td><td>隐式</td><td>O(n)</td><td><code>string_view</code></td></tr><tr><td><code>string</code></td><td>隐式</td><td>O(1)</td><td><code>string_view</code></td></tr><tr><td><code>const char *</code></td><td>隐式</td><td>O(n)</td><td><code>string</code></td></tr><tr><td><code>string_view</code></td><td>显式</td><td>O(n)</td><td><code>string</code></td></tr><tr><td><code>string</code></td><td>c_str</td><td>O(1)</td><td><code>const char *</code></td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>隐式转换</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>显式转换</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>c_str 转换</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cs = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><h2 id="八、标准库-string-源码解析"><a href="#八、标准库-string-源码解析" class="headerlink" title="八、标准库 string 源码解析"></a>八、标准库 string 源码解析</h2><h3 id="string-的本质是-basic-string"><a href="#string-的本质是-basic-string" class="headerlink" title="string 的本质是 basic_string"></a>string 的本质是 basic_string</h3><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030194654958.png" class="" title="image-20241030194654958"><p>在调试的时候经常会看到 string 被 c++filt 解析为 <code>basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;</code>。</p><p>因为 std::string 其实就是他的类型别名（typedef）。</p><p>其中 char_traits 定义了字符串具体各种函数的实现，例如 length 默认为 strlen，如果这里指定其他的 traits，就可以替换其实现，改变 string 内部的工作方式。allocator 也是同理，之后我们会专门讲 allocator 与内存分配。</p><p>后面两个参数是默认的，写 <code>basic_string&lt;char&gt;</code> 就行了。</p><p>同理，string_view 其实也是 <code>basic_string_view&lt;char, char_traits&lt;char&gt;&gt;</code> 的类型别名。</p><p>先看 GCC 标准库内部变量的命名规范，观察可以发现：</p><ul><li><p>_M_xyz 表示成员变量&#x2F;函数。</p></li><li><p>_S_xyz 表示静态成员变量&#x2F;函数。</p></li><li><p>__xyz 表示函数参数。</p></li><li><p>_Tp_xyz 表示模板类型参数。</p></li></ul><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030194853736.png" class="" title="image-20241030194853736"><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030194901856.png" class="" title="image-20241030194901856"><h3 id="string-的空基类优化"><a href="#string-的空基类优化" class="headerlink" title="string 的空基类优化"></a>string 的空基类优化</h3><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030194927247.png" class="" title="image-20241030194927247"><p>首先映入眼帘的是 _Alloc_hider 这个奇怪的类，包装了一下首地址指针 _M_p。为什么要套这一层壳？这其实是为了防止 allocator 对象浪费空间的优化手段。俗称空基类优化，问题来了，为什么需要空基类优化？</p><p>如果不优化的话，是会把 allocator 直接作为成员变量放在 basic_string 里的，但是因为 C++ 规定任何对象都要有大小，即使这个类没有任何成员变量，也要有至少 1 字节的大小（为了防止 allocator 的数组指针傻傻分不清）。</p><ul><li>空基类优化（Empty Base Class Optimization, EBCO）是 C++ 中一种优化技术，用于在继承关系中减少空基类的内存开销。具体来说，当一个类作为基类而不包含任何数据成员（即是空类）时，编译器可以选择不为该空基类分配额外的内存，从而节省空间。</li><li>在 C++ 中，如果一个类（如 <code>Base</code>）是空的，它的大小通常为 1 字节，这是为了确保每个对象都有唯一的地址。但是，若一个类（如 <code>Derived</code>）继承自这个空基类，编译器可能会进行优化，使得 <code>Derived</code> 的大小不受 <code>Base</code> 的影响，从而只占用 <code>Derived</code> 自身的数据成员所需的内存。</li></ul><p>但一般来说 allocator 都是空的，没有成员变量，而由于需要和前后夹杂着的首地址指针 _M_p 对齐的原因，需要占据额外空间，最终会耗费 8 字节的大小！而这 8 字节实际上没有任何数据，只是为了伺候古代 C++ 这个“空类也必须有 1 字节大小”的煞笔设定……</p><p>那么继续往下看，basic_string 里定义了一个 <code>_Alloc_hider</code> 类型的变量 <code>_M_dataplus</code>，刚刚说了他里面实际派用场的是 <code>_M_p</code>，所以下面的 <code>_M_data()</code> 函数直接访问 <code>_M_dataplus._M_p</code> 了。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195018183.png" class="" title="image-20241030195018183"><p>为了弥补这个缺点，C++ 标准委员会提出了<strong>空基类优化</strong>：</p><p>如果一个类（<code>_Alloc_hider</code>）的基类是空类（allocator），则这个基类不占据任何空间，如果这个派生类（<code>_Alloc_hider</code>）如果定义了大小为 n 字节的成员变量（_M_p），则这个派生类（<code>_Alloc_hider</code>）的大小也是 n，<strong>不会</strong>变成 n + 1。</p><p>所以这就是为什么 GCC 标准库把成员变量 _M_p 挪到了一个 _Alloc_hider 里，而让 _Alloc_hider 又继承 allocator。就是为了在 allocator 为<strong>空类</strong>的时候（<strong>无状态分配器</strong>），能让 allocator 不必占据额外的空间。</p><p>问题：既然 allocator 往往都是个空类（<code>std::allocator&lt;T&gt;</code> 默认就是空类，只有几个成员函数负责调用 operator new 和 operator delete），为什么还要把 allocator 对象存到 string 对象里，最后还要搞什么空基类优化防止他浪费空间，多此一举？</p><p>因为最近开始流行“<strong>有状态分配器</strong>”。</p><h3 id="有无空基类优化的对比"><a href="#有无空基类优化的对比" class="headerlink" title="有无空基类优化的对比"></a>有无空基类优化的对比</h3><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195255571.png" class="" title="image-20241030195255571"><ul><li>如图 ，<code>allocator_type</code>是一个空基类，只占据一个字节，如果不进行空基类优化，直接将<code>allocator_type</code>作为成员变量，需要补齐7个字节（一共浪费8个字节）</li><li>源码中的操作，让<code>_Alloc_hider</code>包裹<code>pointer _M_p</code>，并继承<code>allocator_type</code></li><li>此时编译器就可以进行空基类优化，<code>allocator_type</code>，大小变为0，成功隐藏掉这部分空间</li><li>后面的_M_local_buf是一个union联合体，共用了低八位内存，是后面小字符串优化的内容</li></ul><p>空基类优化动手实验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonEmpty</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedEmpty</span> : Empty &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedNonEmpty</span> : NonEmpty &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt; endl;         <span class="comment">// 1 = 1(empty)</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(NonEmpty) &lt;&lt; endl;      <span class="comment">// 1 = 1(char c)</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(DerivedEmpty) &lt;&lt; endl;  <span class="comment">// 4 = 0(empty) + 4(int i)</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(DerivedNonEmpty)</span><br><span class="line">       &lt;&lt; endl;  <span class="comment">// 8 = 1(char c) + 3(padding) + 4(int i)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="string-的小字符串优化"><a href="#string-的小字符串优化" class="headerlink" title="string 的小字符串优化"></a>string 的小字符串优化</h3><p>继续往下看。看到下面有一个 <code>_M_local_buf</code> 的字符数组，和 size_t 的 <code>_M_allocated_capacity</code> 的成员变量。其中 <code>_M_local_buf</code> 大小是 16，常量 <code>_S_local_capacity</code> 为 15 &#x2F; sizeof(char) 也就是 15。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195446501.png" class="" title="image-20241030195446501"><p>这个意思是，当字符串长度<strong>小于 16 字节</strong>时，将存储在 _M_local_buf 里，而不是像 vector 一样把数据存在堆上（通过 new 分配的）。</p><ul><li>请回到观察string的内存示意图，最后的内存共用部分</li><li>当字符串小于15时，使用<code>_M_local_buf</code>这个栈内存，大于十五时就使用<code>_M_allocated_capacity</code>确定分配的容量。</li></ul><p>这称之为小字符串优化，小字符串的上限是 15 字节，而不是 16 字节，为什么？看到这里的 <code>_S_local_capacity + 1</code> 了没，他是为了给 ‘\0’ 留个空位，为的是让 c_str 总能正常得到 0 结尾字符串。所以因为要支持 c_str，string 其实比 vector 多一个负担：需要额外一个字节的空间来存放 ‘\0’。</p><p><strong>string 的 capacity 函数也经过了特殊处理</strong></p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195534094.png" class="" title="image-20241030195534094"><h3 id="string-内存分布示意图"><a href="#string-内存分布示意图" class="headerlink" title="string 内存分布示意图"></a>string 内存分布示意图</h3><ul><li>这里的内存分布只讨论GCC实现</li></ul><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195621430.png" class="" title="image-20241030195621430"><p>C++ 的 string 采用了 [ptr, len, capacity] 构型。其中最后的 capacity 当字符串长度小于 15 时，还和局部小字符串缓存共享了空间。</p><p>_M_local_buf 是物理让字符串比较小的时候能存储在栈上，如果超过 15 字节再去堆上分配空间。这样能节省 new&#x2F;delete 的一点性能开销。</p><p>例如 “helloworld” 这个字符串只有 10 字节，他实际上是存储在栈上的，这时 _M_p 会被设置为指向 _M_local_buf 的首地址。</p><p>不过对于大字符串，这多出来的 8 字节 (unused)是完全浪费掉的，但也不亏，就当是为了对齐到32 字节而故意留的 padding 了。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195659451.png" class="" title="image-20241030195659451"><h3 id="vector-内存分布示意图"><a href="#vector-内存分布示意图" class="headerlink" title="vector 内存分布示意图"></a>vector 内存分布示意图</h3><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195724105.png" class="" title="image-20241030195724105"><p>C++ 的 vector 采用了 [ptr, ptr + len, ptr + capacity] 构型。</p><p>vector 没有采用小字符串优化…这是因为 string 面对的都是 char，wchar_t 这种比较小的类型，且用户常用的字符串往往比较短很容易放进 15 字节的局部栈空间里；</p><p>然而vector 面对的往往是比较大的数据结构，有时还有智能指针，std::thread 这种具有非平凡构造&#x2F;析构函数的类型。对vector 来说保障 RAII 的安全更重要，所以没有冒险优化。</p><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195810758.png" class="" title="image-20241030195810758"><h3 id="string-的-append-实现"><a href="#string-的-append-实现" class="headerlink" title="string 的 append 实现"></a>string 的 append 实现</h3><img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/image-20241030195830146.png" class="" title="image-20241030195830146"><p>append 和 resize 都会去调用 _M_append 这个内部函数。</p><p>他会检测 append 以后是否超过容量，决定是否要扩容数组。</p><p>在 compare 等函数涉及到 0 结尾字符串的版本，都会调用 char_traits 中的方法，方便用户通过模板扩展（性能上或功能上）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basic_string&lt;<span class="type">char</span>, my_simd_char_traits&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代CMake</title>
      <link href="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/"/>
      <url>/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/</url>
      
        <content type="html"><![CDATA[<ul><li><p>现代CMake指的是 CMake 3.x</p></li><li><p>古代CMake指的是 CMake 2.x</p></li><li><p>现代CMake比古代CMake使用更加方便，功能更加强大</p></li></ul><h2 id="命令行小技巧"><a href="#命令行小技巧" class="headerlink" title="命令行小技巧"></a>命令行小技巧</h2><h4 id="传统构建方式对比："><a href="#传统构建方式对比：" class="headerlink" title="传统构建方式对比："></a>传统构建方式对比：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">古代 CMake</span></span><br><span class="line">mkdir -p build# 创建build目录</span><br><span class="line">cd build# 切换到build目录</span><br><span class="line">cmake ..# 在build目录运行cmake &lt;源码目录&gt;生成Makefile</span><br><span class="line">make -j4# 执行本地的构建系统 make 真正开始构建（4进程并行）</span><br><span class="line">make install# 让本地构建系统执行安装步骤</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现代 CMake</span></span><br><span class="line">cmake -B build# 在源码目录直接使用-B选项创建build目录并生成build/Makefile</span><br><span class="line">cmake --build build --parallel 4 或 cmake --build build -j4# 自动调用本地构建系统在build里构建，即：make -C build -j4 </span><br><span class="line">cmake --build build --target install # 调用本地构建系统执行install目标进行安装</span><br></pre></td></tr></table></figure><ul><li>cmake -B build避免了创建目录、切换目录的麻烦</li><li>cmake –build build同意了不同平台（Linux上自动调用make，windows上调用devenv.exe）</li></ul><p>结论：我们应该使用更方便的 -B 和 –build命令</p><h4 id="D选项：指定配置变量（又称缓存变量）"><a href="#D选项：指定配置变量（又称缓存变量）" class="headerlink" title="-D选项：指定配置变量（又称缓存变量）"></a>-D选项：指定配置变量（又称缓存变量）</h4><p>CMake项目的构建分为两步：</p><ol><li>cmake -B build，称为配置阶段(configure)，这时只检测环境并生成构建规则。会在build目录下生成本地构建系统能识别的项目文件(Makefile或.sln)</li><li>cmake –build build，称为构建阶段(build)，这是才实际调用编译器来编译代码</li></ol><p>在配置阶段我们可以通过 -D 参数设置缓存变量。第二次配置是，之前的 -D 添加仍然会被保留。</p><ul><li><p>cmake -B build -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;opt&#x2F;opencvdb-8.0</p></li><li><p>↑设置安装路径为&#x2F;opt&#x2F;opencvdb-8.0</p></li><li><p>cmake -B build _DCMAKE_BUILD_TYPE&#x3D;Release</p></li><li><p>↑设置构建模式为发布模式（开启全部优化）</p></li></ul><p>之后再运行cmake -B build，没有 -D 参数，但是之前的 -D  设置的变量都会被保留</p><p>（此时缓存里仍然存有之前定义的CMAKE_INSTALL_PREFIX和CMAKE_BUILD_TYPE）</p><h4 id="G-选项：指定要使用的生成器"><a href="#G-选项：指定要使用的生成器" class="headerlink" title="-G 选项：指定要使用的生成器"></a>-G 选项：指定要使用的生成器</h4><p>Linux系统上CMake默认使用 Unix Makefiles生成器；Windows系统默认是Visual Studio 2019生成器；MacOS系统默认是Xcode生成器。</p><p>可以使用 -G 选项改用别的生成器，例如cmake -GNinja 会生成使用Ninja这个构建系统的构建规则。</p><ul><li>Ninja是一个高性能、跨平台的构建系统，主流操作系统都可以使用。</li><li>Ninja可以使用包管理器安装，在Windows上也可以使用Python的包管理器(pip install ninja)</li></ul><p>MSbuild、Makefile(Make)、Ninja对比：</p><ul><li>MSbuild主要用于Windows平台，与Visual Studio深度集成，且多核心并行编译不够方便。</li><li>Makefile(Make)主要用于Linux，也可以用于Windows(通过MinGW等工具)，灵活性高，生态成熟、支持多核心构建。但是历史包袱较重，考虑兼容问题导致效率一般</li><li>Ninja是专为性能优化的构建系统，构建速度更快，非常适合CI&#x2F;CD流水线。但是构建文件不容易编写，依赖CMake等构建工具生成，功能较少，专注于速度优化缺乏灵活性。与CMake结合非常适合。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -GNinja -B build</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241017202429099.png" class="" title="image-20241017202429099"><h5 id="对并行编译的补充"><a href="#对并行编译的补充" class="headerlink" title="对并行编译的补充"></a>对并行编译的补充</h5><p><code>cmake --build -j8</code> 在 Linux 下等效于 <code>make -j8</code>, 但在 Windows 上搭配 msbuild generator（例如VS2022）时并没有相同的加速效果， 相关解释：</p><h6 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a><strong>MSBuild</strong></h6><ul><li><strong>项目级并行</strong>：<ul><li><code>cmake --build</code> 的 <code>-j &lt;[jobs]&gt;</code> 映射到了 msbuild 的 <code>-maxcpucount</code>(<code>-m</code>) 参数。</li><li>使用 <code>/m</code> 参数，可以在多个项目（Project）之间实现并行构建。</li><li>适用于解决方案（Solution）包含多个相互独立或无直接依赖关系的项目。</li></ul></li><li><strong>Target 级并行</strong>：<ul><li>默认情况下，MSBuild 不会在同一项目的 Targets 间进行并行构建，因为 Targets 通常存在依赖关系。</li><li>通过设置 <code>BuildInParallel</code> 属性，可以在特定情况下实现 Targets 的并行执行。</li></ul></li><li><strong>文件级并行</strong>：<ul><li>对于同一 Target 内的任务（如编译多个源文件），需要设置环境变量 <code>UseMultiToolTask=true</code>，才能启用多线程编译。</li></ul></li></ul><h6 id="Make"><a href="#Make" class="headerlink" title="Make"></a><strong>Make</strong></h6><ul><li><p>对于Make来说，并没有明确的“Project”概念，Makefile本身就是对项目的顶层定义。</p></li><li><p><strong>Target 级并行</strong>：</p><ul><li>使用 <code>-j</code> 选项（如 <code>make -j4</code>），Make 可以在可能的情况下并行执行多个 Targets。</li><li>依赖于正确的依赖关系定义，确保没有依赖关系的 Targets 可以同时构建。</li></ul></li><li><p><strong>文件级并行</strong>：</p><ul><li>如果编译规则定义得当，Make 可以在同一 Target 内并行编译多个源文件（如 <code>.c</code> 文件生成 <code>.o</code> 文件）。</li></ul></li></ul><h2 id="一、添加源文件"><a href="#一、添加源文件" class="headerlink" title="一、添加源文件"></a>一、添加源文件</h2><p>一个.cpp源文件用于测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMake中添加一个可执行文件作为构建目标</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>另一种方式：先创建目标，稍后再添加源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp)</span><br></pre></td></tr></table></figure><p>多个源文件：逐个添加即可</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp other.cpp)</span><br></pre></td></tr></table></figure><p>使用变量来存储</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">set</span>(sources main.cpp other.cpp) <span class="comment"># 创建一个变量sources</span></span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>) <span class="comment"># 访问变量使用$&#123;变量名&#125;语法</span></span><br></pre></td></tr></table></figure><p>使用GLOB自动查找当前目录下指定扩展名的文件，实现批量添加源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources *.h *.cpp)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure><p>启动CONFIGURE_DEPENDS选项，当添加新文件时，自动更新变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.h *.cpp)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure><p>如果源码放在子文件夹中：</p><p>不必将路径名和文件名全部写出，使用aux_source_directory，自动搜索需要的文件后缀名</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(. sources) <span class="comment"># 搜索当前文件夹</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(mylib sources) <span class="comment"># 搜索mylib文件夹</span></span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure><p>同样的，使用GLOB_RECURSE，可以递归的查找指定后缀的文件。需要注意的是，build文件夹中的一些临时文件也会被加进来，因此需要将源码放在src目录下。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE sources CONFIGURE_DEPENDS src/*.h src/*.cpp)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="二、项目配置变量"><a href="#二、项目配置变量" class="headerlink" title="二、项目配置变量"></a>二、项目配置变量</h2><h4 id="cmake-minimum-required指定最低所需的CMake版本"><a href="#cmake-minimum-required指定最低所需的CMake版本" class="headerlink" title="cmake_minimum_required指定最低所需的CMake版本"></a>cmake_minimum_required指定最低所需的CMake版本</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br></pre></td></tr></table></figure><ul><li><p>可以通过在命令行中运行cmake –version查看当前版本</p></li><li><p>也可以通过 CMAKE_VERSION 这个变量来获得当前 CMake 版本号</p></li></ul><p>假如你写的 CMakeLists.txt 包含了 3.15 版本才有的特性，如果用户在老版本上使用，就会出现各种奇怪的错误。</p><p>因此最好在第一行加个 cmake_minimum_required(VERSION 3.15)表示本 CMakeLists.txt 至少需要 CMake 版本 3.15 以上才能运行。如果用户的 CMake 版本小于 3.15，会出现“CMake 版本不足”的提示</p><h6 id="注意：cmake-mimimum-required不仅是“最小所需版本”"><a href="#注意：cmake-mimimum-required不仅是“最小所需版本”" class="headerlink" title="注意：cmake_mimimum_required不仅是“最小所需版本”"></a>注意：cmake_mimimum_required不仅是“最小所需版本”</h6><p>虽然名字叫 minimum_required，实际上不光是 &gt;&#x3D; 3.15 就不出错这么简单。根据你指定的不同的版本号，还会决定接下来一系列 CMake 指令的行为。</p><p>此外，你还可以通过 3.15…3.20 来表示最高版本不超过 3.20。这会对 cmake_policy 有所影响，稍后再提。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>...<span class="number">3.20</span>)</span><br></pre></td></tr></table></figure><h4 id="CMAKE-BUILD-TYPE-构建的类型，调试模式还是发布模式"><a href="#CMAKE-BUILD-TYPE-构建的类型，调试模式还是发布模式" class="headerlink" title="CMAKE_BUILD_TYPE 构建的类型，调试模式还是发布模式"></a>CMAKE_BUILD_TYPE 构建的类型，调试模式还是发布模式</h4><ul><li>CMAKE_BUILD_TYPE是CMake中一个特殊变量，用于控制构建类型，它的值可以是：</li><li>Debug调试模式，完全不优化，生成调试信息，方便调试程序</li><li>Release发布模式，优化成都最高，性能最佳，但是编译会比Debug慢</li><li>MinSizeRel最小体积发布，生成的文件比Release更小，不完全优化，减少二进制体积</li><li>RelWithDebInfo带调试信息发布，生成的文件比Release更大，因为带有调试的符号信息</li><li>默认情况下 CMAKE_BUILD_TYPR 为空字符串，这是相当于Debug。</li></ul><p>各种构建模式在编译器选项上的区别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Debug: &#x27;-O0 -g&#x27;</span><br><span class="line">Release: &#x27;-O3 -DNDEBUG&#x27;</span><br><span class="line">MinSizeRel: &#x27;-Os -DNDEBUG&#x27;</span><br><span class="line">RelWithDebInfo: &#x27;-O2 -g -DNDEBUG&#x27;</span><br></pre></td></tr></table></figure><ul><li>在Release模式下，追求程序的最佳性能表现，在此情况下，编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后与源代码不一致，此模式下一般会丢失大量调试信息。</li><li>此外，注意定义了NDEBUG宏会使<code>assert</code>被去除掉。<code>assert</code> 是 C 语言和 C++ 中的一个宏，定义在 <code>&lt;cassert&gt;</code> 或 <code>&lt;assert.h&gt;</code> 头文件中，通常用于在调试阶段检查表达式是否为真。它的工作原理是在运行时检查条件是否成立，如果条件为假，则程序会终止并打印错误信息</li></ul><p>小技巧：CMAKE_BUILD_TYPE默认使debug模式，在文件开头添加下面的内容，使默认为release</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="project：初始化项目信息，并把当前CMakeLists-txt所在的位置作为根目录"><a href="#project：初始化项目信息，并把当前CMakeLists-txt所在的位置作为根目录" class="headerlink" title="project：初始化项目信息，并把当前CMakeLists.txt所在的位置作为根目录"></a>project：初始化项目信息，并把当前CMakeLists.txt所在的位置作为根目录</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br></pre></td></tr></table></figure><p>还有一些关于projrct的预定义变量可以使用</p><p><strong>PROJECT_IS_TOP_LEVEL</strong>：BOOL类型，表示当前项目是否是最顶层的根项目</p><p><strong>PROJECT_NAME</strong>：当前项目名</p><p><strong>CMAKE_PROJECT_NAME</strong>：根项目的项目名</p><p><strong>PROJECT_NAME</strong>：当前项目的名称。</p><p><strong>PROJECT_SOURCE_DIR</strong>：项目源代码的根目录路径。</p><p><strong>PROJECT_BINARY_DIR</strong>：项目构建文件的输出目录路径。</p><p><strong>CMAKE_SOURCE_DIR</strong>：表示整个项目的根源代码目录，始终指向最上层CMakeLists.txt文件所在的目录。</p><p><strong>CMAKE_CURRENT_SOURCE_DIR</strong>：当前CMakeLists.txt文件所在的源目录。</p><p><strong>CMAKE_CURRENT_BINARY_DIR</strong>：当前CMakeLists.txt文件对应的构建目录。</p><ul><li>PROJECT_SOURCE_DIR 表示最近一次设置 project 的 CMakeLists.txt 所在的源码目录。</li><li>CMAKE_CURRENT_SOURCE_DIR 表示当前处理的CMakeLists.txt文件所在的源目录。</li><li>CMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。</li><li>利用 PROJECT_SOURCE_DIR 可以实现从子模块里直接获得项目最外层目录的路径。</li><li>不建议用 CMAKE_SOURCE_DIR，那样会让你的项目无法被人作为子模块使用。</li></ul><h5 id="子模块里也可以使用project命令，将当前目录作为一个独立的子项目"><a href="#子模块里也可以使用project命令，将当前目录作为一个独立的子项目" class="headerlink" title="子模块里也可以使用project命令，将当前目录作为一个独立的子项目"></a>子模块里也可以使用project命令，将当前目录作为一个独立的子项目</h5><p>这样一来 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。</p><p>这时候 CMake 会认为这个子模块是个独立的项目，会额外做一些初始化。</p><p>他的构建目录 PROJECT_BINARY_DIR 也会变成 build&#x2F;&lt;源码相对路径&gt;。</p><p>这样在 MSVC 上也会看见 build&#x2F;mylib&#x2F;mylib.vcxproj 的生成。</p><h5 id="project的初始化：LANGUAGES字段"><a href="#project的初始化：LANGUAGES字段" class="headerlink" title="project的初始化：LANGUAGES字段"></a>project的初始化：LANGUAGES字段</h5><p>•project(项目名 LANGUAGES 使用的语言列表…) 指定了该项目使用了哪些编程语言。</p><p>目前支持的语言包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C：C语言</span><br><span class="line">CXX：C++语言</span><br><span class="line">ASM：汇编语言</span><br><span class="line">Fortran：老年人的编程语言</span><br><span class="line">CUDA：英伟达的 CUDA（3.8 版本新增）</span><br><span class="line">OBJC：苹果的 Objective-C（3.16 版本新增）</span><br><span class="line">OBJCXX：苹果的 Objective-C++（3.16 版本新增）</span><br><span class="line">ISPC：一种因特尔的自动 SIMD 编程语言（3.18 版本新增）</span><br></pre></td></tr></table></figure><p>如果不指定 LANGUAGES，默认为 C 和 CXX。</p><ul><li>也可以线设置LANGUAGES NONE，之后再调用enable_languages(CXX)来启用</li><li>这样可以把enable_languages放到if语句中，达到只有某些选项开启才启用某语言的功能</li></ul><h5 id="project的初始化：VERSION字段"><a href="#project的初始化：VERSION字段" class="headerlink" title="project的初始化：VERSION字段"></a>project的初始化：VERSION字段</h5><p>project(项目名 VERSION x.y.z) 可以把当前项目的版本号设定为 x.y.z。之后可以通过 PROJECT_VERSION 来获取当前项目的版本号。</p><p>PROJECT_VERSION_MAJOR 获取 x（主版本号）。</p><p>PROJECT_VERSION_MINOR 获取 y（次版本号）。</p><p>PROJECT_VERSION_PATCH 获取 z（补丁版本号）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>...<span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_VERSION: $&#123;CMAKE_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_VERSION: $&#123;PROJECT_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_VERSION_MAJOR: $&#123;PROJECT_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_VERSION_MINOR: $&#123;PROJECT_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_VERSION_PATCH: $&#123;PROJECT_VERSION_PATCH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><h5 id="项目名的一大作用：设置-SOURCE-DIR等变量"><a href="#项目名的一大作用：设置-SOURCE-DIR等变量" class="headerlink" title="项目名的一大作用：设置&lt;项目名&gt;_SOURCE_DIR等变量"></a>项目名的一大作用：设置&lt;项目名&gt;_SOURCE_DIR等变量</h5><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241018132807600.png" class="" title="image-20241018132807600"><h6 id="小技巧：CMake的-表达式可以嵌套"><a href="#小技巧：CMake的-表达式可以嵌套" class="headerlink" title="小技巧：CMake的${} 表达式可以嵌套"></a>小技巧：CMake的<code>$&#123;&#125; </code>表达式可以嵌套</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hellocmake_VERSION: $&#123;$&#123;PROJECT_NAME&#125;_VERSION&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>因为<code>$&#123;PROJECT_NAME&#125;</code>求值结果使hellocmake，所以<code>$&#123;$&#123;PROJECT_NAME&#125;_VERSION&#125;</code>相当于<code>$&#123;hellocmake_VERSION&#125;</code></p><h4 id="设置-c-标准：CMAKE-CXX-STANDARD"><a href="#设置-c-标准：CMAKE-CXX-STANDARD" class="headerlink" title="设置 c++标准：CMAKE_CXX_STANDARD"></a>设置 c++标准：CMAKE_CXX_STANDARD</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br></pre></td></tr></table></figure><h4 id="CMAKE-CXX-STANDARD"><a href="#CMAKE-CXX-STANDARD" class="headerlink" title="CMAKE_CXX_STANDARD"></a>CMAKE_CXX_STANDARD</h4><p>是一个整数，表示要用的 C++ 标准。比如需要 C++17 那就设为 17，需要 C++23 就设为 23。</p><h4 id="CMAKE-CXX-STANDARD-REQUIRED"><a href="#CMAKE-CXX-STANDARD-REQUIRED" class="headerlink" title="CMAKE_CXX_STANDARD_REQUIRED"></a>CMAKE_CXX_STANDARD_REQUIRED</h4><p>是 BOOL 类型，可以为 ON 或 OFF，默认 OFF。他表示是否一定要支持你指定的 C++ 标准：如果为 OFF 则 CMake 检测到编译器不支持 C++17 时不报错，而是默默调低到 C++14 给你用；为 ON 则发现不支持报错，更安全。</p><h4 id="CMAKE-CXX-EXTENSIONS"><a href="#CMAKE-CXX-EXTENSIONS" class="headerlink" title="CMAKE_CXX_EXTENSIONS"></a>CMAKE_CXX_EXTENSIONS</h4><p>也是 BOOL 类型，默认为 ON。设为 ON 表示启用 GCC 特有的一些扩展功能；OFF 则关闭 GCC 的扩展功能，只使用标准的 C++。</p><ul><li>要兼容其他编译器（如 MSVC）的项目，都会设为 OFF 防止不小心用了 GCC 才有的特性。</li></ul><p>此外，最好是在 project 指令前设置 CMAKE_CXX_STANDARD 这一系列变量，这样 CMake 可以在 project 函数里对编译器进行一些检测，看看他能不能支持 C++17 的特性</p><h6 id="常见误区：手动添加-std-c-17"><a href="#常见误区：手动添加-std-c-17" class="headerlink" title="常见误区：手动添加 -std&#x3D;c++17"></a>常见误区：手动添加 -std&#x3D;c++17</h6><ul><li><p>请勿直接修改 CMAKE_CXX_FLAGS 来添加 -std&#x3D;c++17（你在百度 CSDN 学到的用法）。</p></li><li><p>使用 CMake 帮你封装好的 CMAKE_CXX_STANDARD（从业人员告诉你的正确用法）。</p></li></ul><p>为什么百度不对：你 GCC 用户手动指定了 -std&#x3D;c++17，让 MSVC 的用户怎么办？</p><p>此外 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加 -std&#x3D;c++11 选项了，你再添加个 -std&#x3D;c++17 选项不就冲突了吗？所以请用 CMAKE_CXX_STANDARD</p><h4 id="其他的一些变量："><a href="#其他的一些变量：" class="headerlink" title="其他的一些变量："></a>其他的一些变量：</h4><ul><li>CMAKE_BUILD_TOOL: 执行构建过程的工具。该变量设置为CMake构建时输出所需的程序。对于VS 6， CMAKE_BUILD_TOOL设置为msdev， 对于Unix，它被设置为make 或 gmake。 对于 VS 7， 它被设置为devenv. 对于Nmake构建文件，它的值为nmake。</li><li>CMAKE_DL_LIBS: 包含dlopen和dlclose的库的名称。</li><li>CMAKE_COMMAND: 指向cmake可执行程序的全路径。</li><li>CMAKE_CTEST_COMMAND: 指向ctest可执行程序的全路径。</li><li>CMAKE_EDIT_COMMAND: cmake-gui或ccmake的全路径。</li><li>CMAKE_EXECUTABLE_SUFFIX: 该平台上可执行程序的后缀。</li><li>CMAKE_SIZEOF_VOID_P: void指针的大小。</li><li>CMAKE_SKIP_RPATH: 如果为真，将不添加运行时路径信息。默认情况下是如果平台支持运行时信息，将会添加运行时信息到可执行程序当中。这样从构建树中运行程序将很容易。为了在安装过程中忽略掉RPATH，使用CMAKE_SKIP_INSTALL_RPATH。</li><li>CMAKE_GENERATOR: 构建工程的产生器。它将产生构建文件 (e.g. “Unix Makefiles”, “Visual Studio 2019”, etc.)</li></ul><h4 id="一个标准的CMakeLists-txt模板"><a href="#一个标准的CMakeLists-txt模板" class="headerlink" title="一个标准的CMakeLists.txt模板"></a>一个标准的CMakeLists.txt模板</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定CMake的最低版本要求为3.15</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++标准为C++17，并强制使用该标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称为 ming，并指定支持的语言为C、C++和CUDA</span></span><br><span class="line"><span class="keyword">project</span>(ming LANGUAGES C CXX CUDA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查编译目录是否与源代码目录相同，若相同则发出警告</span></span><br><span class="line"><span class="keyword">if</span> (PROJECT_BINARY_DIR <span class="keyword">STREQUAL</span> PROJECT_SOURCE_DIR)</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;The binary directory of CMake cannot be the same as source directory!&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未指定构建类型，默认设置为Release</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是Windows系统，添加一些编译选项定义</span></span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="comment"># -DNOMINMAX：避免Windows头文件定义min和max宏</span></span><br><span class="line">    <span class="comment"># -D_USE_MATH_DEFINES：启用数学常量（如M_PI）在Windows环境中</span></span><br><span class="line">    <span class="keyword">add_definitions</span>(-DNOMINMAX -D_USE_MATH_DEFINES)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不是使用Microsoft编译器（MSVC），则寻找CMake缓存编译器（ccache）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> MSVC)</span><br><span class="line">    <span class="comment"># 查找系统中的ccache程序</span></span><br><span class="line">    <span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果找到ccache，启用ccache来加速编译和链接</span></span><br><span class="line">    <span class="keyword">if</span> (CCACHE_PROGRAM)</span><br><span class="line">        <span class="comment"># 打印找到的ccache路径</span></span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;</span>)</span><br><span class="line">        <span class="comment"># 设置全局属性，使CMake在编译时使用ccache</span></span><br><span class="line">        <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">        <span class="comment"># 设置全局属性，使CMake在链接时使用ccache</span></span><br><span class="line">        <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、链接库文件"><a href="#三、链接库文件" class="headerlink" title="三、链接库文件"></a>三、链接库文件</h2><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>main.cpp调用mylib.cpp里的say_hello函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, mylib!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp mylib.cpp)</span><br></pre></td></tr></table></figure><h4 id="引用改进："><a href="#引用改进：" class="headerlink" title="引用改进："></a>引用改进：</h4><p>关于动静态库的内容这里不做介绍</p><h5 id="mylib作为一个静态库STATIC"><a href="#mylib作为一个静态库STATIC" class="headerlink" title="mylib作为一个静态库STATIC"></a>mylib作为一个静态库STATIC</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib STATIC mylib.cpp)<span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)<span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)<span class="comment"># 为main链接静态库</span></span><br></pre></td></tr></table></figure><h5 id="mylib作为一个动态库SHARED"><a href="#mylib作为一个动态库SHARED" class="headerlink" title="mylib作为一个动态库SHARED"></a>mylib作为一个动态库SHARED</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)<span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)<span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)<span class="comment"># 为main链接动态库</span></span><br></pre></td></tr></table></figure><h5 id="mylib作为一个对象库-OBJECT"><a href="#mylib作为一个对象库-OBJECT" class="headerlink" title="mylib作为一个对象库 OBJECT"></a>mylib作为一个对象库 OBJECT</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib OBJECT mylib.cpp)<span class="comment"># 生成对象库</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)<span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)<span class="comment"># 为main链接对象库</span></span><br></pre></td></tr></table></figure><p>对象库类似于静态库，但不生成 .a 文件，只由 CMake 记住该库生成了哪些对象文件</p><p>对象库是 CMake 自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。</p><p>推荐全部用对象库(OBJECT)替代静态库(STATIC)避免跨平台的麻烦。</p><p>对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难</p><h4 id="其他补充："><a href="#其他补充：" class="headerlink" title="其他补充："></a>其他补充：</h4><h5 id="静态库的麻烦："><a href="#静态库的麻烦：" class="headerlink" title="静态库的麻烦："></a>静态库的麻烦：</h5><p>GCC编译器自作聪明，会自动提出没有引用符号的那些对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstido&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> unused = <span class="built_in">printf</span>(<span class="string">&quot;mylib initialized\n&quot;</span>);<span class="comment">//c++静态初始化语法，正常会在main之前运行</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main function\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(mylib STATIC mylib.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预期结果：</span></span><br><span class="line">mylib initialized</span><br><span class="line">main function</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际结果：</span></span><br><span class="line">main function</span><br></pre></td></tr></table></figure><p>编译时gcc发现没有人引用这个mylib.cpp编译出的mylib.o文件，就会将这个.o文件删掉。</p><p>对象库可以绕开编译器的不统一：保证不会自动剔除没引用到的对象文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstido&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> unused = <span class="built_in">printf</span>(<span class="string">&quot;mylib initialized\n&quot;</span>);<span class="comment">//c++静态初始化语法，正常会在main之前运行</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main function\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(mylib STATIC mylib.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预期结果：</span></span><br><span class="line">mylib initialized</span><br><span class="line">main function</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际结果：</span></span><br><span class="line">mylib initialized</span><br><span class="line">main function</span><br></pre></td></tr></table></figure><p>当然，动态库也能避免剔除没引用的对象文件，但会引入运行时链接的麻烦，特别是在windows平台。</p><h5 id="add-library参数"><a href="#add-library参数" class="headerlink" title="add_library参数"></a>add_library参数</h5><p>当add_library无参数时，会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。</p><p>ON 则相当于 SHARED，OFF 则相当于 STATIC。</p><p>如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。</p><p>因此，如果发现一个项目里的 add_library 都是无参数的，意味着你可以用：cmake -B build -DBUILD_SHARED_LIBS:BOOL&#x3D;ON来让他全部生成为动态库。稍后会详解命令行传递变量的规则。</p><h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>要让 BUILD_SHARED_LIBS 默认为 ON，可以用这个方法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> BUILD_SHARED_LIBS)</span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBRED_LIBS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>如果该变量没有定义，则设为 ON，否则保持用户指定的值不变。</p><p>这样当用户没有指定 BUILD_SHARED_LIBS 这个变量时，会默认变成 ON。也就是说除非用户指定了 -DBUILD_SHARED_LIBS:BOOL&#x3D;OFF 才会生成静态库，否则默认是生成动态库。</p><h5 id="常见坑点：动态库无法链接静态库"><a href="#常见坑点：动态库无法链接静态库" class="headerlink" title="常见坑点：动态库无法链接静态库"></a>常见坑点：动态库无法链接静态库</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure><p>因为静态库认为应该链接到一个可执行文件，现在链接到一个动态库中。</p><p>但是动态库在内存中的位置是会变化的，静态库静态库中可能包含非位置无关代码，编译器就会报错，</p><ul><li>动态库在程序运行时可以被加载到内存的不同地址，而不是在编译时就固定到某个地址。</li></ul><p><strong>位置无关代码 PIC</strong></p><p>为了使动态库能够在任意内存地址加载，编译时生成的位置无关代码（PIC）允许程序在运行时根据加载位置进行必要的地址重定位。这确保了无论动态库被加载到哪个地址，程序都能正确访问库中的函数和变量。</p><ul><li><strong>实现方式</strong>：编译器生成的代码中，所有的绝对地址都被替换为相对地址，函数调用和全局变量访问通常通过间接寻址来实现。</li></ul><p>解决：让静态库编译时也生成位置无关的代码(PIC)，这样才能装在动态库里。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_POSITION_INDEPENEDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure><p>将CMAKE_POSITION_INDEPENEDENT_CODE属性设置为ON，会强制所有代码都生成位置无关的代码PIC。</p><p>也可以只针对一个库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> otherlib CMAKE_POSITION_INDEPENEDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure><p>这里就只针对otherlib设置启动PIC</p><h2 id="四、对象的属性"><a href="#四、对象的属性" class="headerlink" title="四、对象的属性"></a>四、对象的属性</h2><p> 刚才提到的CMAKE_POSITION_INDEPENEDENT_CODE就是一个otherlib对象的一个属性</p><h4 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h4><h5 id="使用set-property设置"><a href="#使用set-property设置" class="headerlink" title="使用set_property设置"></a>使用set_property设置</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="number">17</span>)           <span class="comment"># 采用 C++17 标准进行编译（默认 11）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)  <span class="comment"># 如果编译器不支持 C++17，则直接报错（默认 OFF）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class="keyword">ON</span>)       <span class="comment"># 在 Windows 系统中，运行时不启动控制台窗口，只有 GUI 界面（默认 OFF）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class="keyword">ON</span>)      <span class="comment"># 告诉编译器不要自动剔除没有引用符号的链接库（默认 OFF会剔除）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="comment"># 设置动态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="comment"># 设置静态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)   <span class="comment"># 设置可执行文件的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br></pre></td></tr></table></figure><h5 id="另一种方式：set-target-properties批量设置多个属性"><a href="#另一种方式：set-target-properties批量设置多个属性" class="headerlink" title="另一种方式：set_target_properties批量设置多个属性"></a>另一种方式：set_target_properties批量设置多个属性</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(main PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">17</span>           <span class="comment"># 采用 C++17 标准进行编译（默认 11）</span></span><br><span class="line">    CXX_STANDARD_REQUIRED <span class="keyword">ON</span>  <span class="comment"># 如果编译器不支持 C++17，则直接报错（默认 OFF）</span></span><br><span class="line">    WIN32_EXECUTABLE <span class="keyword">ON</span>       <span class="comment"># 在 Windows 系统中，运行时不启动控制台窗口，只有 GUI 界面（默认 OFF）</span></span><br><span class="line">    LINK_WHAT_YOU_USE <span class="keyword">ON</span>      <span class="comment"># 告诉编译器不要自动剔除没有引用符号的链接库（默认 OFF）</span></span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib   <span class="comment"># 设置动态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib   <span class="comment"># 设置静态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin   <span class="comment"># 设置可执行文件的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h5 id="另一种方式：通过全局变量，设置之后的所有对象"><a href="#另一种方式：通过全局变量，设置之后的所有对象" class="headerlink" title="另一种方式：通过全局变量，设置之后的所有对象"></a>另一种方式：通过全局变量，设置之后的所有对象</h5><p>相当于改变了各个属性的默认值，要注意此时 **set(CMAKE_XXX) **必须在add_executable之前才有效</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)           <span class="comment"># 采用 C++17 标准进行编译（默认 11）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)  <span class="comment"># 如果编译器不支持 C++17，则直接报错（默认 OFF）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_WIN32_EXECUTABLE <span class="keyword">ON</span>)       <span class="comment"># 在 Windows 系统中，运行时不启动控制台窗口，只有 GUI 界面（默认 OFF）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class="keyword">ON</span>)      <span class="comment"># 告诉编译器不要自动剔除没有引用符号的链接库（默认 OFF）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="comment"># 设置动态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="comment"># 设置静态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)   <span class="comment"># 设置可执行文件的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="number">17</span>)        <span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(main PUBLIC <span class="string">&quot;-std=c++17&quot;</span>)          <span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CUDA_ARCHITECTURES <span class="number">75</span>)  <span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(main PUBLIC <span class="string">&quot;-arch=sm_75&quot;</span>)         <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><p>对于 CXX_STANDARD 这种 CMake 本就提供了变量来设置的东西，就不要自己去设置 -std&#x3D;c++17 选项，会和 CMake 自己设置好的冲突，导致出错。</p><p>请始终用 CXX_STANDARD 或是全局变量 CMAKE_CXX_STANDARD 来设置 -std&#x3D;c++17 这个 flag，CMake 会在配置阶段检测编译器是否支持 C++17。</p><p>CUDA 的 -arch&#x3D;sm_75 也是同理，请使用 CUDA_ARCHITECTURES 属性。</p><p>再说了 -std&#x3D;c++17 只是 GCC 编译器的选项，无法跨平台用于 MSVC 编译器。</p><h4 id="windows动态链接"><a href="#windows动态链接" class="headerlink" title="windows动态链接"></a>windows动态链接</h4><p>如果要使用动态链接，需要在代码中进行一些定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllimport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，还会有经典错误：</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019184342262.png" class="" title="image-20241019184342262"><p>这是因为你的 dll 和 exe 不在同一目录。Windows 比较蠢，他只会找当前 exe 所在目录，然后查找 PATH，找不到就报错。而你的 dll 在其他目录，因此 Windows 会找不到 dll。</p><ul><li>解决1：把 dll 所在位置加到你的 PATH 环境变量里去，一劳永逸。</li><li>解决2：把这个 dll，以及这个 dll 所依赖的其他 dll，全部拷贝到和 exe 文件同一目录下。</li></ul><p><strong>实现解决1：xx_OUTPUT_DIRECTORY系列属性</strong></p><p>CMake中设置xx_OUTPUT_DIRECTORY系列属性，让我们的dll文件输出到PROJECT_BINARY_DIR（可执行程序所在的目录）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp mylib.h)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><p>为了满足Windows，这样的操作非常繁琐。为什么说Linux系统YYDS？</p><ul><li>Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH 字段指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH 里找链接库，所以即使不在同目录也能找到。</li><li>需要手动修改或查看一个 ELF 文件的 RPATH，可以用 chrpath 或 patchelf 命令</li></ul><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019185330589.png" class="" title="image-20241019185330589"><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>属性通常可以在目标级别（<code>TARGET</code>）设置，也可以在全局级别（<code>GLOBAL</code>）设置。目标级别的属性只影响特定的目标，而全局级别的属性影响整个项目。</p><h2 id="五、链接第三方库"><a href="#五、链接第三方库" class="headerlink" title="五、链接第三方库"></a>五、链接第三方库</h2><h6 id="案例：需要使用tbb库"><a href="#案例：需要使用tbb库" class="headerlink" title="案例：需要使用tbb库"></a>案例：需要使用tbb库</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC tbb)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">4</span>, [&amp;] (<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, %d!\n&quot;</span>, i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="直接链接的缺点"><a href="#直接链接的缺点" class="headerlink" title="直接链接的缺点"></a>直接链接的缺点</h6><p>如果这样直接指定 tbb，CMake 会让链接器在系统的库目录里查找 tbb，他会找到 &#x2F;usr&#x2F;lib&#x2F;libtbb.so 这个系统自带的，但这对于没有一个<strong>固定库安装位置</strong>的 Windows 系统并不适用。</p><p>此外，他还要求 tbb 的头文件就在 &#x2F;usr&#x2F;include 这个系统默认的头文件目录，这样才能 #include &lt;tbb&#x2F;parallel_for.h&gt; 不出错，如果 tbb 的头文件在其他地方就需要再加一个 <strong>target_include_directories</strong> 设置额外的头文件查找目录。</p><h6 id="硬核解决：直接写出全部路径"><a href="#硬核解决：直接写出全部路径" class="headerlink" title="硬核解决：直接写出全部路径"></a>硬核解决：直接写出全部路径</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC C:/Users/archibate/installed/tbb/tbb.dll)</span><br></pre></td></tr></table></figure><p>这样也可以让没有默认系统路径的 Windows 找到安装在奇怪位置的 tbb……不过这样根本不跨平台，你这样改了别人如果装在不同地方就出错了。</p><p>顺便一提，CMake 的路径分割符始终是 &#x2F;。即使在 Windows 上，也要把所有的 \ 改成 &#x2F;，这是出于跨平台的考虑。请放心，CMake 会自动在调用 MSVC 的时候转换成 \，你可以放心的用 ${x}&#x2F;bin 来实现和 Python 的 os.path.join(x, ‘bin’) 一样的效果。</p><p><strong>高情商：Windows是最适合练习C语言转义符使用水平的平台。</strong></p><h3 id="find-package：更通用的做法"><a href="#find-package：更通用的做法" class="headerlink" title="find_package：更通用的做法"></a>find_package：更通用的做法</h3><p>使用CMake的find_package命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)<span class="comment"># 查找库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<span class="comment"># 链接</span></span><br></pre></td></tr></table></figure><p>find_package(TBB REQUIRED)会查找&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;TBB&#x2F;TBBConfig.cmake(由TBB安装)这个配置文件，并根据里面的配置信息创建TBB::tbb这个伪对象（它实际指向真正的tbb库文件路径&#x2F;usr&#x2F;lib&#x2F;libtbb.so），之后通过target_link_libraries链接TBB::tbb就可以正常工作了</p><h4 id="CONFIG参数选项"><a href="#CONFIG参数选项" class="headerlink" title="CONFIG参数选项"></a>CONFIG参数选项</h4><p>find_package(TBB CONFIG REQUIRED) </p><p>添加了一个 <strong>CONFIG</strong> 选项。这样他会优先查找 TBBConfig.cmake（系统自带的）而不是 FindTBB.cmake（项目作者常把他塞在 cmake&#x2F; 目录里并添加到 CMAKE_MODULE_PATH）。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb 版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本</p><ul><li><p>没有 CONFIG 选项：先找 FindTBB.cmake，再找 TBBConfig.cmake，找不到则报错</p></li><li><p>有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错</p></li></ul><p>此外，一些老年项目（例如 OpenVDB）只提供 Find 而没有 Config 文件，这时候就必须用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG 选项</p><h4 id="usr-lib-cmake-TBB-TBBConfig-cmake长啥样？"><a href="#usr-lib-cmake-TBB-TBBConfig-cmake长啥样？" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;TBB&#x2F;TBBConfig.cmake长啥样？"></a>&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;TBB&#x2F;TBBConfig.cmake长啥样？</h4><p>不论是 TBBConfig.cmake 还是 FindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb 后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写FindXXX.cmake 才能使用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create imported target TBB::tbb</span></span><br><span class="line"><span class="keyword">add_library</span>(TBB::tbb SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(TBB::tbb PROPERTIES</span><br><span class="line">  INTERFACE_COMPILE_DEFINITIONS <span class="string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span></span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create imported target TBB::tbbmalloc</span></span><br><span class="line"><span class="keyword">add_library</span>(TBB::tbbmalloc SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(TBB::tbbmalloc PROPERTIES</span><br><span class="line">  INTERFACE_COMPILE_DEFINITIONS <span class="string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span></span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create imported target TBB::tbbmalloc_proxy</span></span><br><span class="line"><span class="keyword">add_library</span>(TBB::tbbmalloc_proxy SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(TBB::tbbmalloc_proxy PROPERTIES</span><br><span class="line">  INTERFACE_COMPILE_DEFINITIONS <span class="string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span></span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES <span class="string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="PUBIC属性"><a href="#PUBIC属性" class="headerlink" title="PUBIC属性"></a>PUBIC属性</h4><p>关于TBB::tbb：自带了一些PUBIC属性</p><p>TBB::tbb 是一个伪对象(imported)，除了他会指向 &#x2F;usr&#x2F;lib&#x2F;libtbb.so 之外，TBBConfig.cmake 还会给 TBB::tbb 添加一些 PUBLIC 属性，用于让链接他了的对象带上一些 flag 之类。</p><p>比如，TBB 安装在 &#x2F;opt&#x2F;tbb 目录下，头文件在 &#x2F;opt&#x2F;tbb&#x2F;include 里，那么这时 TBBConfig.cmake 里就会有：</p><p>target_include_directories(TBB::tbb PUBLIC &#x2F;opt&#x2F;tbb&#x2F;include)</p><p>这样 main 在链接了 TBB::tbb 的时候也会被“传染”上 &#x2F;opt&#x2F;tbb&#x2F;include 这个目录，不用调用者手动添加了。</p><p>再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那这个库也会自动链接到 main 上，无需调用者手动添加。</p><h6 id="PUBLIC属性传播机制的便利"><a href="#PUBLIC属性传播机制的便利" class="headerlink" title="PUBLIC属性传播机制的便利"></a>PUBLIC属性传播机制的便利</h6><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019195538109.png" class="" title="image-20241019195538109"><h3 id="常见问题：Qt5查找出错"><a href="#常见问题：Qt5查找出错" class="headerlink" title="常见问题：Qt5查找出错"></a>常见问题：Qt5查找出错</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)</span><br></pre></td></tr></table></figure><p>报错：</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019201639942.png" class="" title="image-20241019201639942"><p>与 TBB 不同，<strong>Qt5 是一个包含多个模块的框架</strong>，如 <code>Qt5Core</code>, <code>Qt5Widgets</code>, <code>Qt5Gui</code> 等。每个模块相当于一个独立的库，CMake 需要知道你具体想使用哪个模块。这就是为什么在使用 <code>Qt5</code> 时，必须明确指定要查找的组件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Widgets REQUIRED)  <span class="comment"># 查找指定组件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC Qt5::Core Qt5::Widgets)  <span class="comment"># 链接所需的 Qt5 组件</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>TBB</strong> 是单一库，使用 <code>find_package(TBB REQUIRED)</code> 即可找到并链接，不需要指定组件。</p></li><li><p><strong>Qt5</strong> 是模块化框架，必须明确指出需要哪些模块，否则 CMake 会提示错误，要求至少指定一个组件。</p></li></ul><h4 id="REQUIRED参数"><a href="#REQUIRED参数" class="headerlink" title="REQUIRED参数"></a>REQUIRED参数</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB)</span><br><span class="line"><span class="keyword">if</span> (TBB_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;TBB found at: $&#123;TBB_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;TBB not found! using serial for&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p><strong>不指定</strong> <strong>REQUIRED****，找不到时不报错，只会设置</strong> <strong>TBB_FOUND</strong> <strong>为</strong> **FALSE</p><p>这样可以用于添加一些可选的依赖，如果没有也不要紧的那种，这时我们可以抛出一个警告。</p><p>找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 设为 TBBConfig.cmake 所在路径。</p><p>找不到会把 TBB_FOUND 设为 FALSE，TBB_DIR 为空。</p><p>这里我们在找到 TBB 时定义 WITH_TBB 宏，稍后 .cpp 里就可以根据这个判断。</p><p>如果找不到 TBB 可以 fallback 到保守的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_TBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_TBB</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">4</span>, [&amp;] (<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, %d!\n&quot;</span>, i);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_TBB</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在.cpp 里可以判断WITH_TBB宏，找不到TBB时退化到串行for循环</strong></p><p>也可以使用TARGET判断是否存在<strong>TBB::tbb</strong>这个伪对象，实现同样的效果</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(TBB)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">TARGET</span> TBB::tbb)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;TBB found at: $&#123;TBB_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;TBB not found! using serial for&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h2 id="六、输出与变量"><a href="#六、输出与变量" class="headerlink" title="六、输出与变量"></a>六、输出与变量</h2><h3 id="message指令"><a href="#message指令" class="headerlink" title="message指令"></a>message指令</h3><h4 id="message-“打印的字符串”"><a href="#message-“打印的字符串”" class="headerlink" title="message(“打印的字符串”)"></a>message(“打印的字符串”)</h4><p>在运行cmake –B build时，打印字符串</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019210233803.png" class="" title="image-20241019210233803"><h4 id="message-STATUS-“打印的字符串”"><a href="#message-STATUS-“打印的字符串”" class="headerlink" title="message(STATUS “打印的字符串”)"></a>message(STATUS “打印的字符串”)</h4><p>表示信息类型是状态信息，有 –前缀</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Hello，world!&quot;</span>)</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019210500717.png" class="" title="image-20241019210500717"><h4 id="message-WARNING-“警告信息”"><a href="#message-WARNING-“警告信息”" class="headerlink" title="message(WARNING “警告信息”)"></a>message(WARNING “警告信息”)</h4><p>表示警告信息，会以黄色字体显示，并且会出现几个换行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning sign!&quot;</span>)</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019210750746.png" class="" title="image-20241019210750746"><h4 id="message-AUTHOR-WARNING-“作者警告信息”"><a href="#message-AUTHOR-WARNING-“作者警告信息”" class="headerlink" title="message(AUTHOR_WARNING “作者警告信息”)"></a>message(AUTHOR_WARNING “作者警告信息”)</h4><p>表示仅仅是给项目作者看的警告信息，可以通过-Wno-dev关闭</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This warning is for project developers.&quot;</span>)</span><br><span class="line"><span class="comment"># cmake -B build -Wno-dev</span></span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019210931857.png" class="" title="image-20241019210931857"><h4 id="message-FATAL-ERROR-“错误信息”"><a href="#message-FATAL-ERROR-“错误信息”" class="headerlink" title="message(FATAL_ERROR “错误信息”)"></a>message(FATAL_ERROR “错误信息”)</h4><p>表示的是错误信息，会终止CMake的运行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is an error message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;After error...&quot;</span>)<span class="comment"># 不执行</span></span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019211352849.png" class="" title="image-20241019211352849"><h4 id="message-SEND-ERROR-“错误信息”"><a href="#message-SEND-ERROR-“错误信息”" class="headerlink" title="message(SEND_ERROR “错误信息”)"></a>message(SEND_ERROR “错误信息”)</h4><p>表示的是错误信息，但之后的语句仍继续执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;This is an error message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;After error...&quot;</span>)<span class="comment"># 继续执行</span></span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019211642132.png" class="" title="image-20241019211642132"><h4 id="message打印变量"><a href="#message打印变量" class="headerlink" title="message打印变量"></a>message打印变量</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：</span></span><br><span class="line">myvar is: hello world</span><br></pre></td></tr></table></figure><ul><li><p>如果set没有加引号，会编程分号分割列表，即<code>set(myvar hello world)</code>等价于<code>set(myvar &quot;hello;world&quot;)</code></p><p>输出：<code>myvar is: hello;world</code></p></li><li><p>如果message没加引号，会把列表里的字符串当成它的关键字</p></li></ul><p>结论：除非确实需要列表，建议始终在不确定的地方加上引号</p><h2 id="七、变量与缓存"><a href="#七、变量与缓存" class="headerlink" title="七、变量与缓存"></a>七、变量与缓存</h2><p>重复执行cmake -B build会有什么区别？</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019215306301.png" class="" title="image-20241019215306301"><p>可以看到第二次的输出少了很多，这是因为 CMake 第一遍需要检测编译器和 C++ 特性等，比较耗时。检测完会把结果存储到<strong>缓存</strong>中，这样第二遍运行cmake -B build 时就可以直接用缓存的值，就不需要再检测一遍了。</p><h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>然而有时候外部的情况有所更新，这时候 CMake 里缓存的却是旧的值，会导致一系列问题。</p><p>这时我们需要清除缓存，最简单的办法就是删除 build 文件夹，然后重新运行 cmake -B build。缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以试试看删 build 全部重新构建。</p><p>经典 CMake 笑话：“99%的cmake错误可以用删build解决”“删 build 大法好”</p><h4 id="build-CMakeCache-txt"><a href="#build-CMakeCache-txt" class="headerlink" title="build&#x2F;CMakeCache.txt"></a>build&#x2F;CMakeCache.txt</h4><p>清除缓存，只需要删除build&#x2F;CMakeCache.txt就可以。</p><p>删 build 虽然彻底，也会导致编译的中间结果（.o文件）都没了，重新编译要花费很长时间。</p><p>如果只想清除缓存，不想从头重新编译，可以只删除 build&#x2F;CMakeCache.txt 这个文件。</p><p>这文件里面装的就是缓存的变量，删了他就可以让 CMake 强制重新检测一遍所有库和编译器。</p><h3 id="变量缓存"><a href="#变量缓存" class="headerlink" title="变量缓存"></a>变量缓存</h3><h4 id="find-package缓存机制"><a href="#find-package缓存机制" class="headerlink" title="find_package缓存机制"></a>find_package缓存机制</h4><p>变量缓存的意义在于能够把 find_package 找到的库文件位置等信息，储存起来。</p><p>这样下次执行 find_package 时，就会利用上次缓存的变量，直接返回。</p><p>避免重复执行 cmake -B 时速度变慢的问题</p><h4 id="设置缓存变量"><a href="#设置缓存变量" class="headerlink" title="设置缓存变量"></a>设置缓存变量</h4><p>语法：set(变量名 “变量值” CACHE 变量类型 “注释”)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;hello&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;this is the docstring.&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019220353531.png" class="" title="image-20241019220353531"><p>查看CMakeCache.txt文件，能够发现缓存的myvar</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019220444879.png" class="" title="image-20241019220444879"><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>修改了CMakeLists.txt里set的值，却没有更新</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;world&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;this is the docstring.&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了更新缓存变量，有的同学偷懒直接修改 CMakeLists.txt 里的值，这是没用的。</p><p>因为 set(… CACHE …) 在缓存变量已经存在时，不会更新缓存的值！</p><p>CMakeLists.txt 里 set 的被认为是“默认值”因此不会在第二次 set 的时候更新。</p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019220739493.png" class="" title="image-20241019220739493"><h5 id="标准解法：通过命令行-D-参数"><a href="#标准解法：通过命令行-D-参数" class="headerlink" title="标准解法：通过命令行 -D 参数"></a>标准解法：通过命令行 -D 参数</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -Dmyvar=world</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241019222107994.png" class="" title="image-20241019222107994"><h5 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h5><p>通过指定FORCE来强制set更新缓存</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;world&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;this is the docstring.&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>set 可以在后面加一个 FORCE 选项，表示不论缓存是否存在，都强制更新缓存。不过这样会导致没办法用 -Dmyvar&#x3D;othervalue 来更新缓存变量</p><p>图形化的缓存编辑器</p><ul><li>在 Linux 中，可以运行 ccmake -B build 来启动基于终端的可视化缓存编辑菜单。</li><li>在 Windows 则可以 cmake-gui -B build 来启动图形界面编辑各个缓存选项。</li><li>当然，直接用编辑器打开 build&#x2F;CMakeCache.txt 修改后保存也是可以的。</li><li>CMakeCache.txt 用文本存储数据，就是可供用户手动编辑，或是被第三方软件打开并解析的。</li></ul><h3 id="其他类型的缓存变量"><a href="#其他类型的缓存变量" class="headerlink" title="其他类型的缓存变量"></a>其他类型的缓存变量</h3><ul><li><p>STRING 字符串，例如 “hello, world”</p></li><li><p>FILEPATH 文件路径，例如 “C:&#x2F;vcpkg&#x2F;scripts&#x2F;buildsystems&#x2F;vcpkg.cmake”</p></li><li><p>PATH 目录路径，例如 “C:&#x2F;Qt&#x2F;Qt5.14.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;”</p></li><li><p>BOOL 布尔值，只有两个取值：ON 或 OFF。</p></li><li><p>注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF 等价</p></li></ul><h5 id="案例：添加一个BOOL类型的缓存变量，用于控制某些特性"><a href="#案例：添加一个BOOL类型的缓存变量，用于控制某些特性" class="headerlink" title="案例：添加一个BOOL类型的缓存变量，用于控制某些特性"></a>案例：添加一个BOOL类型的缓存变量，用于控制某些特性</h5><p>例如添加WITH_TBB变量，用于控制是否启用TBB</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(WITH_TBB <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (WITH_TBB)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)<span class="comment"># 添加预定义选项</span></span><br><span class="line">    <span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>可以在命令行进行控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DWITH_TBB:BOOL=OFF</span><br></pre></td></tr></table></figure><p>可以在源码中检查这个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_TBB</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TBB enabled!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指令简写：option"><a href="#指令简写：option" class="headerlink" title="指令简写：option"></a>指令简写：option</h4><p>CMake对BOOL类型的缓存的set指令提供了一个简写：option</p><p>option(变量名 “描述” 变量值)</p><p>等价于：</p><p>set(变量名 CACHE BOOL 变量值 “描述”)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(WITH_TBB <span class="string">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span> (WITH_TBB)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)</span><br><span class="line">    <span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p><strong>同样的，直接在CMakeLists.txt中的option值也不会更新变量</strong></p><p>官方解法：-D参数</p><p>-D变量名:BOOL&#x3D;ON&#x2F;OFF</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build _DWITH_TBB:BOOL=OFF</span><br></pre></td></tr></table></figure><h4 id="补充：target-compile-definitions"><a href="#补充：target-compile-definitions" class="headerlink" title="补充：target_compile_definitions"></a>补充：target_compile_definitions</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC MY_MACRO=<span class="number">233</span>)<span class="comment">#相当于在main中定义了一个MY_MACRO宏，值是233</span></span><br></pre></td></tr></table></figure><h2 id="八、跨平台与编译器"><a href="#八、跨平台与编译器" class="headerlink" title="八、跨平台与编译器"></a>八、跨平台与编译器</h2><p>上面提到了我们可以通过CMake添加一个宏，CMake可以通过一些变量判断不同的平台，结合就可以实现根据平台选择对应的编译器。</p><h4 id="CMAKE-SYSTEM-NAME判断系统平台"><a href="#CMAKE-SYSTEM-NAME判断系统平台" class="headerlink" title="CMAKE_SYSTEM_NAME判断系统平台"></a>CMAKE_SYSTEM_NAME判断系统平台</h4><p>根据不同操作系统，把宏定义成不同的值</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MY_NAME</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s!\n&quot;</span>, MY_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I don&#x27;t know your name!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简写变量"><a href="#简写变量" class="headerlink" title="简写变量"></a>简写变量</h4><p>CMake还提供了一些简写变量：WIN32、APPLE、UNIX、ANDROID、IOS等</p><ul><li><p>虽然名字叫 WIN32，实际上对 32 位 Windows 和 64 位 Windows 都适用</p></li><li><p>APPLE 对于所有苹果产品（MacOS 或 iOS）都为真</p></li><li><p>UNIX 对于所有 Unix 类系统（FreeBSD, Linux, Android, MacOS, iOS）都为真</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (UNIX <span class="keyword">AND</span> <span class="keyword">NOT</span> APPLE)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>使用生成器表达式，简化上面的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">语法：$&lt;$&lt;类型:值&gt;:为真时的表达式&gt;</span><br><span class="line">比如 $&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=”Bill Gates”&gt;</span><br><span class="line">在 Windows 平台上会变为 MY_NAME=”Bill Gates”</span><br><span class="line">其他平台上则表现为空字符串</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Linux&gt;:MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Darwin&gt;:MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>如果需要多个平台可以使用逗号分割</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class="string">&quot;DOS-like&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Linux,Darwin,FreeBSD&gt;:MY_NAME=<span class="string">&quot;Unix-like&quot;</span>&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="CMAKE-CXX-COMPILER-ID判断c-编译器"><a href="#CMAKE-CXX-COMPILER-ID判断c-编译器" class="headerlink" title="CMAKE_CXX_COMPILER_ID判断c++编译器"></a>CMAKE_CXX_COMPILER_ID判断c++编译器</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;gcc&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;NVIDIA&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;nvcc&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;msvc&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>也可以使用生成器表达式</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC</span><br><span class="line">    $&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:MY_NAME=<span class="string">&quot;Open-source&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;CXX_COMPILER_ID:MSVC,NVIDIA&gt;:MY_NAME=<span class="string">&quot;Commercial&quot;</span>&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>简写变量：MSVC、CMAKE_COMPILER_IS_GNUCC</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_COMPILER_IS_GNUCC)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;GCC&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Other compiler&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p><strong>从命令行指定编译器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_CXX_COMPILER=&quot;/usr/bin/clang++&quot;</span><br></pre></td></tr></table></figure><p><strong>通过环境变量指定编译器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXX=&#x27;which clang&#x27; cmake -B build</span><br></pre></td></tr></table></figure><h2 id="九、分支与判断"><a href="#九、分支与判断" class="headerlink" title="九、分支与判断"></a>九、分支与判断</h2><p><strong>BOOL类型的值</strong></p><ul><li><p>通常来说 BOOL 类型的变量只有 ON&#x2F;OFF 两种取值。</p></li><li><p>但是由于历史原因，TRUE&#x2F;FALSE 和 YES&#x2F;NO 也可以表示 BOOL 类型。</p></li></ul><h3 id="if的特点：不需要加"><a href="#if的特点：不需要加" class="headerlink" title="if的特点：不需要加 ${}"></a>if的特点：不需要加 ${}</h3><p>不需要加${}，会自动尝试作为变量名求值</p><p>由于历史原因，if 的括号中有着特殊的语法，如果是一个字符串，比如 MYVAR，则他会先看是否有 ${MYVAR} 这个变量。如果有这个变量则会被替换为变量的值来进行接下来的比较，否则保持原来字符串不变。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR Hello)</span><br><span class="line"><span class="keyword">if</span> (MYVAR <span class="keyword">MATCHES</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is Hello&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is not Hello&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：MYVAR is Hello</span></span><br></pre></td></tr></table></figure><h4 id="如果加了-会怎样"><a href="#如果加了-会怎样" class="headerlink" title="如果加了 ${ } 会怎样"></a>如果加了 ${ } 会怎样</h4><p>if (${MYVAR} MATCHES “Hello”) 会被翻译成 if (Hello MATCHES “Hello”)</p><p>但是因为找不到名为 Hello 的变量，所以会被直接当成普通的字符串来处理。</p><p>也就是 if (“Hello” MATCHES “Hello”) 从而会执行真分支，结果正常</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR Hello)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$&#123;MYVAR&#125;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is Hello&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is not Hello&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：MYVAR is Hello</span></span><br></pre></td></tr></table></figure><p><strong>万一碰巧定义了Hello变量</strong></p><p>假如存在 Hello 这个变量，其值为 “world”</p><p>那么 if (${MYVAR} MATCHES “Hello”) 会被翻译成 if (Hello MATCHES “Hello”)</p><p>而因为 Hello 这个变量名存在，所以会被（出于历史原因的）if 进一步求值：if (“world” MATCHES “Hello”) 从而会执行假分支，结果不正常了。</p><p><strong>解决：</strong>用引号包起来，防止被当作变量名</p><ul><li>如果搞不明白，可以把所有不确定的地方都套上一层引号，例如”${MYVAR}”，这样就可以避免被 if 当做变量名来求值了。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR Hello)</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;$&#123;MYVAR&#125;&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is Hello&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is not Hello&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：MYVAR is Hello</span></span><br></pre></td></tr></table></figure><h2 id="十、变量与作用域"><a href="#十、变量与作用域" class="headerlink" title="十、变量与作用域"></a>十、变量与作用域</h2><h3 id="变量的传播规则：父传子，子不传父"><a href="#变量的传播规则：父传子，子不传父" class="headerlink" title="变量的传播规则：父传子，子不传父"></a>变量的传播规则：父传子，子不传父</h3><ul><li>夫模块里定义的变量，会传递给子模块</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子模块</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：MYVAR：ON</p><ul><li>子模块里定义的变量，<strong>不会</strong>传递给父模块</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子模块</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：MYVAR：空</p><p>在子模块中打印MYVAR变量会发现没有内容</p><ul><li>如果父模块本来就定义了同名变量，则<strong>离开子模块</strong>后仍保持夫模块原来设置的值</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子模块</span></span><br><span class="line"><span class="keyword">set</span>(MUVAR <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>输出：MYVAR：OFF</p><p><strong>如果子模块需要向夫模块传递变量怎么办</strong></p><ul><li>使用set的PARENT_SCOPE选项，把一个变量传递到上一层作用域（也就是父模块）</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子模块</span></span><br><span class="line"><span class="keyword">set</span>(MUVAR <span class="keyword">ON</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure><p>输出：MYVAR：ON</p><ul><li>如果父模块里没有定义 MYVAR 的话，也可以用缓存变量向外部传变量（不推荐）。但是这样就不光父模块可见了，父模块的父模块，到处都可见。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子模块</span></span><br><span class="line"><span class="keyword">set</span>(MUVAR <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br></pre></td></tr></table></figure><p>输出：MYVAR：ON</p><h3 id="其他独立作用域"><a href="#其他独立作用域" class="headerlink" title="其他独立作用域"></a>其他独立作用域</h3><ul><li>include 的 XXX.cmake <strong>没有</strong>独立作用域</li><li>macro <strong>没有</strong>独立作用域</li><li>add_subdirectory 的 CMakeLists.txt <strong>有</strong>独立作用域</li><li>function <strong>有</strong>独立作用域</li><li>（因此 PARENT_SCORE 也可以用于 function 的返回值）</li></ul><h3 id="环境变量的访问方式：-ENV-xx"><a href="#环境变量的访问方式：-ENV-xx" class="headerlink" title="环境变量的访问方式：$ENV{xx}"></a>环境变量的访问方式：<code>$ENV&#123;xx&#125;</code></h3><p>用 ${xx} 访问的是局部变量，局部变量服从刚刚所说的父子模块传播规则。</p><p>而还有一种特殊的方式可以访问到系统的环境变量（environment variable）：$ENV{xx}。</p><p>比如 $ENV{PATH} 就是获取 PATH 这个环境变量的值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PATH is $ENV&#123;PATH&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：打印PATH环境变量</p><h3 id="缓存变量访问方式：-CACHE-xx"><a href="#缓存变量访问方式：-CACHE-xx" class="headerlink" title="缓存变量访问方式：$CACHE{xx}"></a>缓存变量访问方式：<code>$CACHE&#123;xx&#125;</code></h3><ul><li>缓存变量和环境变量是不论父子模块都共用的，没有作用域一说</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_BUILD_TYPE is $CACHE&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_BUILD_TYPE is: RELEASE</span><br></pre></td></tr></table></figure><h3 id="xx-找不到局部变量时，自动去找缓存变量"><a href="#xx-找不到局部变量时，自动去找缓存变量" class="headerlink" title="${xx}找不到局部变量时，自动去找缓存变量"></a><code>$&#123;xx&#125;</code>找不到局部变量时，自动去找缓存变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_BUILD_TYPR is $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_BUILD_TYPE is: Release</span><br></pre></td></tr></table></figure><p>${xx} 当找不到名为 xx 的局部变量时，就会去在缓存里查找名为 xx 的缓存变量。</p><p>因此这里 CMAKE_BUILD_TYPE 虽然在代码里没被 set，但是他被-D参数固定在缓存里了。</p><p>所以 <code>$&#123;CMAKE_BUILD_TYPE&#125;</code> 自动变成 <code>$CACHE&#123;CMAKE_BUILD_TYPE&#125;</code> 从而找到变量</p><h3 id="if-DEFIEND-xx-判断某变量是否存在"><a href="#if-DEFIEND-xx-判断某变量是否存在" class="headerlink" title="if (DEFIEND xx)判断某变量是否存在"></a><code>if (DEFIEND xx)</code>判断某变量是否存在</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> MYVAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is: $&#123;MYVAR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR not defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYVAR not defined</span><br></pre></td></tr></table></figure><p><code>if (DEFINED MYVAR) </code>可以判断是否存在 <code>MYVAR</code> 这个局部变量或缓存变量</p><ul><li>值得注意的是：<strong>空字符串不代表变量不存在</strong>。因此即使是空字符串 DEFINED 也认为存在</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> MYVAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is: $&#123;MYVAR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR not defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>输出：<code>MYVAR is: </code></p><p><strong>可以直接用<code>if(xx)</code>判断某变量是否存在且不为空字符串</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYVAR <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (MYVAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is: $&#123;MYVAR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is empty or not defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>输出：MYVAR is empty or not defined</p><p>直接用 if (xx) 来判断是否为空字符串，因为空字符串等价于 FALSE</p><h3 id="if-DEFINED-ENV-xx-判断某环境变量是否存在"><a href="#if-DEFINED-ENV-xx-判断某环境变量是否存在" class="headerlink" title="if (DEFINED ENV{xx})判断某环境变量是否存在"></a><code>if (DEFINED ENV&#123;xx&#125;)</code>判断某环境变量是否存在</h3><p> $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx} 来表示环境变量。</p><ul><li><p>因为 set 的第一参数和 if 的参数都是不加<code> $</code> 的，所以要设置<code> $&#123;x&#125;</code>就变成了 <code>set(x ...)</code>。而设置 <code>$ENV&#123;x&#125;</code> 自然就是 <code>set(ENV&#123;x&#125; ...)</code> 。</p></li><li><p>同理还可以用 <code>if (DEFINED CACHE&#123;x&#125;)</code> 判断是否存在这个缓存变量，但是<code> set(CACHE&#123;x&#125; ...)</code> 就不行。</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;MYVAR&#125; <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> EBV&#123;MYVAR&#125;)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR is: $ENV&#123;MYVAR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR is not defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>输出：<code>MYVAR is: hello</code></p><p><strong>从bash设置环境变量试试：</strong></p><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241021131505431.png" class="" title="image-20241021131505431"><h2 id="十一、其他小建议"><a href="#十一、其他小建议" class="headerlink" title="十一、其他小建议"></a>十一、其他小建议</h2><h3 id="CCache：编译加速缓存"><a href="#CCache：编译加速缓存" class="headerlink" title="CCache：编译加速缓存"></a>CCache：编译加速缓存</h3><p>一般用法：把<code>gcc -c main.cpp -omain</code>换成<code>ccache gcc -c main.cpp -o main</code>即可</p><p>在CMake中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CCAHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCAHE_PROGRAM)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Found CCache: $&#123;CCAHE_PROGRAM&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(GLOBAL ProPERTY RULE_LANCH_COMPILE <span class="variable">$&#123;CCAHE_PROGRAM&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>即在每个编译和链接命令前加上ccache</p><p>（似乎不支持MSVC）</p><h3 id="添加run伪目标，用于启动主程序"><a href="#添加run伪目标，用于启动主程序" class="headerlink" title="添加run伪目标，用于启动主程序"></a>添加run伪目标，用于启动主程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(run <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:main&gt;)</span><br></pre></td></tr></table></figure><img src="/2024/10/17/C++/CMake/%E7%8E%B0%E4%BB%A3Cmake/image-20241020231456590-17294877691271.png" class="" title="image-20241020231456590"><ul><li><p>创建一个 run 伪目标，其执行 main 的可执行文件。</p></li><li><p>这里用了生成器表达式 <code>$&lt;TARGET_FILE:main&gt;</code>，会自动让 run 依赖于 main。</p></li><li><p>如果不放心有没有自动依赖上，手动加一个 add_dependencies(run main) 也是可以的。</p></li><li><p>这样就可以在命令行运行 <code>cmake --build build --target run</code> 来启动 main.exe 运行了。</p></li><li><p>而不必根据不同的平台，手动写出 build&#x2F;main 或是 build\main.exe。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的简历模板</title>
      <link href="/2024/10/10/%E9%9D%A2%E8%AF%95/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/10/%E9%9D%A2%E8%AF%95/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>效果如下：</p><img src="/2024/10/10/%E9%9D%A2%E8%AF%95/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241010211225.jpg" class="" title="我的简历">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试寄录</title>
      <link href="/2024/10/10/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%AF%84%E5%BD%95/"/>
      <url>/2024/10/10/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%AF%84%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="01–库感智能"><a href="#01–库感智能" class="headerlink" title="01–库感智能"></a>01–库感智能</h2><p>初创公司，BOSS上直接和感知算法总监打招呼，约了第二天下午面试。</p><p>原本准备了几个问题，但是都没用到，一开始问的就比较深，说是想拷打我一下。</p><p>面试官直接要求讲自己的项目，第一个讲完开始拷打：</p><ol><li>重新讨论了一下单目摄像头定位、测距是怎样实现的，比赛项目比较脱离实际，重新描述了一次。已知了障碍物大小，标定了相机内参</li><li>问了一些计算机视觉方面的问题，都回答的不好。<ol><li>相机内参矩阵每个参数代表什么</li><li>相机外参，回答描述的是相机的位姿信息，引出了后面的坐标系转换</li><li>真实世界的一个点，怎样变换到图像画面中的（当时没有理解在问什么，回忆应该是想问这个问题。。）</li></ol></li><li>坐标系转换，一个点，左乘变换矩阵和右乘有什么区别。又是盲区，没回答上来。面试官解释：左乘变换矩阵表示对<strong>固定坐标系</strong>的变换，右乘变换矩阵表示对<strong>变化坐标的操作</strong>，不是很理解。</li><li>关于docker，detached和tached启动的区别，没有回答上来，解释说detached模式下启动的容器重启后会保持运行状态</li><li>问怎样实现导航的，又重新解释了一遍：已知背景地图，先确定了障碍物位置，实时定位又靠障碍物和里程计的参考。</li></ol><p>接着讲第二个机器狗项目，还是主要问传感器</p><ol><li>处理雷达数据时用的哪些包</li><li>解释了激光雷达的工作原理</li><li>了解SLAM吗，回答只会调包，知道哪些包，回答了gmapping和cartographer，问知道三维的SLAM包不，回答没用过</li><li>TensorRT是怎样优化的，回答内部自动实现的，具体细节不清楚。回答到内部会对一些网络层进行融合后面试官很满意。当时没想起来还有精度降低</li></ol><p>上面的问题问完后，面试官表示看完简历觉得我有点东西，就问了一些比较深的内容。（很好的表示，下次不允许了）</p><p>接下来问的简单问题，基本秒了：</p><ol><li>Git切换分支怎样操作，回答checkout（差点记错）</li><li>怎样提交代码到服务器，准备过的问题：add到暂存区、commit提交更改、push推送到服务器</li><li>简单的C++概念，static修饰符的效果、Vector和List</li><li>ROS2中spin和spin_once的区别，印象不深了，磕磕绊绊回答上来了。其实就是spin_once只回调一次，就执行之后的代码，spin会卡住一直回调。</li></ol><p>我反问：</p><ol><li><p>公司的经营模式，这个赛道怎么样</p><p>三大业务板块：园区清扫车(完成)、光伏清扫机器人(预交付)、移动充电站(战未来)</p><p>目前11个人，本硕博都有，目标是进军光伏领域（有相关行业的背景）</p></li><li><p>假如来实习，主要职责是什么</p><p>进他的组，做导航定位相关。不限制接触其他内容（意思啥都得干bushi）</p></li><li><p>对我的评价</p><p>作为大三学生，从简历、面试表现来说超出这个阶段很多，很务实</p><p>最后表示自身努力重要，选择的环境、道路更重要（是不是暗示我得考个研）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九届智能车地平线组完赛方案——02.系统启动和连接</title>
      <link href="/2024/09/30/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/02.%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
      <url>/2024/09/30/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/02.%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 智能车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能车 </tag>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九届智能车地平线组完赛方案——01.系统选择和烧录</title>
      <link href="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/"/>
      <url>/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>硬件：RDK X3开发板、SD卡</p><p>软件：操作系统镜像、balenaEtcher烧录软件</p><p>本章相关链接：</p><ul><li><a href="https://github.com/balena-io/etcher/releases">balenaEtcher软件下载</a></li><li><a href="https://archive.d-robotics.cc/downloads/os_images/rdk_x3/">rdk_x3操作系统镜像</a></li><li><a href="https://developer.d-robotics.cc/">地瓜开发者社区</a></li><li><a href="https://pan.baidu.com/s/1FH9txTJil7aMCIUOzhkVcg?pwd=gyh1#list/path=%2F">比赛时官方提供的资料及基础镜像网盘链接</a></li></ul><h3 id="操作系统镜像下载"><a href="#操作系统镜像下载" class="headerlink" title="操作系统镜像下载"></a>操作系统镜像下载</h3><p>官方封装了一些操作系统镜像，内置了许多工具和环境，目前共有三个大版本，1.0已经不推荐使用了，2.0基于Ubuntu-20.04，3.0基于Ubuntu-22.04。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928203049066.png" class="" title="image-20240928203049066"><p>我们这里使用的是上面的2.1.1版本。比赛时主办方在百度网盘提供了一个镜像，但是这个镜像在当时备赛过程中已经发现存在一些问题，主要是TogetherROS已经与GitHub文档无法对应，以及一些小的BUG，目前最新的镜像不存在这些问题。</p><p>(区域赛前一周意识到了上面的问题，由于只有一人开发，担心进度问题，就继续使用百度网盘中的镜像，所以如果想直接用我的源码，就得使用存在问题的镜像，已经提供在了开头的链接中)</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928204909300.png" class="" title="image-20240928204909300"><p>镜像分为desktop和server两个版本，开发板性能有限，我们使用sever版本。</p><h3 id="烧录系统"><a href="#烧录系统" class="headerlink" title="烧录系统"></a>烧录系统</h3><p>个人推荐使用balenaEtcher，UI更加现代化，还能提醒大容量设备，防止破坏其他硬盘（曾深受其害），类似的软件还有win32 disk imager，这里并没有强制要求。注意这类软件一般都需要以管理员身份运行，否则无法烧录。</p><p>打开软件，选择从文件烧录，选定下载好的img镜像文件</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240928211401192.png" class="" title="image-20240928211401192"><p>点击选择目标磁盘，选定要烧录的sd卡，注意要选择单独的磁盘设备，不是分区，一旦开始烧录会格式化选定的整个磁盘设备。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240930142736534.png" class="" title="image-20240930142736534"><p>确定好之后开始烧录，烧录速度取决SD卡性能。</p><img src="/2024/09/28/%E5%8D%81%E4%B9%9D%E5%B1%8A%E6%99%BA%E8%83%BD%E8%BD%A6-%E6%99%BA%E6%85%A7%E5%8C%BB%E7%96%97/01.%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%92%8C%E7%83%A7%E5%BD%95/image-20240930142843437.png" class="" title="image-20240930142843437"><p>镜像烧录完成就可以插入开发板卡槽，上电等待，如果绿灯闪烁说明系统已经成功启动。</p><p>如果出现烧录失败，例如报错镜像可能被更改之类，需要以管理员身份运行烧录软件。</p>]]></content>
      
      
      <categories>
          
          <category> 智能车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能车 </tag>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell与Terminal</title>
      <link href="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/"/>
      <url>/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shell（壳）、Terminal（终端），许多刚开始接触计算机的朋友可能跟以前的我一样并不清楚这两个概念，因为它们总是同时出现。配置开发环境或者学习Linux的过程中我们难免接触，所以我觉得有必要跟大家讨论一下它们的关系。</p><h2 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h2><p>shell翻译过来是“壳”，十分形象，shell就是包裹在操作系统内核上的一层外壳。shell接收用户输入的命令，并将其转换为操作系统可以理解的指令，然后执行这些指令。这里我们借助shell提供的cat指令来理解一下shell的作用。</p><p>熟悉Linux的朋友会知道，cat命令可以输出一个文件的内容到终端。这里我提前准备了一个hello.cpp文件，打开一个终端，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.cpp</span><br></pre></td></tr></table></figure><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206213159507.png" class="" title="image-20231206213159507"><p>shell会解析我们命令行里的内容并执行，可以看到，文件里的内容成功输出到了我们的终端里。接下来我们思考一下，假如没有这个命令，我们想要达到同样的目的需要怎样的步骤，由于本人对windows内核并不熟悉，这里我会在Linux环境下进行演示，原理是相通的，不会影响我们理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, <span class="string">&quot;Usage: program_name &lt;filename&gt;\n&quot;</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回非零表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="type">char</span> *filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fileDescriptor = <span class="built_in">open</span>(filename, O_RDONLY);</span><br><span class="line">    <span class="comment">// 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, <span class="string">&quot;Error opening file\n&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 返回非零表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取并打印文件内容</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = <span class="built_in">read</span>(fileDescriptor, buffer, <span class="built_in">sizeof</span>(buffer))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buffer, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fileDescriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回零表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个my_cat程序，程序使用 <code>open</code> 打开文件，然后使用 <code>read</code> 从文件中读取内容，并使用 <code>write</code> 将内容写入标准输出。最后，使用 <code>close</code> 关闭文件描述符。这几个函数就是linux内核提供的接口。</p><p>编译并运行程序，可以看到成功输出文件内容<img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206220309890.png" class="" title="image-20231206220309890"></p><p>到这你是否对这层“壳”有了一点点感觉，再借助下面这张图，估计就能理解shell扮演的角色。</p><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206222404523.png" class="" title="image-20231206222404523"><p>用户可以通过shell和各种程序操作系统内核，shell和程序之间也可以相互操作，通过这种架构我们可以十分灵活的完成对计算机的控制</p><h2 id="shell命令解释器"><a href="#shell命令解释器" class="headerlink" title="shell命令解释器"></a>shell命令解释器</h2><p>上面提到的shell是概念级的东西，在它之下有各种解释器的实现，例如Linux中常用的bash、zsh，windows的cmd、powershell，甚至一些软件例如Git、VistualStudio都会提供一些shell工具。</p><p>在linux中我们可以查看当前系统中都有那些shell解释器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206223115522.png" class="" title="image-20231206223115522"><p>可以看到我的ubuntu系统中有这些解释器，正在使用的是zsh，我的终端就是使用的oh-my-zsh进行的美化。</p><p>在windows环境，以前我们使用的是cmd（命令提示符），它只在windows下使用，并且很多命令都是微软自己的规范，有一定的学习成本。后来win10以后，powershell越来越完善，我们也强推使用这个。powershell是可以跨平台的。</p><h2 id="Terminal（终端）是什么"><a href="#Terminal（终端）是什么" class="headerlink" title="Terminal（终端）是什么"></a>Terminal（终端）是什么</h2><p>现在的终端和计算机刚发展时的终端概念发生了一些变化，现在我们看到的各种终端软件其实应该叫模拟终端，关于这个概念有兴趣的朋友可以查阅相关资料。</p><p>用我自己的理解来说，终端就是可以输入命令并显示程序运行信息的窗口软件。终端本身不会解释命令，它会把用户输入的命令交给shell解释器执行。由于这两者总是同时出现，所以才让我们容易混淆。</p><p>这些终端软件又会提供一些额外的功能，例如Terminator好用的拆分窗口、Windows Terminal提供的统一管理、美化等功能。</p><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206230246074.png" class="" title="image-20231206230246074"><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/shell%E4%B8%8ETerminal/image-20231206230439597.png" class="" title="image-20231206230439597"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上：</p><ul><li>shell是操作系统内核的外层封装，方便用户对系统进行操作。</li><li>Terminal是提供窗口界面，将用户的命令交给shell解释器执行</li></ul><p>另外，shell本身还是一种脚本语言，我们可以直接将命令在命令行执行，也可以按照shell语法将这些命令写入文件中，shell解释器可以读取这个文件并执行。本人并不擅长shell编程，就不在这里献丑，有兴趣的朋友可以查看相关资料学习。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器与IDE</title>
      <link href="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/"/>
      <url>/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>写这篇文章的想法源于某次课堂，老师多次将VC++6.0、CodeBlocks这些上古神器称为编译器，虽然知道它们区别的同学知道这只是老师的个人习惯，但我觉得课堂上还是应该严谨，特别是对刚接触计算机学科的同学们来说。</p><p>直接说结论：</p><ul><li>编辑器：用来编辑文本文件的工具。比如windows下的记事本、Notepad++，Linux下的Vi、Vim、gedit，当然还有Vscode这种跨平台的软件。</li><li>编译器：按一定的规则将文本格式的源代码翻译成可执行程序的工具。例如编译c\c++的GCC、G++、MSVC、Clang等</li><li>IDE（集成开发环境）：将上面的编译器、编辑器集成到一个软件中，再拓展更多便于开发人员使用的工具。</li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>注意这里我们只讨论c\c++这类编译型语言。</p><p>我们都知道一段程序从源码到可执行程序需要经过预处理、编译、汇编、链接这几步操作，下面是我在windows环境下使用MinGW-w64编译器（不懂的朋友先不用管它是什么，马上会解释）分步执行了这个过程：</p><ol><li><p><strong>编辑（Editing）：</strong> 你首先使用文本编辑器（如Notepad++、Visual Studio Code、或者专门的集成开发环境（IDE）如Visual Studio等）编写C++源代码文件（通常以<code>.cpp</code>为扩展名）。在这个阶段，你可以编写类、函数、变量等。</p></li><li><p><strong>预处理（Preprocessing）：</strong> 在这个阶段，预处理器会对源代码进行处理。预处理器的任务包括处理<code>#include</code>指令，替换宏定义，以及处理条件编译等。预处理器生成一个新的临时源文件，通常以<code>.i</code>或<code>.ii</code>为扩展名。打开终端，进入源文件所在目录，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></li><li><p><strong>编译（Compiling）：</strong> 在这个阶段，编译器将预处理后的源代码翻译成汇编代码。汇编代码是一种低级的表示，它使用符号和指令来描述程序的操作。生成的文件通常以<code>.s</code>为扩展名。继续执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></li><li><p><strong>汇编（Assembling）：</strong> 汇编器将汇编代码翻译成机器码或者可重定位的目标代码。生成的文件通常以<code>.o</code>、<code>.obj</code>或者其他特定于平台的扩展名为后缀。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></li><li><p><strong>链接（Linking）：</strong> 在这个阶段，链接器将目标代码与其他已经编译的目标代码或者库文件链接在一起，生成最终的可执行文件。链接器的任务包括解析符号引用、地址重定向等。生成的文件通常是一个可执行文件，可以在计算机上运行。可执行文件的扩展名可能是<code>.exe</code>（Windows）或者无扩展名（Linux）。执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello.exe</span><br></pre></td></tr></table></figure></li></ol><p>上面的过程中每一步都会生成相应的文件，其中几个文本类型文件有兴趣的朋友可以打开查看一下。</p><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231205235904204.png" class="" title="image-20231205235904204"><p>大家可以看到，我们通过gcc工具，在命令行中就实现了一个程序从源码到可执行程序的全过程（当然gcc命令还有更多使用方式，在这里不深入讨论）。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ol><li><p>GCC\G++</p><p>gcc 和 g++分别是GNU的c、c++的编译器，主要用于LINUX平台。现在大多Linux的发行版都会自带这两个编译器。</p></li><li><p>MinGW</p><p>其实MinGW就是GCC\G++在windows环境下的移植，上面我用来演示编译过程就是用的MinGW，与Linux下使用gcc没什么区别。</p></li><li><p>MSVC</p><p>这是Windows环境下的编译器，我们在安装Visual Studio之后就会自带这个编译器。</p></li></ol><h2 id="IDE（集成开发环境）"><a href="#IDE（集成开发环境）" class="headerlink" title="IDE（集成开发环境）"></a>IDE（集成开发环境）</h2><p>前边说的VC++6.0、CodeBlocks其实是在这个范畴，IDE是将文件管理系统、编辑器、编译器、调试、版本管理、代码提示、远程连接等等会用到的工具进行了一个打包，让程序员尽量做到开箱即用。</p><p>在windows环境下，我们大部分初学者接触到的都是微软的那套软件，我个人推荐的就是大名鼎鼎的Visual Studio，真正让初学者做到了开箱即食，能够尽快入门，而不是把时间和热情消耗在各种奇怪的环境配置上。</p><p>另外关于VScode，它本体其实只能算一个文本编辑器（记事本同级），加上各种插件之后才得以拿来开发。喜欢定制化、有时间折腾的朋友推荐使用，我个人最喜欢的就是vscode。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内容很简单，对大部分朋友来说这个问题可能太过低端，文中也没多少干货，但想想两年前的自己确实需要这种“启蒙”的文章，或许就有人需要呢。</p><p>最后附上本人正在使用开发工具大合集，你喜欢哪一款的风格呢？</p><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231206201826011.png" class="" title="image-20231206201826011"><img src="/2023/12/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8EIDE/image-20231206202027987.png" class="" title="image-20231206202027987"><p>上边两个是微软出品，下边是JetBrains全家桶中的两个</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是环境变量——windows</title>
      <link href="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
      <url>/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​我们在配置各种开发环境的时候，常常会包含一个步骤：配置环境变量。</p><p>​那么什么是环境变量，这个步骤是为了做什么，接下来我会抛掉官方解释，逐步带大家测试。（windows环境下）</p><h2 id="终端中执行的命令是什么"><a href="#终端中执行的命令是什么" class="headerlink" title="终端中执行的命令是什么"></a>终端中执行的命令是什么</h2><p>​我们经常会在电脑终端(cmd或者powershell)中输入&#x3D;&#x3D;ipconfig&#x3D;&#x3D;命令来查看电脑的网络配置，如图：</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204153850323.png" class="" title="image-20231204153850323"><p>​为什么输入ipconfig命令就会输出这些信息，这里先跟大家介绍一个新命令&#x3D;&#x3D;get-Command&#x3D;&#x3D;，这个命令的作用是获取其他命令的信息，这里我们目的是为了获取它的路径。（熟悉linux的朋友会不会想到where、which命令）</p><p>我们在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-Command ipconfig</span><br></pre></td></tr></table></figure><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204154604859.png" class="" title="image-20231204154604859"><p>​哦豁，看见Source条目没，首先它就是一个exe可执行程序！！其实想来也是，大一的计算机概论课就告诉我们计算机上执行的就是一堆二进制文件。</p><p>​有兴趣的朋友可以进到这个目录双击执行下这个文件，运气好就能看到输出信息。（但是八成会一闪而过，需要修改终端的终止行为才能卡住看到信息）</p><h2 id="自己的程序怎样在终端里运行"><a href="#自己的程序怎样在终端里运行" class="headerlink" title="自己的程序怎样在终端里运行"></a>自己的程序怎样在终端里运行</h2><p>​既然知道了Terminal里的各种命令本质就是一些二进制文件，那么我们学了c语言，成天到晚printf，我们编写的程序是不是也能这样运行呢？当然可以，程序都是人写的，微软程序员宁有种乎？！（bushi）</p><p>​这里先准备了一个简单程序，功能就是打印”current directory”这句话。</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204161326079.png" class="" title="image-20231204161326079"><p>​接下来我们进入文件所在目录，右键选择在终端中打开，就会弹出右边的窗口（你的可能和我不一样，powershell美化教程后续会出）</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204161728786.png" class="" title="image-20231204161728786"><p>​接下来在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPath</span><br></pre></td></tr></table></figure><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204162242146.png" class="" title="image-20231204162242146"><p>​哦豁，翻车了这下。。但是根据提示，我们再输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\myPath.exe</span><br><span class="line">或者</span><br><span class="line">.\myPath</span><br></pre></td></tr></table></figure><p>​<img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204162506238.png" class="" title="image-20231204162506238"></p><p>​这下ok了，所以我们的程序在终端也是可以执行的。</p><h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p>​为什么我们的程序必须加上 .\ 才可以运行呢，而且注意观察刚才的报错，Suggestion中提到了它在当前目录下检测到了这个程序，说明系统其实找到了这个文件，但是为什么不直接执行。</p><p>​这个问题有人回答是一种安全设计，防止恶意程序执行、防止环境变量与当前目录中的同名程序冲突等。本人没有继续深究，有兴趣的朋友可以继续探索。综上，这里的 .\ 就是指定了运行当前目录的程序</p><h2 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h2><p>​刚才我们想要执行程序，必须进入到程序所在的目录，或者完整指定程序的路径：</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204164412398.png" class="" title="image-20231204164412398"><p>​为什么系统中的命令，比如&#x3D;&#x3D;ipconfig&#x3D;&#x3D;不管我们在哪都可以执行呢？这就是环境变量的作用。</p><p>按照下图的步骤打开环境变量编辑器，</p><p>​<img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204165105696.png" class="" title="image-20231204165105696"></p><p>​观察新弹出的窗口，会有一个系统环境变量和一个用户变量（以你的用户名命名），这两个窗口都包含一个Path的条目，双击可以打开：</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204165635829.png" class="" title="image-20231204165635829"><p>​这里存的就是一堆路径，如果你还记得的话，&#x3D;&#x3D;C:\Windows\system32&#x3D;&#x3D;路径里就存着我们的&#x3D;&#x3D;ipconfig&#x3D;&#x3D;命令。</p><p>​到这就可以告诉大家了，当我们在终端输入一个命令时，系统就会在这一堆路径里去查找，找到了就执行，没有就报错。</p><p>​我们把刚才的程序所在路径添加到下边，再在终端执行（注意一定要先保存环境变量编辑，再新打开一个终端）<img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204170501737.png" class="" title="image-20231204170501737"></p><p>成功执行！说明系统正确查找到了我的程序。</p><h2 id="系统变量与用户变量"><a href="#系统变量与用户变量" class="headerlink" title="系统变量与用户变量"></a>系统变量与用户变量</h2><p>​但是还有一个问题，为什么还分系统变量和用户变量呢，他们有什么区别？</p><p>​windows系统与Linux一样，都支持多用户操作（虽然我们大部分朋友都是单用户使用），比如办公室的公用电脑，为了防止开发环境冲突，或者有些程序我们并不想让其他用户使用，我们就可以只配置当前用户的环境变量。在这种要求下，我们很快也能想到，他们两个就是查找顺序的区别，并且肯定是先系统变量，再用户变量。</p><p>​我重新生成了两个myPath程序，分别放在用户变量和系统变量中，各自输出：”SystemPath“和”UserPath“</p><p>​<img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204171908509.png" class="" title="image-20231204171908509"></p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204172002808.png" class="" title="image-20231204172002808"><p>此时再执行命令，发现输出的是”systemPath”，系统环境变量的程序</p><p>接下来删掉系统变量的条目，再开新终端执行，发现输出的是”userPath”，用户变量的程序</p><img src="/2023/12/04/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/image-20231204172449841.png" class="" title="image-20231204172449841"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，现在就可以回答之前搭建开发环境的问题，环境变量的作用就是让系统可以找到你需要的那些工具，比如Python、MinGW、JDK、conda等等。我们可以打开这些工具的bin目录，里边肯定会有一堆可执行程序，所谓的配置开发环境就是让这些工具正常使用。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>​1.系统不会递归的查找目录的子文件夹，不然直接放个C、D、E盘三个根目录，直接把电脑翻干净了hhh</p><p>​2.系统查找的流程是从上到下执行，只要找到程序就停止查询，配置环境有时候就会在这栽跟头</p><p>​3.窗口中除了Path项目，其他的条目就像是在给文件夹起别名，比如我们会找到TEMP这个变量，它的值就是”C:Users\你的用户名\AppData\Local\Temp”。起完别名我们可以直接在Path中用&#x3D;&#x3D;%别名%&#x3D;&#x3D;来使用</p><p>最后，由于本人还在学习，能力有限，文中如有错误恳请指正，将不胜感激！</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
