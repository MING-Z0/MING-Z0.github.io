<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>全面理解STL-vector容器与迭代器入门 | MINGの部落格</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="vector容器构造显式构造指定一个参数 explicit vector(size_t n)123456#include &lt;vector&gt;using namespace std;int main()&amp;#123;    vector&lt;int&gt; a;    return 0;  vector 的功能是长度可变的数组，他里面的数据存储在堆上。  使用sizeof(vector)会">
<meta property="og:type" content="article">
<meta property="og:title" content="全面理解STL-vector容器与迭代器入门">
<meta property="og:url" content="https://ming-z0.github.io/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="MINGの部落格">
<meta property="og:description" content="vector容器构造显式构造指定一个参数 explicit vector(size_t n)123456#include &lt;vector&gt;using namespace std;int main()&amp;#123;    vector&lt;int&gt; a;    return 0;  vector 的功能是长度可变的数组，他里面的数据存储在堆上。  使用sizeof(vector)会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg">
<meta property="article:published_time" content="2024-10-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-27T11:07:13.723Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="开发语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg"><link rel="shortcut icon" href="/./img/%E5%9B%BE%E6%A0%87/favicon.png"><link rel="canonical" href="https://ming-z0.github.io/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "i8gwfiuxij");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: Ming","link":"链接: ","source":"来源: MINGの部落格","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '全面理解STL-vector容器与迭代器入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-27 19:07:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4271902_rs891qgkdfh.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分析</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VB4y137ys/"><i class="fa-fw fas fa-heart"></i><span> ROS2理论与实践</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y147hS/"><i class="fa-fw fas fa-heart"></i><span> 动手学深度学习</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://geek-logic.com/"><i class="fa-fw fas fa-heart"></i><span> Geek Logic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/parallel101/cppguidebook"><i class="fa-fw fas fa-heart"></i><span> 小彭老师C++大典</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MINGの部落格"><span class="site-name">MINGの部落格</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分析</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VB4y137ys/"><i class="fa-fw fas fa-heart"></i><span> ROS2理论与实践</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y147hS/"><i class="fa-fw fas fa-heart"></i><span> 动手学深度学习</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://geek-logic.com/"><i class="fa-fw fas fa-heart"></i><span> Geek Logic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/parallel101/cppguidebook"><i class="fa-fw fas fa-heart"></i><span> 小彭老师C++大典</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">全面理解STL-vector容器与迭代器入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-20T16:00:00.000Z" title="发表于 2024-10-21 00:00:00">2024-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-27T11:07:13.723Z" title="更新于 2024-10-27 19:07:13">2024-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>68分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="全面理解STL-vector容器与迭代器入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="显式构造"><a href="#显式构造" class="headerlink" title="显式构造"></a>显式构造</h4><h5 id="指定一个参数-explicit-vector-size-t-n"><a href="#指定一个参数-explicit-vector-size-t-n" class="headerlink" title="指定一个参数 explicit vector(size_t n)"></a>指定一个参数 <code>explicit vector(size_t n)</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>vector 的功能是长度可变的数组，他里面的数据存储在堆上。</p>
<ul>
<li><p>使用<code>sizeof(vector)</code>会得到vector的大小是24，即三个指针的大小</p>
</li>
<li><p>第一个指针指向堆上内存的起始地址</p>
</li>
<li><p>第二个指针标志着有效元素结束位置</p>
</li>
<li><p>第三个指针指向分配给<code>vector</code>的总容量位置，表示<code>vector</code>可以存储多少元素而不需要重新分配内存</p>
</li>
</ul>
<p>vector 是一个模板类，第一个模板参数是数组里元素的类型。</p>
<p>例如，声明一个元素是 int 类型的动态数组 a：<code>vector&lt;int&gt; a;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure>

<p>vector 可以在构造时指定初始长度。</p>
<p>例如，要创建一个长度为 4 的 int 型数组：<code>vector&lt;int&gt; a(4);</code></p>
<p>之后可以通过 a.size() 获得数组的长度。比如上面的代码会得到 4。</p>
<p><strong>另外：</strong></p>
<ul>
<li><p>vector 的这个显式构造函数，默认会把所有元素都初始化为 0（不必手动去 memset）。</p>
</li>
<li><p>•如果是其他自定义类，则会调用元素的默认构造函数（例如：数字类型会初始化为 0，string 会初始化为空字符串，指针类型会初始化为 nullptr）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span><span class="comment">//自定义打印，详见本节小技巧</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="指定两个参数-explicit-vector-size-t-n-int-const-val"><a href="#指定两个参数-explicit-vector-size-t-n-int-const-val" class="headerlink" title="指定两个参数 explicit vector(size_t n, int const &amp;val)"></a>指定两个参数 <code>explicit vector(size_t n, int const &amp;val)</code></h5><p>这个显式构造函数还可以指定第二个参数，这样就可以用 0 以外的值初始化整个数组了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">233</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如要创建 4 个 233 组成的数组就可以写：</p>
<p><code>vector&lt;int&gt; a(4, 233);</code></p>
<p>等价于</p>
<p><code>vector&lt;int&gt; a = &#123;233, 233, 233, 233&#125;;</code></p>
<h4 id="初始化列表构造"><a href="#初始化列表构造" class="headerlink" title="初始化列表构造"></a>初始化列表构造</h4><p><code>vector(initializer_list&lt;int&gt; list);</code></p>
<p>除了先指定大小再一个个构造之外，还可以直接利用初始化列表（C++11 新特性）在构造时就初始化其中元素的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如创建具有 6, 1, 7, 4 四个元素的 vector：</p>
<p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p>
<p>和刚刚先创建再赋值的方法相比更直观。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化表达式的<strong>等号</strong>可以写也可以不写：</p>
<p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p>
<p><code>vector&lt;int&gt; a&#123;6, 1, 7, 4&#125;;</code></p>
<p>都是等价的。</p>
<p><strong>注意，</strong>这意味着如果用花括号的 <code>&#123;4&#125; </code>初始化：</p>
<p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p>
<p>会得到长度为 1 只有一个元素 4 的数组。</p>
<p>如果需要长度为 4，元素全部为 0 的数组，必须用圆括号<code> ()</code> 而不是花括号 <code>&#123;&#125;</code>，这样才能保证调用他的显式<code>（explicit）</code>构造函数：</p>
<p><code>vector&lt;int&gt; a(4);</code></p>
<p>会得到长度为 4 元素全为 0 的数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 4</span></span><br><span class="line"><span class="comment">// a.size() = 1</span></span><br></pre></td></tr></table></figure>

<p>这在对于<strong>只能用花括号初始化</strong>的类成员来说，就有很大问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p>
<p>会得到长度为 1 只有一个元素 4 的数组。</p>
<p>但还是可以用这种写法强制调用显式构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector&lt;int&gt; a = vector&lt;int&gt;(4);</code></p>
<p>会得到长度为 4 元素全为 0 的数组。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>添加一个运算符重载用于打印 vector 类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	printer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, vector&lt;T&gt; <span class="type">const</span> &amp;v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        os &lt;&lt; *it;</span><br><span class="line">        <span class="keyword">for</span> (++it; it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; *it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><p><code>int &amp;operator[](size_t i) noexcept;</code></p>
<p><code>int const &amp;operator[](size_t i) const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br></pre></td></tr></table></figure>

<p>要访问 vector 里的元素，只需用 [] 运算符：</p>
<ul>
<li><p>例如 a[0] 访问第 0 个元素（人类的第一个）</p>
</li>
<li><p>例如 a[1] 访问第 1 个元素（人类的第二个）</p>
</li>
</ul>
<p><strong>值得注意</strong>的是，<code>[]</code> 运算符在索引超出数组大小时并不会直接报错，这是为了性能的考虑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1000] = &quot;</span> &lt;&lt; a[<span class="number">1000</span>] &lt;&lt; endl;<span class="comment">// 越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br><span class="line"><span class="comment">//a[100] = 0	//越界访问</span></span><br></pre></td></tr></table></figure>



<p>如果你不小心用<code> []</code>访问了越界的索引，可能会覆盖掉别的变量导致程序行为异常，或是访问到操作系统未映射的区域导致奔溃。</p>
<h3 id="at-函数"><a href="#at-函数" class="headerlink" title="at()函数"></a><code>at()</code>函数</h3><p><code>int &amp;at(size_t i);</code></p>
<p><code>int const &amp;at(size_t i) const;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(0) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(2) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(3) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1000) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1000</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a.at(0) = 0</span></span><br><span class="line"><span class="comment">// a.at(1) = 0</span></span><br><span class="line"><span class="comment">// a.at(2) = 0</span></span><br><span class="line"><span class="comment">// a.at(3) = 0</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"><span class="comment">//   what():  vector::_M_range_check: __n (which is 1000) &gt;= this-&gt;size() (which is 4)</span></span><br></pre></td></tr></table></figure>

<p>为了防止不小心越界，可以用 <code>a.at(i)</code> 替代 <code>a[i]</code>，&#96;&#96;at<code> 函数会检测索引 i 是否越界，如果他发现索引</code> i &gt;&#x3D; a.size() <code>则会抛出异常 </code>std::out_of_range<code>让程序提前终止（或者被</code>try-catch &#96;捕获），配合任意一款调试器，就可以很快速地定位到出错点。</p>
<p>不过 <code>at</code> 需要额外检测下标是否越界，虽然更安全方便调试，但和 <code>[]</code> 相比有一定性能损失。</p>
<ul>
<li>上面只演示了读取操作，当然可以使用<code>[]</code>和<code>at</code>进行写入操作</li>
</ul>
<h3 id="resize-函数"><a href="#resize-函数" class="headerlink" title="resize()函数"></a><code>resize()</code>函数</h3><p><code>void resize(size_t n);</code></p>
<p>除了可以在构造函数中指定数组的大小，还可以之后再通过 resize 函数设置大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<p>这在无法一开始就指定大小的情况下非常方便。</p>
<p>当然，resize 也有一个接受第二参数的重载，他会用这个参数的值填充所有新建的元素。</p>
<p><code>void resize(size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用 resize(n) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用</strong> <strong>0</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.resize(4);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 0, 0&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>resize(n)</code> 的时候，如果数组已有超过 n 个元素，假设是 m 个，则他<strong>会删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p>
<p><code>a.resize(4);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用第二个重载 resize(n, val) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用第二个参数</strong> <strong>val</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.resize(4, 233);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 233, 233&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用第二个重载 resize(n, val) 的时候，如果数组已有超过 n 个元素，假设是 m 个，则第二参数 val 会被<strong>无视</strong>，<strong>删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p>
<p><code>a.resize(4, 233);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a><code>clear()</code>函数</h3><p><code>void clear() noexcept</code></p>
<p>vector 的 clear 函数可以<strong>清空该数组</strong>，也就相当于把长度设为零，变成空数组。例如：</p>
<p><code>a.clear();</code></p>
<p>等价于：</p>
<p><code>a.resize(0);  或  a = &#123;&#125;;</code></p>
<p>通常用于后面需要重新 push_back，因此可以 clear 来把数组设为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clear配合resize</strong></p>
<p>resize 会保留原数组的前面部分不变，只在后面填充上 0。(具有一定软弱性)</p>
<p>如果需要把原数组前面的部分也填充上 0，可以<strong>先</strong> <strong>clear</strong> <strong>再</strong> <strong>resize</strong>，这是一个常见的组合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a><code>push_back()</code>函数</h3><p><code>void push_back(int const &amp;val);</code></p>
<p><code>void push_back(int &amp;&amp;val); // C++11 新增</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以<strong>在数组的末尾追加</strong>一个数。例如：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.push_back(3);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a><code>pop_back()</code>函数</h3><p><code>void pop_back() noexcept</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure>

<p>pop_back 函数则是和 push_back 唱反调，他是<strong>在数组的末尾删除</strong>一个数。例如：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p>
<p><code>a.pop_back();</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a><code>back()</code>函数</h3><p><code>int &amp;back() noexcept;</code></p>
<p><code>int const &amp;back() const noexcept</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> val = a.<span class="built_in">back</span>();</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//back = 3</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure>

<p>要注意的是 <code>pop_back</code> 函数的返回类型是 <code>void</code>，也就是没有返回值，如果需要获取删除的值，可以在 <code>pop_back()</code> 之前先通过 <code>back()</code> <strong>获取末尾元素的值</strong>，实现 pop 效果。</p>
<p><code>a.back();</code></p>
<p>等价于：</p>
<p><code>a[a.size() - 1]</code></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a><code>front()</code>函数</h3><p><code>int &amp;front() noexcept;</code></p>
<p><code>int const &amp;front() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[a.size() - 1] = &quot;</span> &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.front() = &quot;</span> &lt;&lt; a.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.back() = &quot;</span> &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 1</span></span><br><span class="line"><span class="comment">// a[a.size() - 1] = 3</span></span><br><span class="line"><span class="comment">// a.front() = 1</span></span><br><span class="line"><span class="comment">// a.back() = 3</span></span><br></pre></td></tr></table></figure>

<p>和 <code>back()</code> 相对的还有一个 <code>front()</code>。</p>
<p><code>back()</code> 返回<strong>末尾元素</strong>的引用 <code>a[a.size() - 1]</code>。</p>
<p>而 <code>front()</code> 返回<strong>首个元素</strong>的引用 <code>a[0]</code>。</p>
<p><code>a.front();</code></p>
<p>等价于：</p>
<p><code>a[0]</code></p>
<h3 id="data-获取首地址指针"><a href="#data-获取首地址指针" class="headerlink" title="data()获取首地址指针"></a><code>data()</code>获取首地址指针</h3><p><code>int *data() noexcept;</code></p>
<p><code>int const *data() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//int n = a.size();</span></span><br><span class="line">    <span class="comment">//memset(p, -1, sizeof(int) * n);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>data() 会返回指向数组中<strong>首个元素的指针</strong>，也就是等价于 &amp;a[0]。由于 vector 是连续存储的数组，因此只要得到了首地址，下一个元素的地址只需指针 +1 即可。</p>
<p>因为指针的 p[i] 相当于 *(p + i)，因此可以把 data() 返回的首地址指针当一个数组来访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;-1,-1,-1,-1,-1&#125;</span></span><br></pre></td></tr></table></figure>

<p>data() 返回的<strong>首地址指针</strong>，通常配合 size() 返回的<strong>数组长度</strong>一起使用（连续的动态数组只需要知道首地址和数组长度即可完全确定）。</p>
<p>用他来获取一个 C 语言原始指针 int *，很方便用于调用 C 语言的函数和 API 等，同时还能享受到 vector 容器 RAII 的安全性。</p>
<h3 id="RAII思想避免内存泄露"><a href="#RAII思想避免内存泄露" class="headerlink" title="RAII思想避免内存泄露"></a>RAII思想避免内存泄露</h3><p>RAII: 资源获取即初始化，使用局部对象来管理资源的技术称为资源获取即初始化。利用栈对象自动销毁的特点来实现，<strong>通过构造函数获取资源，通过析构函数释放资源</strong>。</p>
<p>如果用 new&#x2F;delete 或者 malloc&#x2F;free 就很容易出现忘记释放内存的情况，造成内存泄露。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pixels = <span class="keyword">new</span> <span class="type">char</span>[camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>];	<span class="comment">//使用new</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels));</span><br><span class="line"><span class="keyword">delete</span> pixels;	<span class="comment">//容易忘记释放</span></span><br></pre></td></tr></table></figure>

<p>而 vector 会在离开作用域时，自动调用解构函数，释放内存，就不必手动释放了，更安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">pixels</span><span class="params">(camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>)</span></span>;	<span class="comment">//使用vector</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels.<span class="built_in">data</span>()));	<span class="comment">//通过.data配合c语言操作</span></span><br><span class="line"><span class="comment">//vector离开作用域时，自动释放，.data获取的指针也会失效</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>C++ 中最神奇的运算符 <code>&#125;</code></p>
<p> <code>&#125;</code> 标志着一个语句块的结束，在这里，他会调用所有身处其中的对象的解构函数。比如这里的 <code>vector</code>，他的解构函数会释放动态数组的内存（即自动 delete）。</p>
<p><code>vector</code> 会在退出作用域时释放内存，这时候所有指向其中元素的指针，包括 <code>data()</code> 都会失效。因此如果你是在语句块内获取的 <code>data()</code> 指针，语句块外就无法访问了。</p>
<p>可见 <code>data()</code> 指针是对 <code>vector</code> 的一种引用，实际对象生命周期仍由 <code>vector</code> 类本身管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021	无效数</span></span><br></pre></td></tr></table></figure>

<h4 id="延续生命周期"><a href="#延续生命周期" class="headerlink" title="延续生命周期"></a>延续生命周期</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt; holder;//全局变量，main退出释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; holder;	<span class="comment">//与p生命周期相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        holder = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p>如果需要在一个语句块外仍然保持 data() 对数组的弱引用有效，可以把语句块内的 vector 对象移动到外面的一个 vector 对象上。vector 在移动时指针不会失效，例如：</p>
<p><code>a = move(b)</code></p>
<p>则会把 b 变成空数组，a 指向原来 b 所包含的元素数组，且地址不变。</p>
<p>之后即使不直接使用外面的那个临时对象 a，也可以继续通过 data() 指针来访问数据。</p>
<p>也可以移动到一个全局变量的 vector 对象。这样数组就会一直等到 main 退出了才释放。</p>
<ul>
<li>C++ 规定全局变量都会在进入 main 函数<strong>之前</strong>构造，main 函数返回之后解构</li>
</ul>
<h3 id="resize-和内存管理"><a href="#resize-和内存管理" class="headerlink" title="resize()和内存管理"></a><code>resize()</code>和内存管理</h3><h4 id="resize到更大尺寸会导致data失效"><a href="#resize到更大尺寸会导致data失效" class="headerlink" title="resize到更大尺寸会导致data失效"></a>resize到更大尺寸会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">1024</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021</span></span><br></pre></td></tr></table></figure>

<p>当 resize 的目标长度<strong>大于</strong>原有的容量时，就需要<strong>重新分配一段更大的连续内存</strong>，并把<strong>原数组长度的部分移动过去</strong>，多出来的部分则用 0 来填充。这就导致元素的地址会有所改变，从而过去 data 返回的指针以及所有的迭代器对象，都会失效。</p>
<h4 id="resize到更小尺寸不会导致data失效"><a href="#resize到更小尺寸不会导致data失效" class="headerlink" title="resize到更小尺寸不会导致data失效"></a>resize到更小尺寸不会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当 resize 的目标长度<strong>小于</strong>原有的容量时，不需要重新分配一段连续的内存也不会造成元素的移动（这个设计是为了性能考虑），所以指向元素的指针不会失效。他只是会把数组的长度标记为新长度，后面<strong>空闲出来那一段内存不会释放掉</strong>，继续留在那里，直到 vector 对象被解构。</p>
<p><strong>重新resize到原来也不会导致data失效</strong></p>
<ul>
<li>调用了 a.resize(2) 之后，数组的<strong>容量</strong>仍然是 5，因此重新扩容到 5 是不需要重新分配内存的，也就不会移动元素导致指针失效。</li>
</ul>
<h4 id="capacity-函数查询实际的最大容量"><a href="#capacity-函数查询实际的最大容量" class="headerlink" title="capacity()函数查询实际的最大容量"></a><code>capacity()</code>函数查询实际的最大容量</h4><p><code>size_t capacity() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 7/10</span></span><br></pre></td></tr></table></figure>

<p>可以用 capacity() 函数查询已经分配内存的大小，即<strong>最大容量</strong>。</p>
<p>而 size() 返回的其实是已经存储了数据的<strong>数组长度</strong>。</p>
<p>可以发现当 resize 指定的新<strong>长度</strong>一个超过原来的最大<strong>容量</strong>时时，就会重新分配一段更大<strong>容量</strong>的内存来存储数组，只有这时才会移动元素的位置（data 指针失效）。</p>
<h4 id="resize-的优化策略"><a href="#resize-的优化策略" class="headerlink" title="resize()的优化策略"></a><code>resize()</code>的优化策略</h4><p>注意这里 resize(7) 之后容量实际上扩充到了 10 而不是刚好 7，为什么？</p>
<p>因为标准库的设计者非常聪明，他料想到了你 resize(7) 以后可能还会来个 resize(8) 甚至 resize(9) 之类的。为了减少重复分配的次数，他有一个策略：当 resize 后的新尺寸变化较小时，则<strong>自动扩容至原尺寸的两倍</strong>。</p>
<p>这里我们的原大小是 5，所以 resize(7) 会扩充<strong>容量</strong>到 10，但是<strong>尺寸</strong>为 7。</p>
<ul>
<li><p>尺寸总是小于等于容量。</p>
</li>
<li><p>尺寸范围内都是已初始化的内存(零)。</p>
</li>
<li><p>寸到容量之间的范围是未初始化的。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 12/12</span></span><br></pre></td></tr></table></figure>

<p>不过如果 <code>resize</code> 后的尺寸还超过了原先尺寸的两倍，就没有这个效果了。</p>
<p>也就是说 <code>resize(n)</code> 的逻辑是扩容至 <code>max(n, capacity * 2)</code>。</p>
<h4 id="reserve-预留一定容量，避免之后重复分配"><a href="#reserve-预留一定容量，避免之后重复分配" class="headerlink" title="reserve()预留一定容量，避免之后重复分配"></a><code>reserve()</code>预留一定容量，避免之后重复分配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">12</span>);	<span class="comment">//预留12</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 0x1a8d4b9eb90 5/5</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 2/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 12/12</span></span><br></pre></td></tr></table></figure>

<p>内存分配是需要一定时间的。如果我们程序员能预料到数组最终的大小，可以用 <code>reserve</code> 函数<strong>预留</strong>一定的容量，这样之后就不会出现容量不足而需要动态扩容影响性能了。</p>
<p>例如这里我们一开始预留了 12 格容量，这样从 5 到 12 的时候就不必重新分配。此外，还要注意 <code>reserve</code> 时也会移动元素。</p>
<h4 id="shrink-t0-fit-释放多余的容量"><a href="#shrink-t0-fit-释放多余的容量" class="headerlink" title="shrink_t0_fit()释放多余的容量"></a><code>shrink_t0_fit()</code>释放多余的容量</h4><p>刚刚说过，当 <code>resize</code> 到一个更小的大小上时，多余的容量不会释放，而是继续保留。如担心内存告急可以用 <code>shrink_to_fit</code> 释放掉多余的容量，只保留刚好为 size() 大小的容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 5/5</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 12/12</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 4/12</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 4/4</span></span><br></pre></td></tr></table></figure>

<p><code>shrink_to_fit</code> 会重新分配一段更小内存，他同样是会把元素移动到新内存中的，因此迭代器和指针也会失效。</p>
<h3 id="一个小工具：mallochook"><a href="#一个小工具：mallochook" class="headerlink" title="一个小工具：mallochook"></a>一个小工具：mallochook</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/sjp38/mallochook/blob/master/mallochook.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __unix__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">static</span> <span class="type">malloc_t</span> malloc_fn = (<span class="type">malloc_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc_fn</span>(size);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[32mmalloc(%zu) = %p\033[0m\n&quot;</span>, size, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">free_t</span> free_fn = (<span class="type">free_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[31mfree(%p)\033[0m\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free_fn</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了追踪所有的内存分配与释放，我们试着重写一下 malloc 和 free 函数。</p>
<p>这样当 vector 容器分配或是释放内存的时候，我们就能轻松看到。</p>
<p>不过这个只能 Linux 系统可以用哦</p>
<h3 id="puch-back-的问题"><a href="#puch-back-的问题" class="headerlink" title="puch_back()的问题"></a><code>puch_back()</code>的问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab167f12a0</span></span><br><span class="line"><span class="comment">// malloc(4) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// malloc(8) = 0xaaab16802ed0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ed0)</span></span><br><span class="line"><span class="comment">// malloc(32) = 0xaaab16802ef0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(64) = 0xaaab16802f20</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ef0)</span></span><br><span class="line"><span class="comment">// malloc(128) = 0xaaab16802f70</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f20)</span></span><br><span class="line"><span class="comment">// malloc(256) = 0xaaab16803000</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f70)</span></span><br><span class="line"><span class="comment">// malloc(512) = 0xaaab16803110</span></span><br><span class="line"><span class="comment">// free(0xaaab16803000)</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab16803320</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaab16803110)</span></span><br></pre></td></tr></table></figure>

<p>由于不知道你究竟会推入多少个元素，vector 的初始容量是零，而 push_back 和 resize 一样，每次遇到容量不足时，都会扩容两倍，例如上面的输出。</p>
<p>这也体现了<strong>实际容量</strong><code>(capacity)</code>和数组大小<code>(size)</code>分离的好处，如果死板地让分配的内存容量始终等于当前数组大小（很多同学都号称自己实现过 <code>vector</code>，都是这种写法），那么如果要用 push_back 推入 n 个元素，就需要重新分配内存 n 次，移动元素 n(n+1)&#x2F;2 次。</p>
<p>而像标准库这样允许数组大小和实际容量不同，这样 push_back 在容量不足的时候就可以一次性扩容两倍，只需重新分配 logn 次，移动元素 2n-1 次。</p>
<h4 id="解决：reserve"><a href="#解决：reserve" class="headerlink" title="解决：reserve()"></a>解决：<code>reserve()</code></h4><p>因此，如果你早就知道要推入元素的数量，可以调用 reserve 函数先预留那么多的<strong>容量</strong>，等待接下来的推入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 预留空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaaf6e992a0</span></span><br><span class="line"><span class="comment">// malloc(400) = 0xaaaaf6eaaeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaaf6eab050</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaaaf6eaaeb0)</span></span><br></pre></td></tr></table></figure>

<p>这样之后 push_back 时，就不会一次次地扩容两倍慢慢成长到 128，避免重新分配内存和移动元素，更高效。</p>
<p>比如这里我们可以提前知道循环会执行 100 次，因此 reserve(100) 就可以了。</p>
<p>可以看到只有一次 malloc(400)，之后那次 malloc(1024) 是 cout 造成的，不必在意。</p>
<h3 id="clear-的问题"><a href="#clear-的问题" class="headerlink" title="clear()的问题"></a><code>clear()</code>的问题</h3><p>刚刚说过，<code>clear</code> 相当于 <code>resize(0)</code>，所以他也不会实际释放掉内存，**容量(capacity)<strong>还是摆在那里，clear 仅仅只是把</strong>数组大小(size)**标记为 0 而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaae7f4d2a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaaae7f5eeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaae7f5eed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// after clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaaae7f5eeb0)</span></span><br></pre></td></tr></table></figure>

<p>这可能导致在低端平台上内存告急，这是因为尽管你已经 clear 掉 vector 了而实际容量还在并没有释放。</p>
<h4 id="解决：shrink-to-fit"><a href="#解决：shrink-to-fit" class="headerlink" title="解决：shrink_to_fit()"></a>解决：<code>shrink_to_fit()</code></h4><p>要真正释放掉内存，可以在 clear 之后再调用 shrink_to_fit，这样才会让容量也变成 0（这时 vector 的 data 会返回 nullptr）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab077092a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab0771aeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab0771aed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaab0771aeb0)</span></span><br><span class="line"><span class="comment">// after clear, capacity=0</span></span><br></pre></td></tr></table></figure>

<p>当然，vector 对象解构时也会彻底释放内存，这个不用操心。clear 配合 shrink_to_fit 只是提前释放而已。</p>
<h2 id="迭代器入门"><a href="#迭代器入门" class="headerlink" title="迭代器入门"></a>迭代器入门</h2><h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><h4 id="迭代器结构的出现"><a href="#迭代器结构的出现" class="headerlink" title="迭代器结构的出现"></a>迭代器结构的出现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">char</span>&gt; <span class="type">const</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道，可以使用一个函数来封装打印操作，但是这样的缺点是它智能打印<code>vector</code>类型，没法打印<code>string</code>类型，要想支持<code>string</code>只能再实现另一个<code>print</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>());</span><br><span class="line">    string b = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(b.<span class="built_in">data</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>vector</code> 和 <code>string</code> 的底层都是连续的稠密数组，他们都有 <code>data()</code> 和 <code>size()</code> 函数。</p>
<p>因此可改用<strong>首地址指针</strong>和<strong>数组长度</strong>做参数：</p>
<p><code>print(char const *a, size_t n);</code></p>
<p>这样 <code>print</code> 在无需知道容器具体类型的情况下，只用最简单的接口（首地址指针）就完成了遍历和打印的操作。</p>
<p>使用<strong>指针</strong>和<strong>长度</strong>做接口的好处是，可以通过给指针加减运算，选择其中一部分连续的元素来打印，而不一定全部打印出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如这里我们选择打印<strong>前三个元素</strong>（去掉了最后一个元素，但不必用 <code>pop_back</code> 修改数组，只要传参数的时候修改一下<strong>长度</strong> 部分即可）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>() + <span class="number">1</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择打印<strong>后三个元素</strong>（去掉了第一个元素，但不必用 <code>erase</code> 修改数组，只要传参数的时候同时修改<strong>指针</strong>和<strong>长度</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们发现，<strong>首地址指针</strong>和<strong>数组长度</strong>看起来不太对称。</p>
<p><code>print(char const *begptr, size_t size);</code></p>
<p>不妨改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>如何？</p>
<p><code>print(char const *begptr, size_t endptr);</code></p>
<p>注意看，我们在 print 里也不是用<strong>数组下标</strong>去迭代，而是用<strong>指针</strong>作为迭代变量了。</p>
<h4 id="首指针-尾指针"><a href="#首指针-尾指针" class="headerlink" title="首指针 + 尾指针"></a>首指针 + 尾指针</h4><p>改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>以后，要特别注意一点：<strong>尾地址指针</strong>实际上是指向末尾元素再往后后一个元素的指针！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*begptr = &quot;</span> &lt;&lt; *begptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*endptr = &quot;</span> &lt;&lt; *endptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*(endptr - 1) = &quot;</span> &lt;&lt; *(endptr<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// *begptr = h</span></span><br><span class="line"><span class="comment">// *endptr = ?	随机值</span></span><br><span class="line"><span class="comment">// *(endptr - 1) = l</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>也就是说<strong>尾地址指针</strong>所指向的地方是无效的内存 <code>a + a.size()</code>，<strong>尾地址指针减1</strong>才是真正的末尾元素指针 <code>a + a.size() - 1</code>。</p>
<p>为什么要这样设计？因为如果用 a + <code>a.size() - 1</code> 也就是 <code>&amp;a.back()</code> 作为尾地址指针，将无法表示<strong>数组长度为</strong> <strong>0</strong> 的情况。</p>
<p>而让<strong>尾地址指针</strong>往后移动一格的设计，使得数组长度为 0 就是 <code>begptr == endptr</code> 的情况，非常容易判断。</p>
<p>更方便的是你可以通过指针的减法运算： endptr - begptr 来算出数组的长度！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> size = endptr - begptr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;begptr - endptr = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// begptr - endptr = 4</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>for 循环里也很容易写，判断是否继续循环的条件为 <code>ptr != endptr</code> 就行了。</p>
<h4 id="模板实现"><a href="#模板实现" class="headerlink" title="模板实现"></a>模板实现</h4><p>最后，我们可以让<strong>首指针</strong>和<strong>尾指针</strong>声明为模板参数，这样不论指针是什么类型，都可以使用 print 这个模板函数来打印。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *abegptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *aendptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(abegptr, aendptr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bbegptr = b.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bendptr = b.<span class="built_in">data</span>() + b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(bbegptr, bendptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="不连续内存的容器"><a href="#不连续内存的容器" class="headerlink" title="不连续内存的容器"></a>不连续内存的容器</h4><p><strong>首指针</strong>和<strong>尾指针</strong>的组合的确能胜任 vector 这种连续数组，但是对于 list 这种不连续的内存的容器就没辙了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();	<span class="comment">//No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.data + a.<span class="built_in">size</span>();	<span class="comment">// No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，list 没有 data() 这个成员函数，因为他根本就不连续。</p>
<h4 id="首迭代器-尾迭代器"><a href="#首迭代器-尾迭代器" class="headerlink" title="首迭代器 + 尾迭代器"></a>首迭代器 + 尾迭代器</h4><p>然而 list 却提供了 begin() 和 end() 函数，他们会返回两个 list<char>::iterator 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator begptr = a.<span class="built_in">begin</span>();</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator endptr = a.<span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>list&lt;char&gt;::iterator</code> 是一个特殊定义过的类型，其具有 <code>!=</code> 和 <code>++</code> 以及 <code>*</code> 这些<code>**</code><strong>运算符的重载</strong>。所以用起来就像普通的指针一样。而这些运算符重载，却会<strong>把<code>++</code>对应到链表的<code>curr=curr-&gt;next</code>上</strong>。</p>
<p>这样一个用起来就像普通的指针，但内部却通过运算符重载适配不同容器的特殊类，就是<strong>迭代器(iterator)<strong>，迭代器是 STL 中</strong>容器</strong>和<strong>算法</strong>之间的桥梁。</p>
<p>如果让我们来写 list 容器和他的迭代器，他的内部具体实现可能是这样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head + size&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterate_over_list</span><span class="params">(List&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> curr = list.head; curr != <span class="literal">nullptr</span>; curr = curr-&gt;next) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器的这些运算符，都是约定俗成的，其根本目的在于模仿指针的行为，方便来自 C 语言的程序员快速上手掌握 C++ 标准库。</p>
<p>虽然你也可以用直观的函数名 <code>advance()</code> 代替 <code>++</code>，用 deref() 代替 <code>*</code>，equal_to() 代替 <code>==</code>。但是模仿指针行为的这些运算符，已然成为了 C++ 事实上的标准，而且也非常简洁明了。</p>
<p>因此所有的用户和库，都会按照这套运算符标准来实现和使用迭代器，建立起了沟通的桥梁，节省了各自创立一套规范的成本。</p>
<h4 id="迭代器中-的前置和后置"><a href="#迭代器中-的前置和后置" class="headerlink" title="迭代器中++的前置和后置"></a>迭代器中<code>++</code>的前置和后置</h4><p>迭代器的自增运算符分为 <code>++p</code> 和 p++ 两种写法。他们都会产生 <code>p = p + 1</code> 的效果，但是有一个细微的区别，就是他们<strong>被作为表达式时的返回值</strong>。</p>
<ul>
<li><p>**前置自增 <code>++p</code>**：此运算符会先将迭代器<code>p</code>自增，然后返回自增后的迭代器本身。由于返回的是左值引用，因此可以继续进行自增操作，例如<code>++++p</code>。</p>
</li>
<li><p>**后置自增 <code>p++</code>**：此运算符会先返回自增前的迭代器值，然后再执行自增。返回值是一个右值，不能被修改。</p>
</li>
</ul>
<p>正因如此，后置自增需要先保存旧的迭代器，然后自增自己，再返回旧迭代器，可能<strong>会比较低效</strong>。</p>
<p>在 C++ 中我们推荐尽可能地多用前置自增 ++p。</p>
<ul>
<li><p>在运算符重载上，沙雕的C++ 标准委员会规定，<code>operator++(int)</code> 这个重载是后置自增 <code>p++</code>，不带任何参数的<code>operator++()</code> 这个重载是前置自增，之所以这样是因为同名函数只能通过参数列表类型来区分，这个 int 类型参数没有任何实际意义，只是为了区分不同的重载……**编译器会在p++的时候自动改成调用p.operator++(0)**，这个0只是为了区分重载</p>
</li>
<li><pre><code class="cpp">Iterator &amp;operator++()&#123;
    curr = curr-&gt;next;
    return *this;
&#125;
Iterator operator++(int)&#123;
    Iterator tmp = *this;
    this-&gt;operator++();
    return tmp;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## vector容器中的迭代器</span><br><span class="line"></span><br><span class="line">#### `begin()`和`end()`函数</span><br><span class="line"></span><br><span class="line">`begin()` 可以获取指向第一个元素所在位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">`end()` 可以获取指向最后一个元素下一个位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">迭代器的作用类似于一个位置标记符。</span><br><span class="line"></span><br><span class="line">虽然对于 `vector` 来说只需要下标（index）就能标记位置了，例如 Python 中也是通过 0 表示第一个元素，-1 表示最后一个元素：`a[0] a[1] a[-1]`</span><br><span class="line"></span><br><span class="line">而 C++ 的特色就是采用了迭代器（iterator）来标记位置，他实际上是一个指针，这样的好处是：不需要指定原来的容器本身，就能知道指定的位置。</span><br><span class="line"></span><br><span class="line">一对迭代器 `begin` 和 `end` 就标记了一个区间（range）。区间可以是一个容器的全部，例如 `&#123;a.begin(), a.end()&#125;` 区间；也可以是一个容器的部分，例如 `&#123;a.begin() + 1, a.end() - 1&#125;` 相当于去头去尾后的列表，相当于 Python 中的 `a[1:-1]`。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;printer.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator b = a.begin();</span><br><span class="line">    vector&lt;int&gt;::iterator e = a.end();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*b = &quot; &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 1) = &quot; &lt;&lt; *(b + 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 2) = &quot; &lt;&lt; *(b + 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 2) = &quot; &lt;&lt; *(e - 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 1) = &quot; &lt;&lt; *(e - 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*e = &quot; &lt;&lt; *e &lt;&lt; endl;	//直接访问end是一个无效地址</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">// a = &#123;1,2,3,4,5,6&#125;</span><br><span class="line">// *b = 1</span><br><span class="line">// *(b + 1) = 2</span><br><span class="line">// *(b + 2) = 3</span><br><span class="line">// *(e - 2) = 5</span><br><span class="line">// *(e - 1) = 6</span><br><span class="line">// *e = -450617339	随机数</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><code>begin</code> 可以获取指向<strong>第一个元素所在位置</strong>的迭代器。可以通过 <code>*a.begin()</code> 来访问第一个元素。</p>
<p>迭代器支持加法运算，例如 <code>*(a.begin() + 1)</code> 就是访问数组的第二个元素了，和 a[1] 等价。</p>
<p><code>end</code> 可以获取指向<strong>最后一个元素下一个位置</strong>的迭代器。也就是说 <code>end</code> 指向的位置是不可用的！如需访问最后一个元素必须用 <code>*(a.end() - 1)</code> 才行。</p>
<img src="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/image-20241022221652364.png" class="" title="image-20241022221652364">



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator b = a.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator e = a.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[0] = &quot;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[1] = &quot;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[2] = &quot;</span> &lt;&lt; b[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-2] = &quot;</span> &lt;&lt; e[<span class="number">-2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-1] = &quot;</span> &lt;&lt; e[<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[0] = &quot;</span> &lt;&lt; e[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// b[0] = 1</span></span><br><span class="line"><span class="comment">// b[1] = 2</span></span><br><span class="line"><span class="comment">// b[2] = 3</span></span><br><span class="line"><span class="comment">// e[-2] = 5</span></span><br><span class="line"><span class="comment">// e[-1] = 6</span></span><br><span class="line"><span class="comment">// e[0] = -1739380936</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>冷知识</strong>，迭代器实际上还可以用 <code>[]</code> 运算符访问。</p>
<p>例如这里的 <code>b[i]</code> 就和 <code>*(b + i)</code> 等价。</p>
<p>不过只有 vector 这种连续的可随机访问容器的迭代器有 <code>+</code> 和 <code>[]</code> 运算符，对于 list 则只有 <code>*</code> 和 +<code>+</code> 和 <code>--</code> 运算符可以用，这是迭代器的两个分类，详见下一章。</p>
<p>自此，迭代器对象和容器本身的主要区别就在于：</p>
<p>迭代器不掌握生命周期，从而迭代器的拷贝是平凡的<strong>浅拷贝</strong>，方便传参。但也带来了缺点，因为迭代器是一个对原容器的弱引用，如果原容器解构或发生内存重分配，迭代器就会失效。</p>
<h4 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a><code>insert()</code>函数</h4><h5 id="头部插入"><a href="#头部插入" class="headerlink" title="头部插入"></a>头部插入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//b = &#123;233,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们知道 <code>push_back</code> 可以往尾部插入数据，那么如何往<strong>头部</strong>插入数据呢？用<code>insert</code>函数，他的第一个参数是要插入的位置（用迭代器表示），第二个参数则是要插入的值。</p>
<p>注意这个函数的复杂度是 O(n)，n 是从<strong>插入位置<code>pos</code></strong> 到<strong>数组末尾<code>end</code></strong> 的距离。没错，他会插入位置后方的元素整体向后移动一格，是比较低效的，因此为了高效，我们尽量只往尾部插入元素。如果需要高效的头部插入，可以考虑用 <code>deque</code> 容器，他有高效的 <code>push_front</code> 函数替代。</p>
<p><code>insert</code> 在容量不足时，同样会造成重新分配以求扩容，会移动其中所有元素，这时所有之前保存的迭代器都会失效。</p>
<h5 id="特定位置插入"><a href="#特定位置插入" class="headerlink" title="特定位置插入"></a>特定位置插入</h5><p><code>iterator insert(const_iterator pos, int const &amp;val);</code></p>
<p><code>iterator insert(const_iterator pos, int &amp;&amp;val); // C++11</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//  = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,233,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果要插入到一个特定位置，可以用迭代器的加法来获取某一位置的迭代器。</p>
<p>例如 <code>a.begin() + 3</code> 就会指向第三个元素，那么用这个作为 <code>insert</code> 的参数就会把 <code>233</code> 这个值插到第三个元素的位置之前。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置是倒数第二个</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,233,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.begin()</code> 可以插入到开头位置。</p>
<p><code>a.begin() + 1</code> 可以插入到第二个元素位置。</p>
<p><code>a.end()</code> 可以插入到最末尾（append）。</p>
<p><code>a.end() - 1</code> 则是插入到倒数第一个元素前。</p>
<p><code>end()</code> 迭代器的减法和是 Python 中负数作为下标的情况很像的，不过 C++ 更加明确是从 end 开始往前数的。</p>
<h5 id="重复插入多个相同的值"><a href="#重复插入多个相同的值" class="headerlink" title="重复插入多个相同的值"></a>重复插入多个相同的值</h5><p><code>iterator insert(const_iterator pos, size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,233,233,233,1,2,3,4,,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>insert 还有一个特殊的功能，就是他可以插入一个元素很多遍！只需多指定一个参数来表示插入多少遍，语法如下：</p>
<p><code>a.insert(插入位置, 重复多少次, 插入的值);</code></p>
<ul>
<li>你可能会担心，刚刚不是说在头部 insert 是 O(n) 复杂度嘛？那如果再重复 n 次岂不是 O(n²) 复杂度了？</li>
<li>当然不会，<code>insert</code> 的这个重载会一次性批量让 <code>pos</code> 之后的元素移动 n 格，不存在反复移动 1 格的情况，最坏复杂度仍然是 O(n)。如果你自己写个 for 循环反复调 <code>insert</code> 那的确是会 O(n²) 了，这就是为什么 <code>insert</code> 提供这个高效的重载专门负责重复插入的操作。</li>
</ul>
<h5 id="直接插入一个初始化列表"><a href="#直接插入一个初始化列表" class="headerlink" title="直接插入一个初始化列表"></a>直接插入一个初始化列表</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>insert 还可以直接插入一个 <code>&#123;&#125;</code> 的列表！</p>
<p>这个花括号 <code>&#123;&#125;</code> 形成的列表就是传说中的**初始化列表(initializer-list)**，是 C++11 新增的功能，例如这里这个列表的类型是 <code>std::initializer_list&lt;int&gt;</code>。</p>
<p><code>a.insert(插入位置, &#123;插入值1, 插入值2, ...&#125;);</code></p>
<p>这个的最坏复杂度同样是 O(n) 的，并且因为其内部预先知道了要插入列表的长度，会一次性完成扩容，比重复调用 push_back 重复扩容要高效很多。</p>
<h5 id="直接插入另一个vector"><a href="#直接插入另一个vector" class="headerlink" title="直接插入另一个vector"></a>直接插入另一个vector</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p>
<p>能否传入一个vector作为参数呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b); <span class="comment">//直接传入vector对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// test.cpp: In function ‘int main()’:</span></span><br><span class="line"><span class="comment">// test.cpp:12:13: error: no matching function for call to ‘std::vector&lt;int&gt;::insert(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;&amp;)’</span></span><br><span class="line"><span class="comment">//    12 |     a.insert(a.begin(), b); //直接传入vector对象</span></span><br></pre></td></tr></table></figure>

<p>不可以，因为<code>vector</code>和<code>initializer_list</code>不是同一个类型。</p>
<p>那要如何插入另一个数组，或者说把a和b两个数组进行合并？</p>
<p><strong>通过迭代器</strong></p>
<p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>iterator insert(const_iterator pos, It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());    <span class="comment">//传入区间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">//b = 233 666 985 211</span></span><br><span class="line"><span class="comment">//a = 233 666 985 211 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>记得 C++ 的迭代器思想是，<strong>容器</strong>和<strong>算法</strong>之间的交互不是通过容器对象本身，而是他的迭代器，因此 <code>insert</code> 设计时就决心不支持直接接受 <code>vector</code> 作参数，而是接受他的两个迭代器组成的区间！好处有：</p>
<ol>
<li><p>可以批量插入从来自另一个不同类型的容器，例如 list<int>，只要元素类型相等，且符合迭代器规范。</p>
</li>
<li><p>我可以自由选择对方容器的一个子区间（通过迭代器加减法）内的元素来插入，而不是死板的只能全部插入。</p>
</li>
</ol>
<p>刚才 <code>a.insert(a.begin(), b.begin(), b.end())</code> 会把 b 插入在原先 a 元素之前，相当于Python的 a &#x3D; b + a。</p>
<p>可以改用 <code>a.insert(a.end(), b.begin(), b.end())</code> 把 b 插入到 a 元素之后，相当于Python的 <code>a += b</code>，这样性能更好（只要容量足够就无需移动 a 的全部元素）。</p>
<p>当然也可以 <code>a.insert(a.begin() + 3, b.begin(), b.end())</code> 这样只插入到指定位置中间，Python似乎没有这个操作。</p>
<h5 id="数据源可是是不同类型"><a href="#数据源可是是不同类型" class="headerlink" title="数据源可是是不同类型"></a>数据源可是是不同类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>对方容器也可以是<strong>不同类型</strong>的，最底线的要求是只要他的迭代器有 <code>++</code> 和 <code>*</code> 运算符即可。</p>
<p>例如上面的 <code>list&lt;int&gt;::iterator</code> 就符合需求。</p>
<p><strong>甚至可以是一个c语言风格的数组</strong></p>
<p>c++11新增两个函数：</p>
<p><code>template &lt;class T&gt; auto begin(T &amp;&amp;t);</code></p>
<p><code>template &lt;class T&gt; auto end(T &amp;&amp;t);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(b), std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为 C 语言类型没有办法加成员函数 begin 和 end，可以用 <code>std::begin</code> 和 std::end 这两个全局函数代替，当然如果用了 <code>using namespace std</code> 时也可以不写 std:: 前缀。</p>
<p>这两个函数会对于具有 <code>begin</code> 和 <code>end</code> 成员函数的容器会直接调用，对于 C 语言数组则被特化为返回 <code>b</code> 和 <code>b + sizeof(b)/sizeof(b[0])</code>。</p>
<h4 id="构造函数也接受迭代器"><a href="#构造函数也接受迭代器" class="headerlink" title="构造函数也接受迭代器"></a>构造函数也接受迭代器</h4><p><code>template &lt;class It&gt;  // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>explicit vector(It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(std::begin(b), std::end(b))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985.211&#125;</span></span><br></pre></td></tr></table></figure>

<p>vector 容器的构造函数也接受一对迭代器做参数，来初始化其中的元素。同样可以是不同容器的迭代器对象，只要具有 <code>++</code> 和 <code>*</code> 就行了。</p>
<h4 id="assign-函数"><a href="#assign-函数" class="headerlink" title="assign()函数"></a><code>assign()</code>函数</h4><p>重新分配vector中的值</p>
<p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>void assign(It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    a.<span class="built_in">assign</span>(std::<span class="built_in">begin</span>(b),std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了构造函数外，<code>assign</code> 这个成员函数也能在后期把元素覆盖进去。和 <code>insert</code> 不同的是，他会把旧有的数组完全覆盖掉，变成一个新的数组。（清空原来的值，放入新值，注意此时不会重新分配内存）</p>
<p><code>a.assign(beg, end)</code> 基本和 <code>a = vector&lt;int&gt;(beg, end)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量不会释放掉。</p>
<p><code>assign</code> 还有一个<code>重载</code>，可以把 <code>vector</code> 批量填满一个特定的值，重复的次数（长度）也是参数里指定。</p>
<p><code>void assign(size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233, 233, 233, 233&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.assign(n, val)</code> 基本和 <code>a = vector&lt;int&gt;(n, val)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量。</p>
<p>assign 还可以直接接受一个初始化列表作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(&#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a = &#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a = vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;233,666,985,211&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;996,7&#125;</span></span><br><span class="line"><span class="comment">// a.capacity() = 6</span></span><br><span class="line"><span class="comment">// a.capacity() = 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>a.assign(&#123;x, y, ...&#125;)</code> 和 <code>a = &#123;x, y, ...&#125;</code> 完全等价，都会保留原来的容量。而和 <code>a = vector&lt;int&gt;&#123;x, y, ...&#125;</code> 就不等价，这个会重新分配内存。</p>
<h4 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a><code>erase()</code>函数</h4><h5 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h5><p>erase 函数可以删除指定位置的一个元素（通过迭代器指定）。</p>
<p><code>iterator erase(const_iterator pos);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.erase(a.begin())</code> 就是删除第一个元素（相当于 pop_front）。</p>
<p><code>a.erase(a.end() - 1)</code> 就是删除最后一个元素（相当于 pop_back）。</p>
<p><code>a.erase(a.begin() + 2)</code> 就是删除第三个元素。</p>
<p>a.erase(a.end() - 2) 就是删除倒数第二个元素。</p>
<p>erase 的复杂度最坏情况是删除第一个元素 O(n)。如果删的是最后一个元素则复杂度为 O(1)。</p>
<p>这是因为 erase 会移动 pos 之后的那些元素。</p>
<h5 id="指定区间"><a href="#指定区间" class="headerlink" title="指定区间"></a>指定区间</h5><p>erase 也可以指定两个迭代器作为参数，表示把这个区间内的对象都删除。</p>
<p>iterator erase(const_iterator beg, const_iterator end);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如这里 <code>a.erase(a.begin() + 1, a.begin() + 3)</code> 就删除了 a 的第二个和第三个元素，相当于Python的 <code>del a[1:3]</code>，注意 C++ 的 insert 和 erase 都是就地操作的。</p>
<p>例如：<code>a.erase(a.begin() + n, a.end())</code> 就和 <code>a.resize(n)</code> 等价，前提是**<code>n小于a.size()</code>**。</p>
<p>批量删除的最坏复杂度依然是 O(n) 的，不用担心。</p>
<p>不过这里两个作为 erase 参数的迭代器<strong>必须是自己这个对象的迭代器</strong>，不能是其他容器的，这点和 insert 不一样。</p>
<p>他返回删除后<code>最后一个元素之后</code>那个位置的迭代器。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ming-z0.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ming-z0.github.io/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/">https://ming-z0.github.io/2024/10/21/C++/标准库/二、vector容器与迭代器入门/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ming-z0.github.io" target="_blank">MINGの部落格</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/">开发语言</a></div><div class="post_share"><div class="social-share" data-image="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E6%89%93%E8%B5%8F/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/%E6%89%93%E8%B5%8F/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/" title="全面理解STL-std::string用法指南&amp;源码刨析"><img class="cover" src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全面理解STL-std::string用法指南&amp;源码刨析</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/" title="全面理解STL-前言"><img class="cover" src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">全面理解STL-前言</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/" title="全面理解STL-前言"><img class="cover" src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-27</div><div class="title">全面理解STL-前言</div></div></a></div><div><a href="/2024/10/23/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%89%E3%80%81set%E7%B3%BB%E5%88%97%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/" title="全面理解STL-set系列容器与迭代器分类"><img class="cover" src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-27</div><div class="title">全面理解STL-set系列容器与迭代器分类</div></div></a></div><div><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/" title="全面理解STL-std::string用法指南&amp;源码刨析"><img class="cover" src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-30</div><div class="title">全面理解STL-std::string用法指南&amp;源码刨析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ming</div><div class="author-info__description">一个记录、分享自己学习过程的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ming-z0"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ming-z0" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:ming-zhanglu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-text">构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-text">显式构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0-explicit-vector-size-t-n"><span class="toc-text">指定一个参数 explicit vector(size_t n)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0-explicit-vector-size-t-n-int-const-val"><span class="toc-text">指定两个参数 explicit vector(size_t n, int const &amp;val)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0"><span class="toc-text">初始化列表构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">小技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator"><span class="toc-text">operator[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at-%E5%87%BD%E6%95%B0"><span class="toc-text">at()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E5%87%BD%E6%95%B0"><span class="toc-text">resize()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-%E5%87%BD%E6%95%B0"><span class="toc-text">clear()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-back-%E5%87%BD%E6%95%B0"><span class="toc-text">push_back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop-back-%E5%87%BD%E6%95%B0"><span class="toc-text">pop_back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#back-%E5%87%BD%E6%95%B0"><span class="toc-text">back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#front-%E5%87%BD%E6%95%B0"><span class="toc-text">front()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-%E8%8E%B7%E5%8F%96%E9%A6%96%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88"><span class="toc-text">data()获取首地址指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E6%80%9D%E6%83%B3%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">RAII思想避免内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E7%BB%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">延续生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">resize()和内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resize%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%B0%BA%E5%AF%B8%E4%BC%9A%E5%AF%BC%E8%87%B4data%E5%A4%B1%E6%95%88"><span class="toc-text">resize到更大尺寸会导致data失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize%E5%88%B0%E6%9B%B4%E5%B0%8F%E5%B0%BA%E5%AF%B8%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4data%E5%A4%B1%E6%95%88"><span class="toc-text">resize到更小尺寸不会导致data失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capacity-%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2%E5%AE%9E%E9%99%85%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="toc-text">capacity()函数查询实际的最大容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize-%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">resize()的优化策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reserve-%E9%A2%84%E7%95%99%E4%B8%80%E5%AE%9A%E5%AE%B9%E9%87%8F%EF%BC%8C%E9%81%BF%E5%85%8D%E4%B9%8B%E5%90%8E%E9%87%8D%E5%A4%8D%E5%88%86%E9%85%8D"><span class="toc-text">reserve()预留一定容量，避免之后重复分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shrink-t0-fit-%E9%87%8A%E6%94%BE%E5%A4%9A%E4%BD%99%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-text">shrink_t0_fit()释放多余的容量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%9Amallochook"><span class="toc-text">一个小工具：mallochook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#puch-back-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">puch_back()的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9Areserve"><span class="toc-text">解决：reserve()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">clear()的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9Ashrink-to-fit"><span class="toc-text">解决：shrink_to_fit()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8"><span class="toc-text">迭代器入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">迭代器的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">迭代器结构的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%8C%87%E9%92%88-%E5%B0%BE%E6%8C%87%E9%92%88"><span class="toc-text">首指针 + 尾指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0"><span class="toc-text">模板实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">不连续内存的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%B0%BE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">首迭代器 + 尾迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%AD-%E7%9A%84%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE"><span class="toc-text">迭代器中++的前置和后置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-%E5%87%BD%E6%95%B0"><span class="toc-text">insert()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-text">头部插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5"><span class="toc-text">特定位置插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E5%80%BC"><span class="toc-text">重复插入多个相同的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">直接插入一个初始化列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AAvector"><span class="toc-text">直接插入另一个vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%AF%E6%98%AF%E6%98%AF%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据源可是是不同类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E6%8E%A5%E5%8F%97%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">构造函数也接受迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assign-%E5%87%BD%E6%95%B0"><span class="toc-text">assign()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#erase-%E5%87%BD%E6%95%B0"><span class="toc-text">erase()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-text">指定位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4"><span class="toc-text">指定区间</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/" title="全面理解STL-std::string用法指南&amp;源码刨析"><img src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全面理解STL-std::string用法指南&amp;源码刨析"/></a><div class="content"><a class="title" href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/" title="全面理解STL-std::string用法指南&amp;源码刨析">全面理解STL-std::string用法指南&amp;源码刨析</a><time datetime="2024-10-30T14:06:57.140Z" title="更新于 2024-10-30 22:06:57">2024-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/" title="WSL2快速搭建CUDA体验环境"><img src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2快速搭建CUDA体验环境"/></a><div class="content"><a class="title" href="/2024/10/29/CUDA/%E6%80%A5%E9%80%9F%E6%90%AD%E5%BB%BACUDA%E4%BD%93%E9%AA%8C%E7%8E%AF%E5%A2%83/" title="WSL2快速搭建CUDA体验环境">WSL2快速搭建CUDA体验环境</a><time datetime="2024-10-30T11:36:17.774Z" title="更新于 2024-10-30 19:36:17">2024-10-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Ming</div><div class="footer_custom_text">Hi, 欢迎你来！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1336856864" data-autoplay="autoplay" data-server="netease" data-type="song" data-fixed="true"> </div><script id="canvas_nest" defer="defer" color="97,255,145" opacity="0.7" zIndex="-1" count="88" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>