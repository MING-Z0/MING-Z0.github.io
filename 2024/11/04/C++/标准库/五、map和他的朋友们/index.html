<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>全面理解STL- std::map和它的朋友们 | MINGの部落格</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者链接：✝️小彭大典✝️数据结构与复杂度不论什么语言，容器（或者用学校里的话说：数据结构）的正确使用，能够在复杂度层面上，大幅提升性能。 C++ 中也是如此，有数组（vector），字典（map），还有上一课讲过的集合（set）。 今天我们要介绍的就是 C++ 的字典容器 map，以及 C++11 引入的另一个字典容器">
<meta property="og:type" content="article">
<meta property="og:title" content="全面理解STL- std::map和它的朋友们">
<meta property="og:url" content="https://ming-z0.github.io/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/index.html">
<meta property="og:site_name" content="MINGの部落格">
<meta property="og:description" content="！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者链接：✝️小彭大典✝️数据结构与复杂度不论什么语言，容器（或者用学校里的话说：数据结构）的正确使用，能够在复杂度层面上，大幅提升性能。 C++ 中也是如此，有数组（vector），字典（map），还有上一课讲过的集合（set）。 今天我们要介绍的就是 C++ 的字典容器 map，以及 C++11 引入的另一个字典容器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg">
<meta property="article:published_time" content="2024-11-03T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-04T12:07:14.569Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="开发语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg"><link rel="shortcut icon" href="/./img/%E5%9B%BE%E6%A0%87/favicon.png"><link rel="canonical" href="https://ming-z0.github.io/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "i5biwbw9sk");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '全面理解STL- std::map和它的朋友们',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 20:07:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分析</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VB4y137ys/"><i class="fa-fw fas fa-heart"></i><span> ROS2理论与实践</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y147hS/"><i class="fa-fw fas fa-heart"></i><span> 动手学深度学习</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://geek-logic.com/"><i class="fa-fw fas fa-heart"></i><span> Geek Logic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/parallel101/cppguidebook"><i class="fa-fw fas fa-heart"></i><span> 小彭老师C++大典</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MINGの部落格"><span class="site-name">MINGの部落格</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分析</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VB4y137ys/"><i class="fa-fw fas fa-heart"></i><span> ROS2理论与实践</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y147hS/"><i class="fa-fw fas fa-heart"></i><span> 动手学深度学习</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://geek-logic.com/"><i class="fa-fw fas fa-heart"></i><span> Geek Logic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/parallel101/cppguidebook"><i class="fa-fw fas fa-heart"></i><span> 小彭老师C++大典</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">全面理解STL- std::map和它的朋友们</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-03T16:00:00.000Z" title="发表于 2024-11-04 00:00:00">2024-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-04T12:07:14.569Z" title="更新于 2024-11-04 20:07:14">2024-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">49k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>193分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="全面理解STL- std::map和它的朋友们"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="！！本文内容搬运小彭老师现代C-大典内容，仅为个人学习备份使用，请大家支持原作者"><a href="#！！本文内容搬运小彭老师现代C-大典内容，仅为个人学习备份使用，请大家支持原作者" class="headerlink" title="！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者"></a>！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者</h2><h2 id="链接：✝️小彭大典✝️"><a href="#链接：✝️小彭大典✝️" class="headerlink" title="链接：✝️小彭大典✝️"></a>链接：<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/">✝️小彭大典✝️</a></h2><h3 id="数据结构与复杂度"><a href="#数据结构与复杂度" class="headerlink" title="数据结构与复杂度"></a>数据结构与复杂度</h3><p>不论什么语言，容器（或者用学校里的话说：数据结构）的正确使用，能够在复杂度层面上，大幅提升性能。</p>
<p>C++ 中也是如此，有数组（vector），字典（map），还有上一课讲过的集合（set）。</p>
<p>今天我们要介绍的就是 C++ 的字典容器 map，以及 C++11 引入的另一个字典容器 unordered_map，他们的区别我们最后会详细讨论。我们先学习较为简单的 map，随后学习 unordered_map 时也可以举一反三、融会贯通。</p>
<blockquote>
<p>介绍完这两个标准库自带的字典容器后，我们还将介绍一些常用的第三方库容器，例如 absl::flat_hash_map、tbb::concurrent_hash_map、google::dense_hash_map、robin_hood::unordered_map、tsl::robin_pg_map 等，需要根据应用场景选择适合的容器。</p>
</blockquote>
<p>map&#x2F;set 家族都是高效查找的专家：</p>
<ul>
<li>vector 容器用 std::find 查找：O(N)O(N)</li>
<li>map 或 set 容器用 .find 查找：O(logN)O(log⁡N)</li>
<li>unordered_map 或 unordered_set 容器用 .find 查找：O(1)+O(1)+</li>
</ul>
<p>不仅是查找，map 们还支持高效的增删改查等操作。</p>
<h2 id="map-的逻辑结构"><a href="#map-的逻辑结构" class="headerlink" title="map 的逻辑结构"></a>map 的逻辑结构</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/logicmap.png" class="" title="logicmap">

<p>特点：</p>
<ul>
<li>由一系列 <strong>键值对</strong> 组成</li>
<li>一个键只能对应一个值</li>
<li>键不得重复，值可以重复</li>
</ul>
<blockquote>
<p>std::map, std::unordered_map, absl::flat_hash_map, tbb::concurrent_hash_map 都满足“键值对”这一基本逻辑结构，只是物理实现不同。</p>
</blockquote>
<p>在编程中我们常常需要用到“映射”的关系，这就非常需要用到以 map 为首的“键值对”这类容器了。</p>
<h3 id="为什么要学习-std-map"><a href="#为什么要学习-std-map" class="headerlink" title="为什么要学习 std::map"></a>为什么要学习 std::map</h3><p>map 的具体实现可以是红黑树、AVL 树、线性哈希表、链表哈希表、跳表……不同的实现在不同操作上的复杂度不同，分别适用于不同的场景。</p>
<p>用法上几乎是差不多的，他们都有着几乎相同的接口（除了部分扩展功能）。当你觉得红黑树的 std::map 不合适时，可以轻松把对象类型就地替换为链表哈希表 std::unordered_map 或是是线性哈希表 absl::flat_hash_map，而不用对其他代码有任何更改。</p>
<p>这就是所有 map 类容器都有着相同的<strong>逻辑结构</strong>：都是一个键-值映射，不同的只是他们的<strong>物理结构</strong>而已。</p>
<p>所有的 map 实现，都会模仿提供和 std::map 一样的 API。这就是为什么虽然 std::map 实现的很低效，我们还是要学他的原因。std::map 本身并不是完美的，但却提供了一个所有第三方都会遵循的统一接口。学会了 std::map，任何第三方库的 map 类容器你都可以轻易举一反三。</p>
<blockquote>
<p>不仅是各种第三方的 map 库，比如 rapidjson 库中的 JSON 对象，也提供了类似 std::map 的 <code>find</code> 和 <code>end</code> 迭代器接口：<code>MemberFind</code> 和 <code>MemberEnd</code>，来查找一个字典的子键；几何处理库 cgal 中的“顶点查找”功能也是基于类似的迭代器接口。总之，学会 std::map 将大大有助于你看懂这类业界公认的接口规范。</p>
</blockquote>
<hr>
<h3 id="标准库中的-map-容器"><a href="#标准库中的-map-容器" class="headerlink" title="标准库中的 map 容器"></a>标准库中的 map 容器</h3><p>标准库中，map<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a> 是一个<strong>模板类</strong>，他的键类型，值类型，可以由尖括号内的参数指定，便于适应不同的用户需求。</p>
<blockquote>
<p>由于 C++ 标准库的容器大多都是模板类，提供的算法也大多是模板函数，因此 C++ 标准库常被称为标准模板库 (Standard-Template-Library, STL)。</p>
</blockquote>
<p>键类型和值类型可以是任意类型，包括基本类型，用户自定义的类，其他 STL 容器等，体现了容器的泛用性。</p>
<p>唯一的要求是：键必须支持比较，这里 map 要求的是小于运算符 <code>&lt;</code>。</p>
<ul>
<li>例如 <code>map&lt;string, int&gt;</code> 是一个键类型为 string，值类型为 int 的 map 容器。</li>
<li>例如 <code>map&lt;int, Student&gt;</code> 是一个键类型为 int，值类型为 Student 的 map 容器。</li>
<li>例如 <code>map&lt;char, vector&lt;int&gt;&gt;</code> 是一个键类型为 char，值类型为 <code>vector&lt;int&gt;</code> 的 map 容器。</li>
</ul>
<p>后面为了方便研究，以 <code>map&lt;K, V&gt;</code> 形式书写得出的结论，对于任何实际键和值类型，只需代入 K 和 V 即可。</p>
<blockquote>
<p>已知：要想使用 <code>map&lt;K, V&gt;</code>，就得满足 <code>K</code> 必须支持比较运算符 <code>&lt;</code>。</p>
<p>可得：要想使用 <code>map&lt;string, int&gt;</code>，就得满足 <code>string</code> 必须支持比较运算符 <code>&lt;</code><a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:2">2</a>。</p>
<p>已知：遍历 <code>map&lt;K, V&gt;</code> 时，是以键 <code>K</code> 部分从小到大的顺序遍历的。</p>
<p>可得：遍历 <code>map&lt;int, string&gt;</code> 时，是以键 <code>int</code> 部分从小到大的顺序遍历的。</p>
</blockquote>
<h2 id="map-的物理结构"><a href="#map-的物理结构" class="headerlink" title="map 的物理结构"></a>map 的物理结构</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/physmap.png" class="" title="physmap">

<p>map 和 set 一样，都是基于红黑树的二叉排序树，实现 O(logN)O(log⁡N) 复杂度的高效查找。</p>
<p>vector 就是因为元素没有固定的顺序，所以才需要暴力遍历查找。</p>
<p>在持续的插入和删除操作下，始终维持元素的有序性，正是 map 实现高效查找的关键所在。</p>
<h3 id="二叉排序树与二分法"><a href="#二叉排序树与二分法" class="headerlink" title="二叉排序树与二分法"></a>二叉排序树与二分法</h3><p>始终保存元素按键排序的好处是，如果需要寻找指定键值的元素，就可以采用二分法：</p>
<ol>
<li>从根节点开始查找。</li>
<li>如果当前节点的键小于要找的键，则往左子节点移动；</li>
<li>如果当前节点的键大于要找的键，则往右子节点移动；</li>
<li>如果当前节点的键等于要找的键，则该节点就是要找的节点，返回该节点。</li>
<li>如果当前节点已经是最后一层叶子节点，也没找到相等的键，则说明该键不存在。</li>
<li>把左&#x2F;右子节点设为新的当前节点，然后回到第 2 步，重复这一查找过程。</li>
</ol>
<hr>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>由于 map 的实现基于二叉排序树，map 额外有一个特点：<strong>有序</strong>。</p>
<p>map (或 set) 中的键 K 总是从小到大排列，方便进行二分查找，在 O(logN)O(log⁡N) 时间内找到对应元素。</p>
<p>每次插入新的键时，会找到适当的插入位置，使得插入后的 map 仍然有序。</p>
<blockquote>
<p>注：基于哈希散列表实现的 unordered_map (和 unordered_set)，就不具备<strong>有序</strong>这一特点。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/sortedset.png" class="" title="sortedset">

<hr>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/setvsmap.png" class="" title="setvsmap">

<p>两者的区别在于：map 在 K 之外，额外外挂了一个 V 类型。</p>
<p>map 中的 V 类型不参与排序，只按照 K 进行排序。</p>
<p>这样当用户根据 K 找到的是 K-V 对，然后可以取出 K 对应的 V。</p>
<p>这就实现了从 K 到 V 的映射。</p>
<h3 id="二叉树退化问题"><a href="#二叉树退化问题" class="headerlink" title="二叉树退化问题"></a>二叉树退化问题</h3><p>二叉排序树只解决了查找的问题，但是他并不能保证经历一通插入后的树不会“退化”。</p>
<p>如果插入的时候不小心，可能会让树的形状变得非常诡异！</p>
<p>例如，若插入数据的顺序是从小到大的，那就会一直在往右插入，清一色的一边倒，以至于几乎成了一根往右跑的链表。</p>
<p>如果插入顺序是从大到小，就变成一直往左边倒。即使插入的顺序不那么刻意，依然可能产生非常变态的形状，违背了二叉树的初衷。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/binary_tree_best_worst_cases.png" class="" title="binary_tree_best_worst_cases">

<p>这样“退化”的二叉排序树，虽然能保持有序，但二分查找时就起不到加速作用了。</p>
<p>如果要找一个中间的元素，几乎就和链表一样，需要遍历整个右枝干。</p>
<p>为了限制二叉排序树不要长成畸形，我们引入一个指标：“深度”，表示从根节点到最底层叶子节点的距离。</p>
<p>要最大化二分查找的效率，就需要二叉树的深度尽可能的低。</p>
<p>因为二分查找的次数就取决于每个叶子节点的平均深度，要尽可能减少平均需要访问的次数，就是要减少二叉树的深度。</p>
<p>也就是说要让大家都尽可能贴近根部，但我们不可能让所有叶子都最贴近根部。</p>
<p>例如右侧只有一个叶子节点，他自己是深度最低了，但代价是左边全部挤在一条链表上了！这不公平。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/binary_tree_almost_worst_case.png" class="" title="binary_tree_almost_worst_case">

<p>所以要最大化二分查找的效率，我们真正需要的是让所有叶子节点都尽可能“平等”！</p>
<h3 id="红黑树-vs-平衡树"><a href="#红黑树-vs-平衡树" class="headerlink" title="红黑树 vs 平衡树"></a>红黑树 vs 平衡树</h3><p>为了避免二叉树长成畸形，陷入一边倒的情况。我们需要在每次插入后，检查二叉树是否深度差距过大。</p>
<p>如果差的太多了，就需要进行一系列矫正操作，“劫富济贫”，把太长的枝干砍断，接在短的地方，尽可能保持所有叶子路径的深度差不多，这个“劫富济贫”的动作就是**平衡操作 (balancing)**。</p>
<p>问题是，最大能容忍叶子节点之间多大的深度差才开始矫正？针对这个问题，二叉排序树分为两派：</p>
<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>最理想的情况下，一颗含有 NN 个节点的二叉树，至少需要有 ⌈logN⌉⌈log⁡N⌉ 深度。</p>
<p>这就是平衡树（AVL），他强制保证整个树处于完美的平衡状态，每个叶子节点之间的深度差距不会超过 1（当节点数量 NN 不是 2 的整数倍时，这是不得不存在的 1 格差距）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/balanced_binary_tree.png" class="" title="balanced_binary_tree">

<ul>
<li>优点：始终保持最完美的平衡，平均复杂度和最坏复杂度最低。所以平衡树的查找性能是最好的。</li>
<li>缺点：然而始终保持完美的平衡意味着，几乎每插入一个元素（可能会突然产生深度差距超过 1 的情况），就立即需要平衡一次。平衡一次的开销是比较大的，所以平衡树的性能是插入性能是比较差的。</li>
</ul>
<p>平衡树实现平衡的方式是“旋转”，他能始终保持最低的深度差：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/avltree_right_rotate_with_grandchild.png" class="" title="avltree_right_rotate_with_grandchild">

<blockquote>
<p>这里的细节我们不会深究，那是数据结构课的内容，届时会带大家手搓平衡树和红黑树，本期只是稍微了解 map 常见的底层实现，帮助你理解为什么 map 是有序容器。</p>
</blockquote>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>而红黑树认为，我们不需要总是保持深度差距为 1 那么小，我们只需要保证最深叶子和最浅叶子的深度差不超过 2 倍即可。</p>
<p>例如最浅的一个叶子是 6 深度，另一个最深的叶子可以是 12 深度。只有当最深的叶子超过 12 深度时，红黑树才会开始主动干预平衡，避免继续畸形发展下去。</p>
<ul>
<li>缺点：树可能有一定的一边倒情况，平均复杂度稍微降低，最坏复杂度可以达到原来的 2 倍！</li>
<li>优点：因为对不平衡现象更加宽松，正常插入时基本不需要平衡，只有特别扭曲了才会下场“救急”。所以红黑树是牺牲了一部分查找性能，换取了更好的插入和删除性能。</li>
</ul>
<p>总之，如果你的用况是插入比较少，但是查询非常多，那就适合用平衡树。</p>
<p>由于换来的这部分插入和删除性能实际上比损失的查找性能多，而 map 常见的用况确实需要经常增删改查，所以现在 C++ 标准库的 map 底层都是基于红黑树实现的。</p>
<blockquote>
<p>如果你的需求是大量查找的话，完全可以考虑用查找平均复杂度低至 O(1)O(1) 的哈希表 unordered_map。</p>
<p>如果是一次性插入完毕后不会再修改，还可以用完美哈希表（frozen_map），他会为你的键值序列专门生成一个专用的哈希函数，编译期确定，且保证完全无冲突。例如你在做一种语言编译器，有很多“关键字”，比如“if”、“while”，你需要运行时频繁的查找这些关键字，而关键字有哪些在编译期是固定的，那就很适合用完美哈希。</p>
</blockquote>
<h4 id="红黑树实现平衡的秘密"><a href="#红黑树实现平衡的秘密" class="headerlink" title="红黑树实现平衡的秘密"></a>红黑树实现平衡的秘密</h4><p>红黑树是如何保证最深叶子和最浅叶子的深度差不超过 2 倍的呢？</p>
<p>他设定了这样 5 条规则：</p>
<ol>
<li>节点可以是红色或黑色的。</li>
<li>根节点总是黑色的。</li>
<li>所有叶子节点都是黑色（叶子节点就是 NULL）。</li>
<li>红色节点的两个子节点必须都是黑色的。</li>
<li>从任一节点到其所有叶子节点的路径都包含相同数量的黑色节点。</li>
</ol>
<p>看起来好像很复杂，但实际上大多是废话，有用的只是 4 和 5 这两条。</p>
<p>规则 4 翻译一下就是：不得出现相邻的红色节点（相邻指两个节点是父子关系）。这条规则还有一个隐含的信息：黑色节点可以相邻！</p>
<p>规则 5 翻译一下就是：从根节点到所有底层叶子的距离（以黑色节点数量计），必须相等。</p>
<p>因为规则 4 的存在，红色节点不可能相邻，也就是说最深的枝干只能是：红-黑-红-黑-红-黑-红-黑。</p>
<p>结合规则 5 来看，也就是说每条枝干上的黑色节点数量必须相同，因为最深的枝干是 4 个黑节点了，所以最浅的枝干至少也得有 4 个节点全是黑色的：黑-黑-黑-黑。</p>
<p>可以看到，规则 4 和规则 5 联合起来实际上就保证了：最深枝干的深度不会超过最浅枝干的 2 倍。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/Red-black_tree_example.svg.png" class="" title="Red-black_tree_example">

<p>如果超出了 2 倍，就不得不破坏红黑树的规则 4 或 5，从而触发“劫富济贫”的平衡操作，从而阻止了二叉树过于畸形化。</p>
<p>红黑树如何实现“劫富济贫”的细节我们就不再多谈了，点到为止，接下来直接进入正题：</p>
<h2 id="开始使用-map-容器"><a href="#开始使用-map-容器" class="headerlink" title="开始使用 map 容器"></a>开始使用 map 容器</h2><p>创建一个 map 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br></pre></td></tr></table></figure>

<p>一开始 map 初始是空的，如何插入一些初始数据？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;</span><br><span class="line">config[<span class="string">&quot;delay&quot;</span>] = <span class="number">211</span>;</span><br></pre></td></tr></table></figure>

<p>数据插入成功了，根据键查询对应的值？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]);</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;delay&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>查询时建议用 <code>.at(key)</code> 而不是 <code>[key]</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;delay&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<p>老生常谈的问题：map 中存 string 还是 const char *？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;    <span class="comment">// 常量区的 &quot;hello&quot;</span></span><br><span class="line"><span class="type">char</span> key[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// key 的地址在栈上</span></span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;        <span class="comment">// 栈上变量的 key = &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(m);              <span class="comment">// 两个重复的键 &quot;hello&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;hello: old, hello: <span class="keyword">new</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，任何时候都务必用 string！别用 C 语言老掉牙的 const char *，太危险了。</p>
<p>const char * 危险的原因：</p>
<ol>
<li>const char * 的 &#x3D;&#x3D; 判断的是指针的相等，两个 const char * 只要地址不同，即使实际的字符串相同，也不会被视为同一个元素（如上代码案例所示）。导致 map 里会出现重复的键，以及按键查找可能找不到等。</li>
<li>保存的是弱引用，如果你把局部的 char [] 或 string.c_str() 返回的 const char * 存入 map，等这些局部释放了，map 中的 const char * 就是一个空悬指针了，会造成 segfault。</li>
</ol>
<hr>
<p>请用安全的 string：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">string key = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>);  <span class="comment">// string 的 == 运算符是经过重载的，比较的是字符串里面的内容相等，而不是地址相等</span></span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>描述</th>
<th>C++</th>
<th>Java</th>
<th>Python</th>
</tr>
</thead>
<tbody><tr>
<td>内容相等</td>
<td><code>string(&quot;hello&quot;) == string(&quot;hello&quot;)</code></td>
<td><code>&quot;hello&quot;.equals(&quot;hello&quot;)</code></td>
<td><code>&#39;hello&#39; == &#39;hello&#39;</code></td>
</tr>
<tr>
<td>地址相等</td>
<td><code>&quot;hello&quot; == &quot;hello&quot;</code></td>
<td><code>&quot;hello&quot; == &quot;hello&quot;</code></td>
<td><code>id(&#39;hello&#39;) == id(&#39;hello&#39;)</code></td>
</tr>
</tbody></table>
<hr>
<p>如果你精通对象生命周期分析，能保证 key 指向的字符串活的比 m 久，想要避免拷贝，节省性能。</p>
<p>string 的弱引用版本：string_view，同样可以用封装了正确的 &#x3D;&#x3D; 运算符，会比较字符串内容而不是地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string_view, string_view&gt; m;</span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">string_view key = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">m[key] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="built_in">print</span>(key == <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 此处 m 是栈上变量，key 是弱引用指向全局常量区（rodata），key 比 m 活得久，没有空悬指针问题</span></span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>⚠️ string_view 属于不建议初学者使用的优化小寄巧：有手之前，非常好用。</p>
<blockquote>
<p>注：map 实际上完全没有用到 &#x3D;&#x3D;，用到的只有 &lt; 运算符，当需要判定 <code>a == b</code> 时，他会转而用 <code>!(a &lt; b || b &lt; a)</code> 来判定。</p>
</blockquote>
<blockquote>
<p>string_view 也具有正确的 <code>hash&lt;string_view&gt;</code> 特化，因此也可以用做 unordered_map 的键类型。string_view 试图和 string 表现得完全一样，区别在于他是个弱引用，不持有对象，拷贝构造函数是浅拷贝。string_view 大小只有 16 个字节，内部是一个 const char * 和 size_t，但封装了正确的 &#x3D;&#x3D;，&lt;，&gt; 和 hash。</p>
</blockquote>
<hr>
<p>C++11 新特性——花括号初始化列表，允许创建 map 时直接指定初始数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123; &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;, &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>通常我们会换行写，一行一个键值对，看起来条理更清晰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));  <span class="comment">// 985</span></span><br></pre></td></tr></table></figure>

<hr>
<p>总结花括号初始化语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt; m = &#123;</span><br><span class="line">    &#123;k1, v1&#125;,</span><br><span class="line">    &#123;k2, v2&#125;,</span><br><span class="line">    ...,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让 map 初始就具有这些数据。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>等号可以省略（这其实相当于是在调用 map 的构造函数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以先构造再赋值给 auto 变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> config = map&lt;string, <span class="type">int</span>&gt;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>都是等价的。</p>
<p>作为函数参数时，可以用花括号初始化列表就地构造一个 map 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(map&lt;string, <span class="type">int</span>&gt; config)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myfunc</span>(map&lt;string, <span class="type">int</span>&gt;&#123;               <span class="comment">// 直接创建一个 map 传入</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于 <code>myfunc</code> 函数具有唯一确定的重载，要构造的参数类型 <code>map&lt;string, int&gt;</code> 可以省略不写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myfunc</span>(&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>函数这边，通常还会加上 <code>const &amp;</code> 修饰避免不必要的拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(map&lt;string, <span class="type">int</span>&gt; <span class="type">const</span> &amp;config)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>从 vector 中批量导入键值对：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(kvs.begin(), kvs.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>与刚刚花括号初始化的写法等价，只不过是从现有的 vector 中导入。同样的写法也适用于从 array 导入。</p>
<blockquote>
<p>如果记不住这个写法，也可以自己手写 for 循环遍历 vector 逐个逐个插入 map，效果是一样的。</p>
</blockquote>
<p>冷知识，如果不是 vector 或 array，而是想从传统的 C 语言数组中导入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, <span class="type">int</span>&gt; kvs[] = &#123;  <span class="comment">// C 语言原始数组</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(kvs, kvs + <span class="number">2</span>)</span></span>;                    <span class="comment">// C++98</span></span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">config</span><span class="params">(std::begin(kvs), std::end(kvs))</span></span>;  <span class="comment">// C++17</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中 <code>std::begin</code> 和 <code>std::end</code> 为 C++17 新增函数，专门用于照顾没法有成员函数 <code>.begin()</code> 的 C 语言数组。类似的全局函数还有 <code>std::size</code> 和 <code>std::data</code> 等……他们都是既兼容 STL 容器也兼容 C 数组的。</p>
</blockquote>
<hr>
<p>重点来了：如何根据键查询相应的值？</p>
<p>很多同学都知道 map 具有 [] 运算符重载，[] 里写要查询的键就可以返回对应值，也可以用 &#x3D; 往里面赋值，和某些脚本语言一样直观易懂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;       <span class="comment">// 把 config 中键 timeout 对应值设为 985</span></span><br><span class="line"><span class="keyword">auto</span> val = config[<span class="string">&quot;timeout&quot;</span>];  <span class="comment">// 读取 config 中键 timeout 对应值</span></span><br><span class="line"><span class="built_in">print</span>(val);                    <span class="comment">// 985</span></span><br></pre></td></tr></table></figure>

<p>但其实用 [] 去<strong>读取元素</strong>是很不安全的，下面我会做实验演示这一点。</p>
<hr>
<p>沉默的 []，无言的危险：当键不存在时，会返回 0 而不会出错！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]); <span class="comment">// 985</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;tmeout&quot;</span>]);  <span class="comment">// 默默返回 0</span></span><br><span class="line"><span class="number">985</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当查询的键值不存在时，[] 会默默创建并返回 0，而不会爆出任何错误。</p>
<p>这非常危险，例如一个简简单单的拼写错误，就会导致 map 的查询默默返回 0，你还在那里找了半天摸不着头脑，根本没发现错误原来在 map 这里。</p>
<hr>
<p>爱哭爱闹的 at()，反而更讨人喜欢</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>));  <span class="comment">// 985</span></span><br><span class="line"><span class="built_in">print</span>(config.<span class="built_in">at</span>(<span class="string">&quot;tmeout&quot;</span>));   <span class="comment">// 该键不存在！响亮地出错</span></span><br><span class="line"><span class="number">985</span></span><br><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::out_of_range&#x27;</span></span><br><span class="line">  <span class="built_in">what</span>():  <span class="function">map::at</span></span><br><span class="line"><span class="function"><span class="title">Aborted</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure>

<p>有经验的老手都明白一个道理：<strong>及时奔溃</strong>比<strong>容忍错误</strong>更有利于调试。即 fail-early, fail-loudly<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a> 原则。</p>
<p>例如 JS 和 Lua 的 [] 访问越界不报错而是返回 undefined &#x2F; nil，导致实际出错的位置在好几十行之后，无法定位到真正出错的位置，这就是为什么后来发明了错误检查更严格的 TS。</p>
<p>使用 at() 可以帮助你更容易定位到错误，是好事。</p>
<hr>
<blockquote>
<p>在官方文档和各种教学课件中，都会展示一个函数的“原型”来讲解。</p>
<p>原型展现了一个函数的名称，参数类型，返回类型等信息，掌握了函数的原型就等于掌握了函数的调用方法。</p>
<p>本课程后面也会大量使用，现在来教你如何看懂成员函数的原型。</p>
</blockquote>
<p>假设要研究的类型为 <code>map&lt;K, V&gt;</code>，其中 K 和 V 是模板参数，可以替换成你具体的类型。</p>
<p>例如当我使用 <code>map&lt;string, int&gt;</code> 时，就把下面所有的 K 替换成 string，V 替换成 int。</p>
<p><code>map&lt;K, V&gt;</code> 的 [] 和 at 员函数，原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K <span class="type">const</span> &amp;k);</span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure>

<p>可见 operator[] 只有一个版本，at 居然有名字相同的两个！这样不会发生冲突吗？</p>
<p>这是利用了 C++ 的“重载”功能，重载就是同一个函数有多个不同的版本，各个版本的参数类型不同。</p>
<hr>
<p>同理，编译器也是会根据调用时你传入的参数类型，决定要调用重载的哪一个具体版本。</p>
<ul>
<li>C 语言没有重载，函数名字相同就会发生冲突，编译器会当场报错。</li>
<li>C++ 支持重载，只有当函数名字相同，参数列表也相同时，才会发生冲突。</li>
<li>返回值类型不影响重载，重载只看参数列表。</li>
</ul>
<p>菜鸟教程上对 C++ 重载的解释<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<blockquote>
<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
<p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>
</blockquote>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure>

<p>但是上面这两个 at 函数的参数类型都是 <code>K const &amp;</code>，为什么可以重载呢？</p>
<p>注意看第二个版本最后面多了一个 const 关键字，这种写法是什么意思？对其进行祛魅化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(map&lt;K, V&gt; *<span class="keyword">this</span>, K <span class="type">const</span> &amp;k)</span></span>;                   <span class="comment">// 第一个版本的 at</span></span><br><span class="line"><span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(map&lt;K, V&gt; <span class="type">const</span> *<span class="keyword">this</span>, K <span class="type">const</span> &amp;k)</span></span>;       <span class="comment">// 第二个版本的 at</span></span><br></pre></td></tr></table></figure>

<p>原来加在函数括号后面的 const，实际上是用于修饰 this 指针的！</p>
<blockquote>
<p>该写法仅供示意，并不是真的可以把 this 写成参数</p>
</blockquote>
<p>所以两个 at 的参数列表不同，不同在于传入 this 指针的类型，所以可以重载，不会冲突。</p>
<ul>
<li>当 map 对象为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; const *</code>，所以只能调用第二个版本的 at。</li>
<li>当 map 对象不为 const 时，传入的 this 指针为 <code>map&lt;K, V&gt; *</code>，两个重载都可以调用，但由于第一个重载更加符合，所以会调用第一个版本的 at。</li>
</ul>
<blockquote>
<p>有趣的是，C++23 支持了显式对象形参（deducing-this），this 也能像普通参数一样定义了！上面的代码可以写成：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">map</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function">V &amp;<span class="title">at</span><span class="params">(<span class="keyword">this</span> map &amp;self, K <span class="type">const</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数体内可以使用self代替原来的this（this将不再可用）</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="type">const</span> &amp;<span class="title">at</span><span class="params">(<span class="keyword">this</span> map <span class="type">const</span> &amp;self, K <span class="type">const</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>刚刚解释了函数重载，那么运算符重载呢？</p>
<p>因为原本 C 语言就有 [] 运算符，不过那只适用于原始指针和原始数组。而 C++ 允许也 [] 运算符支持其他用户自定义类型（比如 std::map），和 C 语言自带的相比就只有参数类型不同（一个是原始数组，一个是 std::map），所以和函数重载很相似，这就是运算符重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;key&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>会被编译器“翻译”成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="keyword">operator</span>[](<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码并非仅供示意，是可以通过编译运行的。</p>
<blockquote>
<p>operator[] 虽然看起来很复杂一个关键字加特殊符号，其实无非就是个特殊的函数名，学过 Python 的童鞋可以把他想象成 <code>__getitem__</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K <span class="type">const</span> &amp;k);</span><br></pre></td></tr></table></figure>

<p>结论：[] 运算符实际上是在调用 operator[] 函数。</p>
<blockquote>
<p>所有的所谓“运算符重载函数”实际上都是一个特殊的标识符，以<code>operator</code> + 运算符的形式，他们两个组成一个整体，你还可以试试 <code>string(&quot;hel&quot;).operator+(&quot;lo&quot;)</code>，和 <code>string(&quot;hel&quot;) + &quot;lo&quot;</code> 是等价的。</p>
</blockquote>
<hr>
<p>因为 operator[] 这个成员函数后面没有 const 修饰，因此当 map 修饰为 const 时编译会不通过<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; config = &#123;  <span class="comment">// 此处如果是带 const &amp; 修饰的函数参数也是同理</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;timeout&quot;</span>]);          <span class="comment">// 编译出错</span></span><br><span class="line">/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp: In function ‘<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>’:</span></span><br><span class="line"><span class="function">/home/bate/Codes/course/stlseries/stl_map/experiment/main.cpp:<span class="number">10</span>:<span class="number">23</span>: error: passing ‘const std::map&lt;std::__cxx11::basic_string&lt;char&gt;, int&gt;’ as ‘this’ argument discards qualifiers [-fpermissive]</span></span><br><span class="line"><span class="function">   <span class="number">10</span> | print(config[<span class="string">&quot;timeout&quot;</span>]);</span></span><br></pre></td></tr></table></figure>

<p>编译器说 discards qualifiers，意思是 map 有 const 修饰，但是 operator[] 没有。</p>
<p>这实际上就是在说：<code>map&lt;K, V&gt; const *this</code> 不能转换成 <code>map&lt;K, V&gt; *this</code>。</p>
<p>有 const 修饰的 map 作为 this 指针传入没 const 修饰的 operator[] 函数，是减少了修饰（discards qualifers）。</p>
<p>C++ 规定传参时只能增加修饰不能减少修饰：只能从 <code>map *</code> 转换到 <code>map const *</code> 而不能反之。</p>
<p>所以对着一个 const map 调用非 const 的成员函数 operator[] 就出错了，相比之下 at() 就可以在 const 修饰下编译通过。</p>
<hr>
<p>为什么 operator[] 是非 const 修饰的呢？通常来说，一个成员函数不是 const，意味着他会<strong>就地修改 this 对象</strong>。</p>
<p>其实，operator[] 发现所查询的键值不存在时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;tmeout&quot;</span>]);  <span class="comment">// 有副作用！</span></span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>, <span class="string">&quot;tmeout&quot;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>会自动创建那个不存在的键值！</strong></p>
<p>你以为你只是观察了一下 map 里的 “tmeout” 元素，却意外改变了 map 的内容，薛定谔直呼内行。</p>
<hr>
<p>为什么把 [] 设计的这么危险？</p>
<p>既然已经有更安全的 .at()，为什么还要让 [] 继续存在呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">config.<span class="built_in">at</span>(<span class="string">&quot;timeout&quot;</span>) = <span class="number">985</span>;  <span class="comment">// 键值不存在，报错！</span></span><br><span class="line">config[<span class="string">&quot;timeout&quot;</span>] = <span class="number">985</span>;     <span class="comment">// 成功创建并写入 985</span></span><br></pre></td></tr></table></figure>

<p>由上可见，当我们写入一个本不存在的键值的时候，恰恰需要 [] 的“自动创建”这一特性，这是 at() 所不具有的。</p>
<p>总结：读取时应该用 at() 更安全，写入时才需要用带有自动创建功能的 []。</p>
<blockquote>
<p>许多第三方库，例如 jsoncpp，他们的字典类型也使用类似的接口，at() 负责读，[] 负责写，分工明确！</p>
</blockquote>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>-<br>  读取元素时，统一用 at()</p>
<ul>
<li>写入元素时，统一用 []</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = val;</span><br></pre></td></tr></table></figure>

<p>为什么其他语言比如 Python，只有一个 [] 就行了呢？而 C++ 需要两个？</p>
<ul>
<li>因为 Python 会检测 [] 位于等号左侧还是右侧，根据情况分别调用 <code>__getitem__</code> 或者 <code>__setitem__</code>。</li>
<li>C++ 编译器没有这个特殊检测，也检测不了，因为 C++ 的 [] 只是返回了个引用，并不知道 [] 函数返回以后，你是拿这个引用写入还是读取。为了保险起见他默认你是写入，所以先帮你创建了元素，返回这个元素的引用，让你写入。</li>
<li>而 Python 的引用是不能用 &#x3D; 覆盖原值的，那样只会让变量指向新的引用，只能用 .func() 引用成员函数或者 +&#x3D; 才能就地修改原变量，这是 Python 这类脚本语言和 C++ 最本质的不同。</li>
<li>总而言之，我们用 C++ 的 map 读取元素时，需要显式地用 at() 告诉编译器我是打算读取。</li>
</ul>
<hr>
<p>[] 找不到就返回个“默认值”，其实也是很多语言的传统异能了，只有刚好 Python 比较对初学者友好，会自动判断你的 [] 是读取还是写入，如果是读取，当找不到键值时能友善的给你报错。</p>
<table>
<thead>
<tr>
<th>语言及其关联容器名</th>
<th>C++ map</th>
<th>Python dict</th>
<th>Lua table</th>
<th>JS HashMap</th>
<th>Java HashMap</th>
</tr>
</thead>
<tbody><tr>
<td>找不到键时的行为</td>
<td>默默返回 0</td>
<td>报错 KeyError</td>
<td>默默返回 nil</td>
<td>默默返回 undefined</td>
<td>.get()，默默返回 null</td>
</tr>
</tbody></table>
<p>其中 C++ 的 [] 最为恶劣，因为古代 C++ 中并没有一个 null 或 nil 之类的额外特殊常量。</p>
<p>[] 返回的必须是个具体的类型，由于 [] 不能报错，值的类型又千变万化，<code>map&lt;K, V&gt;</code> 的 [] 只能返回“V 类型默认构造函数创建的值”：对于 int 而言是 0，对于 string 而言是 “”（空字符串）。</p>
<blockquote>
<p>也正因如此，如果一个 <code>map&lt;K, V&gt;</code> 中的 V 类型没有默认构造函数，就无法使用 [] 了。看似美好的 [] 只是骗骗小朋友的面子工程，模棱两可，充满危险。高手都使用更专业的写入函数：insert 或 insert_or_assign 代替。这两个函数不需要默认构造函数，还更高效一些，稍后会详细介绍。</p>
</blockquote>
<hr>
<p>at 与 [] 实战演练</p>
<p>我们现在的甲方是一个学校的大老板，他希望让我们管理学生信息，因此需要建立一个映射表，能够快速通过学生名字查询到相应的学生信息。思来想去 C++ 标准库中的 map 容器最合适。决定设计如下：</p>
<ul>
<li>键为学生的名字，string 类型。</li>
<li>值为一个自定义结构体，Student 类型，里面存放各种学生信息。</li>
</ul>
<p>然后自定义一下 Student 结构体，现在把除了名字以外的学生信息都塞到这个结构体里。</p>
<p>创建 <code>map&lt;string, Student&gt;</code> 对象，变量名为 <code>stus</code>，这个 map 就是甲方要求的学生表，成功交差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;             <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> age;            <span class="comment">// 年龄</span></span><br><span class="line">    string sex;         <span class="comment">// 性别</span></span><br><span class="line">    <span class="type">int</span> money;          <span class="comment">// 存款</span></span><br><span class="line">    set&lt;string&gt; skills; <span class="comment">// 技能</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, Student&gt; stus;</span><br></pre></td></tr></table></figure>

<hr>
<p>现在让我们用 <code>[]</code> 大法插入他的个人信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stus[<span class="string">&quot;彭于斌&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;相依&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;樱花粉蜜糖&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;Sputnik02&quot;</span>] = Student&#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 C++11 允许省略花括号前的类型不写，所以 Student 可以省略，简写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stus[<span class="string">&quot;彭于斌&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;相依&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;樱花粉蜜糖&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;;</span><br><span class="line">stus[<span class="string">&quot;Sputnik02&quot;</span>] = &#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>又由于 map 支持在初始化时就指定所有元素，我们直接写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Student&gt; stus = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">22</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">1000</span>, &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;相依&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000</span>, &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;樱花粉蜜糖&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">20</span>, <span class="string">&quot;女&quot;</span>, <span class="number">3000</span>, &#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;CUDA&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Sputnik02&quot;</span>, &#123;<span class="number">20220301</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>, <span class="number">4000</span>, &#123;<span class="string">&quot;C++&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>现在甲方要求添加一个“培训”函数，用于他们的 C++ 培训课。</p>
<p>培训函数的参数为字符串，表示要消费学生的名字。如果该名字学生不存在，则应该及时报错。</p>
<p>每次培训需要消费 2650 元，消费成功后，往技能 skills 集合中加入 “C++”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 这是在栈上拷贝了一份完整的 Student 对象</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这样写是不对的！</p>
<p><code>stus.at(stuName)</code> 返回的是一个引用 <code>Student &amp;</code> 指向 map 中的学生对象。但是等号左侧，却是个不带任何修饰的 <code>auto</code>，他会被推导为 <code>Student</code>。如何从一个引用 <code>Student &amp;</code> 转换为具体的 <code>Student</code>？找不到 <code>Student(Student &amp;)</code>，但是找到了最接近的 <code>Student(Student const &amp;)</code> 函数（这是编译器自动生成的拷贝构造函数），因此我们拷贝了一份 map 中的学生对象，到栈上的 stu 变量，之后不论如何修改，修改的都是这个栈上对象，而不会对 map 中的学生对象产生任何影响。</p>
<p>结论：把引用保存到普通变量中，则引用会退化，造成深拷贝！不仅影响性能，还影响功能！stu 已经是一个独立的 Student 对象，对 stu 的修改已经不会影响到 stus.at(stuName) 指向的那个 Student 对象了。</p>
<p>此时你对这个普通变量的所有修改，都不会同步到 map 中的那个 Student 中去！</p>
<hr>
<p>我们现在对相依童鞋进行 C++ 培训：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PeiXunCpp</span>(<span class="string">&quot;相依&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(stus.<span class="built_in">at</span>(<span class="string">&quot;相依&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>结果发现他的存款一分没少，也没学会 C++：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">id:</span> <span class="number">20220302</span>, <span class="attr">age:</span> <span class="number">21</span>, <span class="attr">sex:</span> <span class="string">&quot;男&quot;</span>, <span class="attr">money:</span> <span class="number">2000</span>, <span class="attr">skills:</span> &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>看来我们的修改没有在 map 中生效？原来是因为我们在 PeiXunCpp 函数里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 在栈上拷贝了一份完整的 Student 对象</span></span><br></pre></td></tr></table></figure>

<p>一不小心就用了“克隆人”技术！从学生表里的“相依1号”，克隆了一份放到栈上的“相依2号”！</p>
<p>然后我们扣了这个临时克隆人“相依2号”的钱，并给他培训 C++ 技术。</p>
<p>然而我们培训的是栈上的临时变量“相依2号”，克隆前的“相依1号”并没有受到培训，也没有扣钱。</p>
<p>然后呢？残忍的事情发生了！在一通操作培训完“相依2号”后，我们把他送上断头台——析构了！</p>
<p>而这一切“相依1号”完全不知情，他只知道有人喊他做克隆，然后就回家玩 Java 去了，并没有培训 C++ 的记忆。</p>
<hr>
<p>要防止引用退化成普通变量，需要把变量类型也改成引用！这种是浅拷贝，stu 和 stus.at(stuName) 指向的仍然是同一个 Student 对象。用 <code>auto</code> 捕获的话，改成 <code>auto &amp;</code> 就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 在栈上创建一个指向原 Student 对象的引用</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;id: <span class="number">20220302</span>, age: <span class="number">21</span>, sex: <span class="string">&quot;男&quot;</span>, money: <span class="number">-650</span>, skills: &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>终于，正版“相依1号”本体鞋废了 C++！</p>
<p>之后如果再从“相依1号”身上克隆，克隆出来的“相依n号”也都会具有培训过 C++ 的记忆了。</p>
<p>引用相当于身份证，我们复印了“相依”的身份证，身份证不仅复印起来比克隆一个大活人容易（拷贝开销）从而提升性能，而且通过身份证可以找到本人，对身份证的修改会被编译器自动改为对本人的修改，例如通过“相依”的身份证在银行开卡等，银行要的是身份证，不是克隆人哦。</p>
<hr>
<p>引用是一个烫手的香香面包，普通变量就像一个臭臭的答辩马桶，把面包放到马桶（auto）里，面包就臭掉，腐烂掉，不能吃了！要让面包转移阵地了以后依然好吃，需要放到保鲜盒（auto &amp;）里。</p>
<p>这就是 C++ 的 decay（中文刚好是“退化”、“变质”的意思）规则。</p>
<p>以下都是“香香面包”，放进马桶里会变质：</p>
<ul>
<li><code>T &amp;</code> 会变质成 <code>T</code>（引用变质成普通变量）</li>
<li><code>T []</code> 会变质成 <code>T *</code>（数组变质成首地址指针）</li>
<li><code>T ()</code> 会变质成 <code>T (*)()</code>（函数变质成函数指针）</li>
</ul>
<p>在函数的参数中、函数的返回值中、auto 捕获的变量中，放入这些“香香面包”都会发生变质！</p>
<p>如何避免变质？那就不要用马桶（普通变量）装面包呗！用保鲜盒（引用变量）装！</p>
<ul>
<li>避免引用 <code>T &amp;t</code> 变质，就得把函数参数类型改成引用，或者用 <code>auto &amp;</code>，<code>auto const &amp;</code> 捕获才行。</li>
<li>避免原生数组 <code>T t[N]</code> 变质，也可以改成引用 <code>T (&amp;t)[N]</code>，但比较繁琐，不如直接改用 C++11 封装的安全静态数组 <code>array&lt;T, N&gt;</code> 或 C++98 就有的安全动态数组 <code>vector&lt;T&gt;</code>。</li>
<li>避免函数 <code>T f()</code> 变质，可以 <code>T (&amp;f)()</code>，但繁琐，不如直接改用 C++11 的函数对象 <code>function&lt;T()&gt;</code>。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/autodecays.png" class="" title="autodecays">

<hr>
<h3 id="C-语言的退化规则真是害人不浅"><a href="#C-语言的退化规则真是害人不浅" class="headerlink" title="C 语言的退化规则真是害人不浅"></a>C 语言的退化规则真是害人不浅</h3><p>题外话：邪恶的退化规则造成空悬指针的案例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> <span class="type">arr_t</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">arr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> ret;</span><br><span class="line">    <span class="built_in">memcpy</span>(ret, val, <span class="built_in">sizeof</span>(<span class="type">arr_t</span>));  <span class="comment">// 对 val 做一些运算, 把计算结果保存到 ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// double [10] 自动变质成 double *</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> val = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">func</span>(val);             <span class="comment">// 此处 auto 会被推导为 double *</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">span</span>(ret, ret + <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure>

<p>修复方法：别再用 C 语言的煞笔原始人数组了！用 C++ 封装好的 array，无隐患</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>, 10&gt; <span class="type">arr_t</span>;  <span class="comment">// 如需动态长度，改用 vector 亦可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">arr_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> ret;</span><br><span class="line">    ret = val;  <span class="comment">// 对 val 做一些运算, 把计算结果保存到 ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">arr_t</span> val = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">func</span>(val);</span><br><span class="line">    <span class="built_in">print</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你还是学不会怎么保留香香引用的话，土办法：也可以在修改后再次用 [] 写回学生表。这样学生表里不会 C++ 的“相依1号”就会被我们栈上培训过 C++ 的“相依1号”覆盖，现在学生表里的也是有 C++ 技能的“相依”辣！只不过需要翻来覆去克隆了好几次比较低效而已，至少能用了，建议只有学不懂引用的童鞋再用这种保底写法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PeiXunCpp</span><span class="params">(string stuName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> stu = stus.<span class="built_in">at</span>(stuName);  <span class="comment">// 克隆了一份“相依2号”</span></span><br><span class="line">    stu.money -= <span class="number">2650</span>;</span><br><span class="line">    stu.skills.<span class="built_in">insert</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    stus[stuName] = stu;          <span class="comment">// “相依2号”夺舍，把“相依1号”给覆盖掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要根据学号进行查找呢？那就以学号为键，然后把学生姓名放到 Student 结构体中。</p>
<p>如果同时有根据学号进行查找和根据姓名查找两种需求呢？</p>
<p>同时高效地根据多个键进行查找，甚至指定各种条件，比如查询所有会 C++ 的学生等，这可不是 map 能搞定的，或者说能搞定但不高效（最后往往只能暴力遍历查找，时间复杂度太高）。这是个专门的研究领域，称为：关系数据库。</p>
<p>关系数据库的实现有 MySQL，SQLite，MongoDB 等。C++ 等编程语言只需调用他们提供的 API 即可，不必自己手动实现这些复杂的查找和插入算法。</p>
<p>这就是为什么专业的“学生管理系统”都会用关系数据库，而不是自己手动维护一个 map。关系数据库底层的数据结构更复杂，但经过高度封装，效率更高，提供的功能也更全面，用起来也比较无感。何况 map 存在内存中，电脑一关机，学生数据就没了！而数据库可以把数据持久化到磁盘中，相当于在磁盘里构建出了一颗查找树，关机后数据依然保持。</p>
<p>查询 map 中元素的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>m.size()</code> 获得的 map 大小，或者说其中元素的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 0</span></span><br><span class="line">m[<span class="string">&quot;fuck&quot;</span>] = <span class="number">985</span>;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 1</span></span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = <span class="number">211</span>;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">size</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<hr>
<p>应用举例：给每个键一个独一无二的计数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&quot;fuck&quot;</span>] = m.<span class="built_in">size</span>();</span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = m.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要 C++17 以上的版本，才能保证等号右边的 <code>m.size()</code> 先于 <code>m[&quot;fuck&quot;]</code> 求值。C++14 中上面这段代码行为未定义，需要改用 <code>m.insert(&#123;&quot;fuck&quot;, m.size()&#125;)</code> 的写法（函数参数总是优先于函数求值，这保证 <code>m.size()</code> 先求值，然后才发生元素插入）。</p>
</blockquote>
<hr>
<p>判断一个键是否存在：count 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>count 返回容器中键和参数 k 相等的元素个数，类型为 size_t（无符号 64 位整数）。</p>
<p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p>
<p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p>
<hr>
<p>因此可以直接通过 count 的返回值是否为 0 判断一个键在 map 中是否存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">count</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在fuck，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到fuck&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">count</span>(<span class="string">&quot;dick&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在dick，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;suck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到dick&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">存在fuck，其值为 <span class="string">&quot;rust&quot;</span></span><br><span class="line">找不到dick</span><br></pre></td></tr></table></figure>

<p>C++20 中建议改用返回类型为 <code>bool</code> 的 <code>contains</code> 函数，函数名和类型更加一目了然，但实际效果和 <code>count</code> 是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">contains</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存在fuck，其值为&quot;</span>, msg.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到fuck&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="你知道吗？-的妙用"><a href="#你知道吗？-的妙用" class="headerlink" title="你知道吗？[] 的妙用"></a>你知道吗？[] 的妙用</h2><p>除了写入元素需要用 [] 以外，还有一些案例中合理运用 [] 会非常的方便。</p>
<p>[] 的效果：当所查询的键值不存在时，会调用默认构造函数创建一个元素<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>。</p>
<ul>
<li>对于 int, float 等数值类型而言，默认值是 0。</li>
<li>对于指针（包括智能指针）而言，默认值是 nullptr。</li>
<li>对于 string 而言，默认值是空字符串 “”。</li>
<li>对于 vector 而言，默认值是空数组 {}。</li>
<li>对于自定义类而言，会调用你写的默认构造函数，如果没有，则每个成员都取默认值。</li>
</ul>
<h3 id="妙用举例：出现次数统计"><a href="#妙用举例：出现次数统计" class="headerlink" title="[] 妙用举例：出现次数统计"></a>[] 妙用举例：出现次数统计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; input = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    counter[key]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(counter);</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="number">2</span>, <span class="string">&quot;world&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>活用 [] 自动创建 0 元素的特性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    counter[key]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>古板的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;key: input) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!counter.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">        counter[key] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        counter[key] = counter.<span class="built_in">at</span>(key) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="妙用举例：归类"><a href="#妙用举例：归类" class="headerlink" title="[] 妙用举例：归类"></a>[] 妙用举例：归类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; input = &#123;<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;weak&quot;</span>, <span class="string">&quot;strong&quot;</span>&#125;;</span><br><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(categories);</span><br><span class="line">&#123;<span class="string">&#x27;h&#x27;</span>: &#123;<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;, <span class="string">&#x27;w&#x27;</span>: &#123;<span class="string">&quot;world&quot;</span>, <span class="string">&quot;weak&quot;</span>&#125;, <span class="string">&#x27;s&#x27;</span>: &#123;<span class="string">&quot;strong&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><p>活用 [] 自动创建”默认值”元素的特性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(categories);</span><br></pre></td></tr></table></figure>

<p>古板的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, vector&lt;string&gt;&gt; categories;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;str: input) &#123;</span><br><span class="line">    <span class="type">char</span> key = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!categories.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">        categories[key] = &#123;str&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        categories[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/v2-f2560f634b1e09f81522f29f363827f7_720w.jpg" class="" title="Elegence">

<h3 id="妙用举例：线程局部变量"><a href="#妙用举例：线程局部变量" class="headerlink" title="[] 妙用举例：线程局部变量"></a>[] 妙用举例：线程局部变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">concurrent_map&lt;std::thread::id, Data&gt; tls;</span><br><span class="line"><span class="built_in">parallel_for</span>([] &#123;</span><br><span class="line">    Data &amp;data = tls[std::this_thread::<span class="built_in">get_id</span>()];</span><br><span class="line">    ...;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不过 <code>thread_local</code> 关键字，可以取代。</p>
<h2 id="为什么需要反向查找表"><a href="#为什么需要反向查找表" class="headerlink" title="为什么需要反向查找表"></a>为什么需要反向查找表</h2><p>反面典型：查找特定元素在 vector 中的位置（下标）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">array_find</span><span class="params">(vector&lt;string&gt; <span class="type">const</span> &amp;arr, string <span class="type">const</span> &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;fucker&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello在数组中的下标是：&quot;</span>, <span class="built_in">array_find</span>(arr, <span class="string">&quot;fucker&quot;</span>));    <span class="comment">// O(N) 低效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nice在数组中的下标是：&quot;</span>, <span class="built_in">array_find</span>(arr, <span class="string">&quot;nice&quot;</span>));       <span class="comment">// O(N) 低效</span></span><br></pre></td></tr></table></figure>

<p>每次调用 <code>array_find</code>，都需要 O(N)O(N) 复杂度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fucker在数组中的下标是：0</span><br><span class="line"><span class="built_in">nice</span>在数组中的下标是：2</span><br></pre></td></tr></table></figure>

<p>如果查询 N 次，则复杂度就是 O(N2)O(N2)。</p>
<blockquote>
<p>注：假设 vector 中不存在重复的元素</p>
</blockquote>
<h3 id="map-构建下标查找表"><a href="#map-构建下标查找表" class="headerlink" title="map 构建下标查找表"></a>map 构建下标查找表</h3><p>正确做法：构建 vector 的反向查找表，以后查找更高效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;fucker&quot;</span>&#125;;</span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; arrinv;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;                <span class="comment">// O(N) 一次性受苦</span></span><br><span class="line">    arrinv[arr[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;反向查找表构建成功：&quot;</span>, arrinv);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fucker在数组中的下标是：&quot;</span>, arrinv.<span class="built_in">at</span>(<span class="string">&quot;fucker&quot;</span>));  <span class="comment">// O(log N) 高效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nice在数组中的下标是：&quot;</span>, arrinv.<span class="built_in">at</span>(<span class="string">&quot;nice&quot;</span>));      <span class="comment">// O(log N) 高效</span></span><br></pre></td></tr></table></figure>

<p>只有第一次构造反向查找表时，需要 O(N)O(N) 复杂度。</p>
<p>以后每次调用 <code>map.at</code>，只需要 O(logN)O(log⁡N) 复杂度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反向查找表构建成功：&#123;<span class="string">&quot;day&quot;</span>: 3, <span class="string">&quot;fucker&quot;</span>, 4, <span class="string">&quot;hello&quot;</span>: 0, <span class="string">&quot;nice&quot;</span>: 2, <span class="string">&quot;world&quot;</span>: 1&#125;</span><br><span class="line">fucker在数组中的下标是：4</span><br><span class="line"><span class="built_in">nice</span>在数组中的下标是：2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>轶事：在数据库中，这种反向查找表被称为“倒序索引”</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv[arr[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提前构造好查找表 O(N)O(N)，以后每次查找只需要 O(logN)O(log⁡N) 复杂度就行。</p>
<ul>
<li>（正向查找）已知下标 i，求元素 v：<code>v = arr[i]</code></li>
<li>（反向查找）已知元素 v，求下标 i：<code>i = arrinv[v]</code></li>
</ul>
<p>如果查询 N 次，则复杂度就是 O(NlogN)O(Nlog⁡N)，比优化前高效。</p>
<blockquote>
<p>只有当 vector 更新时，才需要重新构建 map。如果 vector 的删除采用 back-swap-erase（见 <a target="_blank" rel="noopener" href="https://142857.red/book/cpp_tricks/">C++ 小妙招</a>），那么无需完全重构 map，只需更新 swap 的两个元素即可，总复杂度 O(logN)O(log⁡N)，这样就实现了一个 O(logN)O(log⁡N) 的有下标又能快速查找数组，兼具 map 和 vector 的优势。在之后的数据结构进阶课中我们会详细介绍此类复合数据结构。</p>
</blockquote>
<h3 id="map-构建另一个-map-的反向查找表"><a href="#map-构建另一个-map-的反向查找表" class="headerlink" title="map 构建另一个 map 的反向查找表"></a>map 构建另一个 map 的反向查找表</h3><p>map 只能通过值映射到键，能不能反过来通过键查找值？</p>
<p>案例：构建另一个 map 的反向查找表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; tab = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, string&gt; tabinv;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: tab) &#123;</span><br><span class="line">    tabinv[v] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(tabinv);</span><br></pre></td></tr></table></figure>

<p>效果就是，键变值，值变键，反一反，两个 map 互为逆运算：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;rust&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fuck&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：要求 tab 中不能存在重复的值，键和值必须是一一对应关系，才能用这种方式构建双向查找表。否则一个值可能对应到两个键，反向表必须是 <code>map&lt;string, vector&lt;string&gt;&gt;</code> 了。</p>
</blockquote>
<hr>
<h2 id="元编程查询成员类型：value-type"><a href="#元编程查询成员类型：value-type" class="headerlink" title="元编程查询成员类型：value_type"></a>元编程查询成员类型：<code>value_type</code></h2><p>STL 容器的元素类型都可以通过成员 <code>value_type</code> 查询，常用于泛型编程（又称元编程）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::value_type      <span class="comment">// int</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::value_type   <span class="comment">// int</span></span><br><span class="line">string::value_type        <span class="comment">// char</span></span><br></pre></td></tr></table></figure>

<p>此外还有引用类型 <code>reference</code>，迭代器类型 <code>iterator</code>，常迭代器类型 <code>const_iterator</code> 等。</p>
<p>曾经在 C++98 中很常用，不过自从 C++11 有了 auto 和 decltype 以后，就不怎么用了，反正能自动推导返回类型。</p>
<p>C++23:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;elem: arr) &#123;</span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++17:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;elem: arr) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++11:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++98:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typename-修饰"><a href="#typename-修饰" class="headerlink" title="typename 修饰"></a>typename 修饰</h3><p>当容器有至少一个不确定的类型 T 作为模板参数时，就需要前面加上 <code>typename</code> 修饰了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::value_type;               <span class="comment">// 没有不定类型，不需要</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;T&gt;::value_type;        <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;set&lt;T&gt;&gt;::value_type;   <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, T&gt;::value_type;   <span class="comment">// 包含有 T 是不定类型</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;K, T&gt;::value_type;     <span class="comment">// 包含有 K、T 是不定类型</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::value_type;       <span class="comment">// 没有不定类型，不需要</span></span><br></pre></td></tr></table></figure>

<p>如果你搞不清楚，始终加 <code>typename</code> 就行了，反正加多肯定不会有错。你就认为：这就是一个平时可以省略，偶尔不能省略的东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> set&lt;<span class="type">int</span>&gt;::value_type;    <span class="comment">// 可以省略，但你加了也没关系</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;T&gt;::value_type;      <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> set&lt;set&lt;T&gt;&gt;::value_type; <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, T&gt;::value_type; <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;K, T&gt;::value_type;   <span class="comment">// 不能省略</span></span><br><span class="line"><span class="keyword">typename</span> map&lt;<span class="type">int</span>, string&gt;::value_type; <span class="comment">// 可以省略，但你加了也没关系</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>含有 T 的类型表达式称为 dependent-type，根本原因是因为在不知道具体是类型表达式还是值表达式的情况下，编译器无法区分模板的 <code>&lt;</code> 和小于符号 <code>&lt;</code>，以及类型的指针 <code>*</code> 和数值乘法 <code>*</code>。默认会认为是小于符号和数值乘法，加上 <code>typename</code> 后明确前面这一串是类型表达式，才知道这是模板的 <code>&lt;</code> 和指针的 <code>*</code>。</p>
</blockquote>
<h3 id="decltype-大法好"><a href="#decltype-大法好" class="headerlink" title="decltype 大法好"></a>decltype 大法好</h3><p>也有更直观的获取 STL 容器元素类型的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arr[<span class="number">0</span>])&gt;; <span class="comment">// T = int</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>decltype</code> 必须配合 <code>std::decay_t</code> 才能用！否则会得到引用类型 <code>int &amp;</code>，后续使用中就坑到你！（因为 arr 的 [] 返回的是一个引用类型）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">using</span> T = <span class="keyword">decltype</span>(arr[<span class="number">0</span>]); <span class="comment">// T = int &amp;</span></span><br><span class="line"></span><br><span class="line">T i = <span class="number">0</span>; <span class="comment">// int &amp;i = 0; 后续使用中编译出错！</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="查询类名小工具"><a href="#查询类名小工具" class="headerlink" title="查询类名小工具"></a>查询类名小工具</h3><p>在本课程的案例代码中附带的 “cppdemangle.h”，可以实现根据指定的类型查询类型名称并打印出来。</p>
<p>跨平台，需要 C++11，支持 MSVC，Clang，GCC 三大编译器，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;());</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;std::string&gt;());</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cppdemangle</span>&lt;std::wstring::value_type&gt;());</span><br></pre></td></tr></table></figure>

<p>在我的 GCC 12.2.1 上得到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;int &amp;&amp;&quot;</span></span><br><span class="line"><span class="string">&quot;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&quot;</span></span><br><span class="line"><span class="string">&quot;wchar_t&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="map-真正的元素类型究竟是什么？"><a href="#map-真正的元素类型究竟是什么？" class="headerlink" title="map 真正的元素类型究竟是什么？"></a>map 真正的元素类型究竟是什么？</h3><p>map 具有三个成员类型<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<ul>
<li>元素类型：<code>value_type</code></li>
<li>键类型：<code>key_type</code></li>
<li>值类型：<code>mapped_type</code></li>
</ul>
<p>后面，将会一直以“元素”称呼官方的“value”，“键”称呼官方的“key”，“值”称呼官方的“mapped”</p>
<p>用 cppdemangle 做实验，看看这些成员类型具体是什么吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::value_type   <span class="comment">// pair&lt;const int, float&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::key_type     <span class="comment">// int</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;::mapped_type  <span class="comment">// float</span></span><br></pre></td></tr></table></figure>

<p>结论：<code>map&lt;K, V&gt;</code> 的元素类型是 <code>pair&lt;const K, V&gt;</code> 而不是 <code>V</code>。</p>
<hr>
<p>疑惑：<code>pair&lt;const K, V&gt;</code> 中，为什么 K 要加 const？</p>
<p>我们在 set 课中说过，set 内部采用红黑树数据结构保持有序，这样才能实现在 O(logN)O(log⁡N) 时间内高效查找。</p>
<p>键值改变的话会需要重新排序，如果只修改键值而不重新排序，会破坏有序性，导致二分查找结果错误！所以 set 只提供了不可变迭代器（const_iterator），没有可变的迭代器，不允许用户修改任何元素的值。</p>
<p>map 和 set 一样也是红黑树，不同在于：map 只有键 K 的部分会参与排序，V 是个旁观者，随便修改也没关系。</p>
<p>所以 map 有可变迭代器，只是在其值类型 value_type 中给键的部分，K，加上了 const 修饰：不允许修改 K，但可以随意修改 V。</p>
<p>如果你确实需要修改键值，那么请先取出旧值，把这个键删了，然后再以同样的值重新插入一遍到新的键。相当于重新构建了一个 <code>pair&lt;const K, V&gt;</code> 对象。</p>
<blockquote>
<p>C++17 开始也可以用更高效 <code>node_handle</code> 系列 API，避免数据发生移动，稍后介绍。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>begin() 和 end() 迭代器分别指向 map 的首个元素和最后一个元素的后一位。</p>
<p>其中 end() 迭代器指向的地址为虚空索敌，不可解引用，仅仅作为一个“标志”存在（回顾之前 vector 课）。</p>
<hr>
<ul>
<li>迭代器可以通过 <code>*it</code> 或 <code>it-&gt;</code> 解引用，获取其指向的元素。</li>
<li>由于 map 内部总是保持有序，map 的首个元素一定是键最小的元素。</li>
<li>由于 map 内部总是保持有序，map 的最后一个元素一定是键最大的元素。</li>
</ul>
<p>例如要查询成绩最好和最坏的学生，可以把成绩当做 key，学生名做 value 依次插入 map，他会帮我们排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; score = &#123;</span><br><span class="line">    &#123;<span class="number">100</span>, <span class="string">&quot;彭于斌&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">80</span>, <span class="string">&quot;樱花粉蜜糖&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;相依&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">60</span>, <span class="string">&quot;Sputnik02&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">string poorestStudent = score.<span class="built_in">begin</span>()-&gt;second;   <span class="comment">// 成绩最差学生的姓名</span></span><br><span class="line">string bestStudent = <span class="built_in">prev</span>(score.<span class="built_in">end</span>())-&gt;second;  <span class="comment">// 成绩最好学生的姓名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最低分:&quot;</span>, poorestStudent);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最高分:&quot;</span>, bestStudent);</span><br><span class="line">最低分: <span class="string">&quot;相依&quot;</span></span><br><span class="line">最高分: <span class="string">&quot;彭于斌&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：仅当确保 <code>score.size() != 0</code> 时才可以解引用，否则 begin() 和 end() 都是虚空迭代器，这时解引用会奔溃。</p>
</blockquote>
<hr>
<p>map 的遍历：古代 C++98 的迭代器大法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, it-&gt;first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要特别注意迭代器是一个指向元素的指针，不是元素本身！要用 <code>-&gt;</code> 而不是 <code>.</code>。</p>
<hr>
<p>运用 C++11 的 auto 简写一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, it-&gt;first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运用 C++17 结构化绑定（structured-binding）语法<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>直接拆开 pair 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [k, v] = *it;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>map 的遍历：现代 C++17 基于范围的循环（range-based loop）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv: m) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, kv.first);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, kv.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时运用 C++17 结构化绑定语法<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, k);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value:&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如何在遍历的过程中修改值？</p>
<p>古代：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;rust&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    it-&gt;second = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="number">986</span>, <span class="string">&quot;rust&quot;</span>: <span class="number">212</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如何在遍历的过程中修改值？</p>
<p>现代：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;rust&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="number">985</span>, <span class="string">&quot;rust&quot;</span>: <span class="number">211</span>&#125;</span><br></pre></td></tr></table></figure>

<p>没有成功修改！为什么？</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v]: m) &#123;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Range-based loop 只是个花哨语法糖，他相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [k, v] = *it;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Structured-binding 也只是个花哨语法糖，他相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = *it;</span><br><span class="line">    <span class="keyword">auto</span> k = tmp.first;</span><br><span class="line">    <span class="keyword">auto</span> v = tmp.second;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样保存下来的 v 是个栈上变量，是对原值的一份拷贝，不仅浪费性能，且对 v 的修改不会反映到原 map 中去！</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;  <span class="comment">// 解决方案是在这里加一个小小的 &amp;，让 range-based loop 捕获引用而不是拷贝</span></span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是拆除 Range-based loop 的花哨语法糖，相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[k, v] = *it;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续拆除 Structured-binding 的花哨语法糖，相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;tmp = *it;</span><br><span class="line">    <span class="keyword">auto</span> &amp;k = tmp.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;v = tmp.second;</span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样保存下来的 v 是个引用，是对原值的引用（用 Rust 的话说叫 borrowed）。不仅避免拷贝的开销节省了性能，而且对 v 的修改会实时反映到原 map 中去。</p>
<hr>
<p>总结，当需要在遍历的同时修改 map 中的值时，要用 <code>auto &amp;</code> 捕获引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;  <span class="comment">// 捕获一个引用，写入这个引用会立即作用在原值上</span></span><br><span class="line">    v = v + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使不需要修改 map 中的值时，也建议用 <code>auto const &amp;</code> 避免拷贝的开销：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: m) &#123;   <span class="comment">// 捕获只读的 const 引用，引用避免拷贝开销，const 避免不小心手滑写入</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>注：即使捕获为 <code>auto &amp;</code>，由于 map 的元素类型是 <code>pair&lt;const K, V&gt;</code> 所以 K 部分还是会捕获为 <code>K const &amp;</code>，无法写入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v]: m) &#123;</span><br><span class="line">    k = <span class="string">&quot;key&quot;</span>;    <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">    v = <span class="number">985211</span>;   <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是如果捕获为 <code>auto const &amp;</code> 就两个都不允许写入了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: m) &#123;</span><br><span class="line">    k = <span class="string">&quot;key&quot;</span>;    <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">    v = <span class="number">985211</span>;   <span class="comment">// 编译期报错：const 引用不可写入！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>m.find(key) 函数，根据指定的键 key 查找元素<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>。</p>
<ul>
<li>成功找到，则返回指向找到元素的迭代器</li>
<li>找不到，则返回 m.end()</li>
</ul>
<p>由于 STL 传统异能之 end() 虚空索敌，他不可能指向任何值，所以经常作为找不到时候缺省的返回值。</p>
<p>可以用 <code>m.find(key) != m.end()</code> 判断一个元素是否存在，等价于 <code>m.count(key) != 0</code>。</p>
<p>第二个版本的原型作用是：如果 map 本身有 const 修饰，则返回的也是 const 迭代器。</p>
<p>为的是防止你在一个 const map 里 find 了以后利用迭代器变相修改 map 里的值。</p>
<h3 id="count-和-contains-没区别"><a href="#count-和-contains-没区别" class="headerlink" title="count 和 contains 没区别"></a>count 和 contains 没区别</h3><p>实际上 count 和 contains 函数就是基于 find 实现的，性能没有区别，glibc 源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt; 201703L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Finds whether an element with the given key exists.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Key of (key, value) pairs to be located.</span></span><br><span class="line"><span class="comment">       *  @return  True if there is an element with the specified key.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function">      <span class="title">contains</span><span class="params">(<span class="type">const</span> key_type&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">find</span>(__x) != _M_t.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Kt&gt;</span></span><br><span class="line"><span class="function">      <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">      <span class="title">contains</span><span class="params">(<span class="type">const</span> _Kt&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      -&gt; <span class="title">decltype</span><span class="params">(_M_t._M_find_tr(__x), <span class="type">void</span>(), <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t._M_find_tr(__x) != _M_t.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Finds the number of elements with given key.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Key of (key, value) pairs to be located.</span></span><br><span class="line"><span class="comment">       *  @return  Number of elements with specified key.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function only makes sense for multimaps; for map the result will</span></span><br><span class="line"><span class="comment">       *  either be 0 (not present) or 1 (present).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function">size_type</span></span><br><span class="line"><span class="function">      <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; __x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">find</span>(__x) == _M_t.<span class="built_in">end</span>() ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="comment">// 以下三者等价</span></span><br><span class="line">m.<span class="built_in">contains</span>(key)</span><br><span class="line">m.<span class="built_in">count</span>(key)</span><br><span class="line">m.<span class="built_in">find</span>(key) != m.<span class="built_in">end</span>()</span><br></pre></td></tr></table></figure>

<h3 id="end-不能解引用"><a href="#end-不能解引用" class="headerlink" title="end 不能解引用"></a>end 不能解引用</h3><p>检查过不是 m.end()，以确认成功找到后，就可以通过 * 运算符解引用获取迭代器指向的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);  <span class="comment">// 寻找 K 为 &quot;fuck&quot; 的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> kv = *it;     <span class="comment">// 解引用得到 K-V 对</span></span><br><span class="line">    <span class="built_in">print</span>(kv);         <span class="comment">// &#123;&quot;fuck&quot;, 985&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(kv.first);   <span class="comment">// &quot;fuck&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(kv.second);  <span class="comment">// 985</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到 fuck！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-的好处"><a href="#find-的好处" class="headerlink" title="find 的好处"></a>find 的好处</h3><p>find 的高效在于，可以把两次查询合并成一次。</p>
<p>保底写法：开销 2logN2log⁡N</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.<span class="built_in">count</span>(<span class="string">&quot;key&quot;</span>)) &#123;    <span class="comment">// 第一次查询，只包含&quot;是否找到&quot;的信息</span></span><br><span class="line">    <span class="built_in">print</span>(m.<span class="built_in">at</span>(<span class="string">&quot;key&quot;</span>));  <span class="comment">// 第二次查询，只包含&quot;找到了什么&quot;的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高效写法：开销 logNlog⁡N</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 一次性查询</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;     <span class="comment">// 查询的结果，既包含&quot;是否找到&quot;的信息</span></span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);   <span class="comment">// 也包含&quot;找到了什么&quot;的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-17-语法糖"><a href="#C-17-语法糖" class="headerlink" title="C++17 语法糖"></a>C++17 语法糖</h4><p>C++17 的 if-auto 语法糖如何简化 find 的迭代器判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key2&quot;</span>);  <span class="comment">// 编译器报错：变量 it 重复定义！</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然删去前面的 auto 可以解决问题，但是如果这里是不同类型的 map 就尬了，得另外想一个变量名。</p>
<p>而 C++17 的 if-auto 语法糖捕获的 it 是限制在当前 if 作用域的，不会跑出去和别人发生冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>); it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key2&quot;</span>); it != m.<span class="built_in">end</span>()) &#123;  <span class="comment">// 这个变量 it 是局域的，不会和上一个局域的 it 产生名字冲突</span></span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>我给 C++ 标准委员会提一个建议，能不能给迭代器加一个 <code>operator bool</code> 代替烦人的 <code>!= m.end()</code>？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    _RbTreeNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(iterator <span class="type">const</span> &amp;other) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == other.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那样的话就可以直接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 if-auto 省略分号后面的条件时，默认就是 <code>if (auto it = m.find(&quot;key&quot;); (bool)it)</code></p>
<h3 id="对-map-而言，迭代器解引用得到的是-pair"><a href="#对-map-而言，迭代器解引用得到的是-pair" class="headerlink" title="对 map 而言，迭代器解引用得到的是 pair"></a>对 map 而言，迭代器解引用得到的是 pair</h3><p>注意 <code>*it</code> 解引用得到的是 <code>pair&lt;const K, V&gt;</code> 类型的键值对，需要 <code>(*it).second</code> 才能获取单独的值 V。</p>
<p>好在 C 语言就有 <code>-&gt;</code> 运算符作为语法糖，我们可以简写成 <code>it-&gt;second</code>，与 <code>(*it).second</code> 等价。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);   <span class="comment">// 寻找 K 为 &quot;fuck&quot; 的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;second);      <span class="comment">// 迭代器有效，可以直接获得值部分 985</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到 fuck！&quot;</span>);  <span class="comment">// 这个分支里不得用 * 和 -&gt; 运算符解引用 it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下我们查询只需要获取值 V 的部分就行了，直接 <code>it-&gt;second</code> 就可以了✅</p>
<blockquote>
<p>注意：find 找不到键时，会返回 <code>m.end()</code>，这是个无效迭代器，只作为标识符使用（类比 Python 中的 find 有时会返回 -1）。</p>
<p>没有确认 <code>it != m.end()</code> 前，不可以访问 <code>it-&gt;second</code>！那相当于解引用一个空指针，会造成 segfault（更专业一点说是 UB）。</p>
<p>记住，一定要在 <code>it != m.end()</code> 的分支里才能访问 <code>it-&gt;second</code> 哦！你得先检查过饭碗里没有老鼠💩之后，才能安心吃饭！</p>
<p>如果你想让老妈（标准库）自动帮你检查有没有老鼠💩，那就用会自动报错的 at（类比 Python 中的 index 找不到直接报错）。</p>
<p>之所以用 find，是因为有时饭碗里出老鼠💩，是计划的一部分！例如当有老鼠💩时你可以改吃别的零食。而 at 这个良心老妈呢？一发现老鼠💩就拖着你去警察局报案，零食（默认值）也不让你吃了。今日行程全部取消，维权（异常处理，找上层 try-catch 块）设为第一要务。</p>
</blockquote>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果 map 没有 const 修饰，则其 find 返回的 it 也是非 const 迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; cm;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::const_iterator cit = cm.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(cit-&gt;second);  <span class="comment">// OK: 可以读取</span></span><br><span class="line">cit-&gt;second = <span class="number">1</span>;     <span class="comment">// 编译期报错: 不允许写入 const 迭代器指向的值</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);   <span class="comment">// OK: 可以读取</span></span><br><span class="line">it-&gt;second = <span class="number">1</span>;      <span class="comment">// OK: 可以写入</span></span><br></pre></td></tr></table></figure>

<p><code>it-&gt;second</code> 可以写入，it 是迭代器，迭代器类似于指针，写入迭代器指向的 second 就可以修改 map 里的值部分。</p>
<p><code>it-&gt;first</code> 是键部分，由于 map 的真正元素类型是 <code>pair&lt;const K, V&gt;</code> 所以这部分无法被修改。</p>
<hr>
<p>带默认值的查询</p>
<p>众所周知，Python 中的 dict 有一个 m.get(key, defl) 的功能，效果是当 key 不存在时，返回 defl 这个默认值代替 m[key]，而 C++ 的 map 却没有，只能用一套组合拳代替：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">count</span>(key) ? m.<span class="built_in">at</span>(key) : defl</span><br></pre></td></tr></table></figure>

<p>但上面这样写是比较低效的，相当于查询了 map 两遍，at 里还额外做了一次多余的异常判断。</p>
<p>正常来说是用通用 find 去找，返回一个迭代器，然后判断是不是 end() 决定要不要采用默认值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">return</span> it != m.<span class="built_in">end</span>() ? it-&gt;second : defl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>饭碗里发现了老鼠💩？别急着报警，这也在我的预料之中：启用 B 计划，改吃 defl 这款美味零食即可！</p>
<p>如果是良心老妈 at，就直接启用 C 计划：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://142857.red/book/img/stl/planc.png" alt="Plan C"> 抛出异常然后奔溃了，虽然这很方便我们程序员调试。</p>
</blockquote>
<hr>
<p>由于自带默认值的查询这一功能实在是太常用了，为了把这个操作浓缩到一行，我建议同学们封装成函数放到自己的项目公共头文件（一般是 utils.h 之类的名称）里方便以后使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> M::mapped_type <span class="title">map_get</span></span></span><br><span class="line"><span class="function"><span class="params">( M <span class="type">const</span> &amp;m</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::key_type <span class="type">const</span> &amp;key</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::mapped_type <span class="type">const</span> &amp;defl</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> M::const_iterator it = m.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>, <span class="number">-1</span>);  <span class="comment">// 如果配置文件里不指定，则默认 timeout 为 -1</span></span><br></pre></td></tr></table></figure>

<hr>
<p>这样还不够优雅，我们还可以更优雅地运用 C++17 的函数式容器 optional：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;</span><br><span class="line"><span class="function">std::optional&lt;<span class="keyword">typename</span> M::mapped_type&gt; <span class="title">map_get</span></span></span><br><span class="line"><span class="function"><span class="params">( M <span class="type">const</span> &amp;m</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">typename</span> M::key_type <span class="type">const</span> &amp;key</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> M::const_iterator it = m.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当找不到时就返回 nullopt，找到就返回含有值的 optional。</p>
<p>调用者可以自行运用 optional 的 value_or 函数<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>指定找不到时采用的默认值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>).<span class="built_in">value_or</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>如果要实现 at 同样的找不到就自动报错功能，那就改用 value 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>).<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure>

<p>optional 具有 <code>operator bool</code> 和无异常的 <code>operator*</code>，所以也可以配合 if-auto 语法糖使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> o_val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> val = *o_val;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到了&quot;</span>, val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到时的处理方案...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> o_val = <span class="built_in">map_get</span>(config, <span class="string">&quot;timeout&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (o_val) &#123;</span><br><span class="line">    <span class="type">int</span> val = *o_val;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到了&quot;</span>, val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到时的处理方案...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上是典型的函数式编程范式 (FP)，C++20 还引入了更多这样的玩意<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:2">2</a>，等有空会专门开节课为大家一一介绍。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> even = [] (<span class="type">int</span> i) &#123; <span class="keyword">return</span> <span class="number">0</span> == i % <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> square = [] (<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">          | std::views::<span class="built_in">filter</span>(even)</span><br><span class="line">          | std::views::<span class="built_in">transform</span>(square))</span><br><span class="line">    <span class="built_in">print</span>(i);  <span class="comment">// 0 4 16</span></span><br></pre></td></tr></table></figure>

<hr>
<p>现在学习删除元素用的 erase 函数，其原型如下<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>指定键值 key，erase 会删除这个键值对应的元素。</p>
<p>返回一个整数，表示删除了多少个元素（只能是 0 或 1）。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>erase 运用举例：删除一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">msg.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>erase 的返回值和 count 一样，返回成功删除的元素个数，类型为 size_t（无符号 64 位整数）。</p>
<p>由于 map 中同一个键最多只可能有一个元素，取值只能为 0 或 1。</p>
<p>并且 size_t 可以隐式转换为 bool 类型，0 则 false，1 则 true。</p>
<hr>
<p>因此可以直接通过 erase 的返回值是否为 0 判断是否删除成功：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除fuck成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除fuck失败，键不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.<span class="built_in">erase</span>(<span class="string">&quot;dick&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除dick成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除dick失败，键不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">删除fuck成功</span><br><span class="line">删除dick失败，键不存在</span><br><span class="line">&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;  <span class="comment">// 指定键版</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>;   <span class="comment">// 已知位置版</span></span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>指定键版 erase(key) 实际上需要先调用 find(key) 找到元素位置，然后才能删除，而且还有找不到的可能性。</li>
<li>而已知位置的话（比如你已经事先用 find 找到了元素位置），可以用 erase(it) 直接用迭代器作为参数</li>
</ul>
<p>复杂度不同：</p>
<ul>
<li>指定键版 erase(key) 的时间复杂度：O(logN)O(log⁡N)。</li>
<li>已知位置版 erase(it) 的时间复杂度：O(1)+O(1)+，更高效。</li>
</ul>
<p>其中 ++ 代表这是平摊（Amortized）下来的时间复杂度。</p>
<p>这是因为即使已知位置，erase 有可能涉及树的更新，需要 O(logN)O(log⁡N) 复杂度。</p>
<p>但是大多数情况下需要的更新很少，平均下来是 O(1)O(1) 的。</p>
<p>这种情况就会用记号 O(1)+O(1)+ 来表示。</p>
<hr>
<p>erase(key) 可能是基于 erase(it) 实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(K <span class="type">const</span> &amp;key)</span> </span>&#123;  <span class="comment">// 小彭老师猜想标准库内部</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(key);  <span class="comment">// O(log N)</span></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">this</span>-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">erase</span>(it);        <span class="comment">// O(1)+</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 找到了，删除成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 找不到，没有删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// 开销大的 find(key) 会覆盖小的 erase(it)，所以 erase(key) 的总复杂度为 O(log N)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>指定位置版 erase(it) 返回的是删除元素的下一个元素位置。</p>
<p>由于 map 内部保持键从小到大升序排列，所谓的下一个就是键比当前键大一个的元素，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span> <span class="number">42</span><span class="punctuation">,</span> <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="number">985</span><span class="punctuation">,</span> <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="number">211</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>erase(find(“answer”)) 会返回指向 “hello” 的迭代器，因为 “hello” 最接近且大于 “answer”。</li>
<li>erase(find(“hello”)) 会返回指向 “world” 的迭代器，因为 “world” 最接近且大于 “hello”。</li>
<li>erase(find(“world”)) 会返回 end()，因为 “world” 已经是最大键，没有下一个。</li>
</ul>
<p>此外 erase(it) 还有性能上的优势：</p>
<ul>
<li>指定位置版 erase(it) 的复杂度是 O(1)+O(1)+</li>
<li>指定键版 erase(key) 的复杂度是 O(logN)O(log⁡N)</li>
</ul>
<p>当已知指向要删除元素的迭代器时（例如先通过 find 找到），直接指定那个迭代器比指定键参数更高效。</p>
<p>删除成绩最差的学生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score.<span class="built_in">erase</span>(score.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="一边遍历一边删除部分元素"><a href="#一边遍历一边删除部分元素" class="headerlink" title="一边遍历一边删除部分元素"></a>一边遍历一边删除部分元素</h2><p>常见需求场景：一边遍历一边删除部分元素（错误示范）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(k);  <span class="comment">// 遍历过程中删除当前元素，会导致正在遍历中的迭代器失效，奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p>引出问题：迭代器失效</p>
<ul>
<li>每当往 map 中插入新元素时，原先保存的迭代器不会失效。</li>
<li>删除 map 中的其他元素时，也不会失效。</li>
<li><strong>只有当删除的刚好是迭代器指向的那个元素时，才会失效</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m[<span class="string">&quot;dick&quot;</span>] = <span class="number">211</span>;</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;dick&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(it-&gt;second);  <span class="comment">// 没有失效，打印 985</span></span><br></pre></td></tr></table></figure>

<hr>
<p>map 比起 unordered_map 来，已经是非常稳定，随便增删改查都不会迭代器失效。</p>
<p>只有一个例外：删除的元素刚好是迭代器指向的。</p>
<p>你拿着个你朋友家的地址，结果你一发 RPG 导弹把他家炸了，还摸不着头脑“奇怪，明明就是这个地址呀”，这时确实无论如何都不能避免失效，不能怪 map。</p>
<p>而刚刚的案例中，我们删除的恰好就是当前正在遍历的迭代器正在指向的那个元素（即使你用了 range-based loop 语法糖他背后还是迭代器遍历）。</p>
<p>而当你对着一个失效的迭代器执行 <code>++it</code> 时，就产生了 segfault 错误。因为红黑树的迭代器要找到“下一个”节点，需要访问这个红黑树节点中存的 <code>next</code> 指针，而这个红黑树节点都已经删除了已经析构了已经释放内存了，里面存的 <code>next</code> 指针也已经释放，被其他系统数据覆盖，这时会访问到错误的指针——野指针。</p>
<hr>
<p>所以《好友清除计划》完整的剧情是：</p>
<p>你有好多朋友，今天你要把他们全炸了。</p>
<p>1号朋友家里有一个字条，写着2号朋友家的地址。</p>
<p>2号朋友家里有一个字条，写着3号朋友家的地址。</p>
<p>…</p>
<p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it <span class="comment">/* 进入燃烧中的1号朋友家 */</span>) &#123;</span><br><span class="line">    m.<span class="built_in">erase</span>(it);  <span class="comment">// 一发 RPG 导弹炸毁1号朋友家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>你拿着1号朋友家的地址，一发 RPG 导弹把他家炸了。然后你现在突然意识到需要2号朋友家的地址，但是1号朋友家已经被你炸了，你傻乎乎进入燃烧的1号朋友家，被火烧死了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    m.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="comment">// it 已经失效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是，先进入1号朋友家，安全取出写着2号朋友家地址的字条后，再来一发 RPG 把1号朋友家炸掉。这样才能顺利找到2号朋友家，以此类推继续拆3号……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">auto</span> next_it = it;  <span class="comment">// 先进入1号朋友的家</span></span><br><span class="line">    ++next_it;          <span class="comment">// 拿出写有2号朋友家地址的字条</span></span><br><span class="line">    m.<span class="built_in">erase</span>(it);        <span class="comment">// 再发射 RPG 导弹</span></span><br><span class="line">    it = next_it;       <span class="comment">// 前往2号朋友家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>注意到 erase 会返回删除元素的下一个元素的迭代器，也就是说这个 RPG 导弹非常智能，好像他就是专为《好友清除计划》设计的一样：他能在炸毁你朋友的房屋前，自动拿到其中的字条，并把他通过“弹射座椅”弹出来送到门外的你手上，把纸条安全送出来后，再爆炸摧毁你朋友的房屋。这样你就不用冒险进入燃烧的房屋拿字条（迭代器失效导致 segfault），也不用先劳烦您自己先进去一趟房屋拿字条了（上一页中那样提前保存 next_it）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it = m.<span class="built_in">erase</span>(it);        <span class="comment">// 这款 RPG 导弹“智能地”在摧毁你朋友的房屋同时把其中的字条拿出来了!?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只是注意这里 for 循环的步进条件 <code>++it</code> 要删掉，因为智能的 RPG 导弹 <code>it = m.erase(it)</code> 已经帮你步进了。</p>
</blockquote>
<hr>
<p>一边遍历一边删除部分元素（正解<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;  <span class="comment">// 没有 ++it</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        it = msg.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;good&quot;</span>: <span class="string">&quot;job&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>不奔溃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        it = msg.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奔溃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v] = *it;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">// 或者 msg.erase(k);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-20-更好的写法：erase-if"><a href="#C-20-更好的写法：erase-if" class="headerlink" title="C++20 更好的写法：erase_if"></a>C++20 更好的写法：erase_if</h3><p>批量删除符合条件的元素（C++20<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::<span class="built_in">erase_if</span>(msg, [&amp;] (<span class="keyword">auto</span> <span class="type">const</span> &amp;kv) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[k, v] = kv;</span><br><span class="line">    <span class="keyword">return</span> k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(msg);</span><br><span class="line">&#123;<span class="string">&quot;good&quot;</span>: <span class="string">&quot;job&quot;</span>, <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你搞不懂迭代器这些，这里我提供一个保底写法，先把键提前保存到一个 vector 中去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; keys;             <span class="comment">// vector 或者 set 都可以</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;  <span class="comment">// 先把所有键提前拷贝到临时 vector 里</span></span><br><span class="line">    keys.<span class="built_in">push_back</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;k: keys) &#123;      <span class="comment">// 遍历刚才保存的键</span></span><br><span class="line">    <span class="keyword">if</span> (k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">        msg.<span class="built_in">erase</span>(k);            <span class="comment">// 键值对已经提前深拷贝到临时 vector 里，这时删除 map 里的键不会奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小彭老师，永远的祛魅大师。</p>
</blockquote>
<hr>
<p>还是搞不懂的话，也可以新建一个 map，条件反之，把不需要删除的元素插入新 map，过滤出需要保留的元素，最后再一次性用新 map 覆盖旧 map。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; msg = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucker&quot;</span>, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fucking&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;job&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, string&gt; newmsg;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!k.<span class="built_in">starts_with</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;   <span class="comment">// 注意这里条件反了，不需要删除的才插入 newmsg</span></span><br><span class="line">        newmsg[k] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">msg = std::<span class="built_in">move</span>(newmsg);        <span class="comment">// 覆盖旧的 map，用更高效的移动赋值函数，O(1) 复杂度</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小彭老师，永远的保底大师。</p>
</blockquote>
<hr>
<p>接下来开始学习如何插入元素，map 的成员 insert 函数原型如下<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; &amp;&amp;kv)</span></span>;</span><br></pre></td></tr></table></figure>

<p>他的参数类型就是刚刚介绍的 <code>value_type</code>，也就是 <code>pair&lt;const K, V&gt;</code>。</p>
<p>pair 是一个 STL 中常见的模板类型，<code>pair&lt;K, V&gt;</code> 有两个成员变量：</p>
<ul>
<li>first：K 类型，表示要插入元素的键</li>
<li>second：V 类型，表示要插入元素的值</li>
</ul>
<p>我称之为”键值对”。</p>
<hr>
<p>试着用 insert 插入键值对：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;</span><br><span class="line">p.first = <span class="string">&quot;fuck&quot;</span>;  <span class="comment">// 键</span></span><br><span class="line">p.second = <span class="number">985</span>;    <span class="comment">// 值</span></span><br><span class="line">m.<span class="built_in">insert</span>(p);  <span class="comment">// pair&lt;string, int&gt; 可以隐式转换为 insert 参数所需的 pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;fuck&quot;</span><span class="punctuation">:</span> <span class="number">985</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>简化 insert</p>
<ol>
<li>直接使用 pair 的构造函数，初始化 first 和 second</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">insert</span>(p);</span><br></pre></td></tr></table></figure>

<ol>
<li>不用创建一个临时变量，pair 表达式直接作为 insert 函数的参数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>可以用 <code>std::make_pair</code> 这个函数，自动帮你推导模板参数类型，省略 <code>&lt;string, int&gt;</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>));  <span class="comment">// 虽然会推导为 pair&lt;const char *, int&gt; 但还是能隐式转换为 pair&lt;const string, int&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>由于 insert 函数原型已知参数类型，可以直接用 C++11 的花括号初始化列表 {…}，无需指定类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;);           <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<hr>
<p>因此，insert 的最佳用法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>insert 插入和 [] 写入的异同：</p>
<ul>
<li>同：当键 K 不存在时，insert 和 [] 都会创建键值对。</li>
<li>异：当键 K 已经存在时，insert 不会覆盖，默默离开；而 [] 会覆盖旧的值。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;);  <span class="comment">// 插入失败，默默放弃不出错</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;old&quot;</span>&#125;</span><br><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;new&quot;</span>;        <span class="comment">// 已经存在？我踏马强行覆盖！</span></span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>insert 的返回值是 <code>pair&lt;iterator, bool&gt;</code> 类型，<del>STL 的尿性：在需要一次性返回两个值时喜欢用 pair</del>。</p>
<p>这又是一个 pair 类型，其具有两个成员：</p>
<ul>
<li>first：iterator 类型，是个迭代器</li>
<li>second：bool 类型，表示插入成功与否，如果发生键冲突则为 false</li>
</ul>
<p>其中 first 这个迭代器指向的是：</p>
<ul>
<li>如果插入成功（second 为 true），指向刚刚成功插入的元素位置</li>
<li>如果插入失败（second 为 false），说明已经有相同的键 K 存在，发生了键冲突，指向已经存在的那个元素</li>
</ul>
<hr>
<p>其实 insert 返回的 first 迭代器等价于插入以后再重新用 find 找到刚刚插入的那个键，只是效率更高：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">insert</span>(&#123;k, v&#125;).first;  <span class="comment">// 高效，只需遍历一次</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;k, v&#125;);     <span class="comment">// 插入完就忘事了</span></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(k);  <span class="comment">// 重新遍历第二次，但结果一样</span></span><br></pre></td></tr></table></figure>

<p>参考 C 编程网<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>对 insert 返回值的解释：</p>
<blockquote>
<p>当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；</p>
<p>反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。</p>
</blockquote>
<hr>
<p>可以用 insert 返回的 second 判断插入多次是否成功：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>&#125;).second);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;).second);  <span class="comment">// false</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;key&quot;</span>);     <span class="comment">// 把原来的 &#123;&quot;key&quot;, &quot;old&quot;&#125; 删了</span></span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>&#125;).second);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也可以用 structured-binding 语法拆解他返回的 <code>pair&lt;iterator, bool&gt;</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">auto</span> [it, success] = counter.<span class="built_in">insert</span>(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);  <span class="comment">// 直接用</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;  <span class="comment">// 如果已经存在，则修改其值+1</span></span><br><span class="line">    it-&gt;second = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果不存在，则打印以下信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;created a new entry!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这一长串代码和之前“优雅”的计数 [] 等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter[<span class="string">&quot;key&quot;</span>]++;</span><br></pre></td></tr></table></figure>

<h3 id="insert-or-assign"><a href="#insert-or-assign" class="headerlink" title="insert_or_assign"></a>insert_or_assign</h3><p>在 C++17 中，[] 写入有了个更高效的替代品 insert_or_assign<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_or_assign</span><span class="params">(K <span class="type">const</span> &amp;k, V v)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_or_assign</span><span class="params">(K &amp;&amp;k, V v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>正如他名字的含义，“插入或者写入”：</p>
<ul>
<li>如果 K 不存在则创建（插入）</li>
<li>如果 K 已经存在则覆盖（写入）</li>
</ul>
<p>用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>);  <span class="comment">// 与 insert 不同，他不需要 &#123;...&#125;，他的参数就是两个单独的 K 和 V</span></span><br></pre></td></tr></table></figure>

<p>返回值依旧是 <code>pair&lt;iterator, bool&gt;</code>。由于这函数在键冲突时会覆盖，按理说是必定成功了，因此这个 bool 的含义从“是否插入成功”变为“是否创建了元素”，如果是创建的新元素返回true，如果覆盖了旧元素返回false。</p>
<hr>
<h4 id="insert-or-assign-的优势"><a href="#insert-or-assign-的优势" class="headerlink" title="insert_or_assign 的优势"></a>insert_or_assign 的优势</h4><p>看来 insert_or_assign 和 [] 的效果完全相同！都是在键值冲突时覆盖旧值。</p>
<p>既然 [] 已经可以做到同样的效果，为什么还要发明个 insert_or_assign 呢？</p>
<p>insert_or_assign 的优点是<strong>不需要调用默认构造函数</strong>，可以提升性能。</p>
<p>其应用场景有以下三种情况：</p>
<ul>
<li>⏱ 您特别在乎性能</li>
<li>❌ 有时 V 类型没有默认构造函数，用 [] 编译器会报错</li>
<li>🥵 强迫症发作</li>
</ul>
<p>否则用 [] 写入也是没问题的。</p>
<p>而且 insert_or_assign 能取代 [] 的岗位仅限于纯写入，之前 <code>counter[key]++</code> 这种“优雅”写法依然是需要用 [] 的。</p>
<h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>创建新键时，insert_or_assign 更高效。</p>
<h5 id=""><a href="#" class="headerlink" title="[]"></a>[]</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;new&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖旧键时，使用 [] 造成的开销：</p>
<ul>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<p>创建新键时，使用 [] 造成的开销：</p>
<ul>
<li>调用默认构造函数 <code>V()</code></li>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<h5 id="insert-or-assign-1"><a href="#insert-or-assign-1" class="headerlink" title="insert_or_assign"></a>insert_or_assign</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">m.<span class="built_in">insert_or_assign</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;new&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖旧键时，使用 insert_or_assign 造成的开销：</p>
<ul>
<li>调用移动赋值函数 <code>V &amp;operator=(V &amp;&amp;)</code></li>
</ul>
<p>创建新键时，使用 insert_or_assign 造成的开销：</p>
<ul>
<li>调用移动构造函数 <code>V(V &amp;&amp;)</code></li>
</ul>
<h4 id="那我应该用什么"><a href="#那我应该用什么" class="headerlink" title="那我应该用什么"></a>那我应该用什么</h4><p>总结，如果你有性能强迫症，并且是 C++17 标准：</p>
<ul>
<li>写入用 insert_or_assign</li>
<li>读取用 at</li>
</ul>
<p>如果没有性能强迫症，或者你的编译器不支持 C++17 标准：</p>
<ul>
<li>写入用 []</li>
<li>读取用 at</li>
</ul>
<p>最后，如果你是还原论者，只需要 find 和 insert 函数就是完备的了，别的函数都不用去记。所有 at、[]、insert_or_assign 之类的操作都可以通过 find 和 insert 的组合拳实现，例如刚刚我们自定义的 map_get。</p>
<h4 id="insert-or-assign-vs-insert：顺序问题"><a href="#insert-or-assign-vs-insert：顺序问题" class="headerlink" title="insert_or_assign vs insert：顺序问题"></a>insert_or_assign vs insert：顺序问题</h4><p>回顾之前的反向查找表，如果有重复，如何区分找第一个还是最后一个？</p>
<p>构建反向查找表，找到最后一个的下标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv.<span class="built_in">insert_or_assign</span>(arr[i], i);</span><br><span class="line">    <span class="comment">// 等价于 arrinv[arr[i]] = i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建反向查找表，找到第一个的下标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    arrinv.<span class="built_in">insert</span>(&#123;arr[i], i&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量-insert"><a href="#批量-insert" class="headerlink" title="批量 insert"></a>批量 insert</h2><p>刚刚介绍的那些 insert 一次只能插入一个元素，insert 还有一个特殊的版本，用于批量插入一系列元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIt beg, InputIt end)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>是两个迭代器 beg 和 end，组成一个区间，之间是你要插入的数据。</p>
<p>该区间可以是任何其他容器的 begin() 和 end() 迭代器——那会把该容器中所有的元素都插入到本 map 中去。</p>
<p>例如，把 vector 中的键值对批量插入 map：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);  <span class="comment">// &#123;&quot;delay&quot;: 211, &quot;timeout&quot;: 985&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="批量-insert-同样遵循不覆盖原则"><a href="#批量-insert-同样遵循不覆盖原则" class="headerlink" title="批量 insert 同样遵循不覆盖原则"></a>批量 insert 同样遵循不覆盖原则</h3><p>注：由于 insert 不覆盖的特性，如果 vector 中有重复的键，则会以键第一次出现时的值为准，之后重复出现的键会被忽视。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">666</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">233</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; kvs = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">666</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">233</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">404</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">config.<span class="built_in">insert</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(config);</span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">404</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量-insert-实现-map-合并"><a href="#批量-insert-实现-map-合并" class="headerlink" title="批量 insert 实现 map 合并"></a>批量 insert 实现 map 合并</h3><p>批量 insert 运用案例：两个 map 合并</p>
<p>这个批量 insert 输入的迭代器可以是任何容器，甚至可以是另一个 map 容器。</p>
<p>运用这一点可以实现两个 map 的并集操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m1 = &#123;  <span class="comment">// 第一个 map</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m2 = &#123;  <span class="comment">// 第二个 map</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m1.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());  <span class="comment">// 把 m2 的内容与 m1 合并，结果写回到 m1</span></span><br><span class="line"><span class="built_in">print</span>(m1);</span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注：还是由于 insert 不覆盖的特性，当遇到重复的键时（例如上面的 “timeout”），会以 m1 中的值为准。</p>
<h4 id="就地写入！"><a href="#就地写入！" class="headerlink" title="就地写入！"></a>就地写入！</h4><p>使用 <code>m1.insert(m2.begin(), m2.end())</code> 后，合并的结果会就地写入 m1。</p>
<p>如果希望合并结果放到一个新的 map 容器中而不是就地修改 m1，请先自行生成一份 m1 的深拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; m1 = &#123;  <span class="comment">// 第一个 map，修饰有 const 禁止修改</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> map&lt;string, <span class="type">int</span>&gt; m2 = &#123;  <span class="comment">// 第二个 map，修饰有 const 禁止修改</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> m12 = m1;  <span class="comment">// 生成一份 m1 的深拷贝 m12，避免 insert 就地修改 m1</span></span><br><span class="line">m12.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="批量-insert-优先保留已经有的"><a href="#批量-insert-优先保留已经有的" class="headerlink" title="批量 insert 优先保留已经有的"></a>批量 insert 优先保留已经有的</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> m12 = m1;</span><br><span class="line">m12.<span class="built_in">insert</span>(m2.<span class="built_in">begin</span>(), m2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果，键冲突时优先取 m1 的值</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚写的 m1 和 m2 合并，遇到重复时会优先采取 m1 里的值，如果希望优先采取 m2 的呢？反一反就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> m12 = m2;</span><br><span class="line">m12.<span class="built_in">insert</span>(m1.<span class="built_in">begin</span>(), m1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(m12);     <span class="comment">// m1 和 m2 的合并结果，键冲突时优先取 m2 的值</span></span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br></pre></td></tr></table></figure>

<p>要是学不会批量 insert，那手写一个 for 循环遍历 m2，然后 m1.insert_or_assign(k2, v2) 也是可以的，总之要懂得变通，动动脑，总是有保底写法的。</p>
<h4 id="其他操作：交集、并集、差集等"><a href="#其他操作：交集、并集、差集等" class="headerlink" title="其他操作：交集、并集、差集等"></a>其他操作：交集、并集、差集等</h4><p>有同学就问了，这个 insert 实现了 map 的并集操作，那交集操作呢？这其实是 set 的常规操作而不是 map 的：</p>
<ul>
<li>set_intersection（取集合交集）</li>
<li>set_union（取集合并集）</li>
<li>set_difference（取集合差集）</li>
<li>set_symmetric_difference（取集合对称差集）</li>
</ul>
<p>非常抱歉在之前的 set 课中完全没有提及，因为我认为那是 <code>&lt;algorithm&gt;</code> 头文件里的东西。</p>
<p>不过别担心，之后我们会专门有一节 algorithm 课详解 STL 中这些全局函数——我称之为算法模板，因为他提供了很多常用的算法，对小彭老师这种算法弱鸡而言，实在非常好用，妈妈再也不用担心我的 ACM 奖杯。</p>
<p>在小彭老师制作完 algorithm 课之前，同学们可以自行参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013095333/article/details/89322501">https://blog.csdn.net/u013095333/article/details/89322501</a> 提前进行学习这四个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">set_union</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(C, C.<span class="built_in">begin</span>()));  <span class="comment">// C = A U B</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：set_union 仅仅要求输入的两个区间有序，可以是 set，也可以是排序过的 vector。而且通过重载运算符或者指定 compare 函数，同样可以模拟 map 只对 key 部分排序的效果——参考 thrust::sort_by_key，但很可惜 STL 没有这函数，需要自定义 compare 函数模拟。</p>
</blockquote>
<p>同样地，这些操作也是很容易基于 map 的 contains、erase、insert 等接口“动动脑”写出保底写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; m12;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[k, v] : m2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m1.<span class="built_in">contains</span>(k)) &#123; <span class="comment">// 此处为 count 也可以</span></span><br><span class="line">        <span class="comment">// 交集操作：如果 m1 和 m2 都有这个键，则插入他俩的交集 m12</span></span><br><span class="line">        m12.<span class="built_in">insert</span>(&#123;k, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="insert-一个初始化列表"><a href="#insert-一个初始化列表" class="headerlink" title="insert 一个初始化列表"></a>insert 一个初始化列表</h3><p>C++11 还引入了一个以初始化列表（initializer_list）为参数的 insert 版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用法和 map 的构造函数一样，还是用花括号列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 初始化时就插入两个元素</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;              <span class="comment">// 批量再插入两个新元素</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,   <span class="comment">// &quot;timeout&quot; 发生键冲突，根据 insert 的特性，不会覆盖</span></span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#123;<span class="string">&quot;answer&quot;</span>: <span class="number">42</span>, <span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里还是和逐个 insert 一样，重复的键 “timeout” 没有被覆盖，依旧了保留原值。</p>
<hr>
<h4 id="小彭老师锐评批量-insert-有什么用"><a href="#小彭老师锐评批量-insert-有什么用" class="headerlink" title="小彭老师锐评批量 insert 有什么用"></a>小彭老师锐评批量 insert 有什么用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总之这玩意和分别调用两次 insert 等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>如果需要覆盖原值的批量写入，还是得乖乖写个 for 循环调用 [] 或 insert_or_assign。</p>
<p>问：既然和批量插入没什么区别，复杂度也一样是 O(logN)O(log⁡N)，那批量 insert 究竟还有什么存在的必要呢？map 又不像 vector 一个个分别插入会变成 O(N2)O(N2) 复杂度，确实需要提供个批量插入的方法。</p>
<p>答：</p>
<ol>
<li>是为了统一，既然 vector 都有批量 insert，那 set 和 map 也得有才符合完美主义美学，而且用他来合并两个 map 也很方便。</li>
<li>复杂度并不一样，当输入已经有序时，批量 insert 会比逐个 insert 更快，只需 O(N)O(N) 而不是 O(NlogN)O(Nlog⁡N)；如果输入无序，那么依然是 O(NlogN)O(Nlog⁡N)，稍后会讲原理。</li>
</ol>
<h3 id="operator-也支持初始化列表"><a href="#operator-也支持初始化列表" class="headerlink" title="operator&#x3D; 也支持初始化列表"></a>operator&#x3D; 也支持初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist);</span><br></pre></td></tr></table></figure>

<p>map 也支持赋值函数，不仅有 map 自己给自己赋值的移动赋值和拷贝赋值函数，还有从列表初始化的函数。</p>
<p>用法是等号右边一个花括号列表，作用是清空原有内容，直接设为一个全新的 map：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 初始化时就插入两个元素</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m = &#123;                   <span class="comment">// 原有内容全部清空！重新插入两个新元素</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#123;<span class="string">&quot;delay&quot;</span>: <span class="number">211</span>, <span class="string">&quot;timeout&quot;</span>: <span class="number">985</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相当于 clear 了再重新 insert，原有的 “answer” 键也被删掉了。</p>
</blockquote>
<h4 id="赋值函数和构造函数概念辨析"><a href="#赋值函数和构造函数概念辨析" class="headerlink" title="赋值函数和构造函数概念辨析"></a>赋值函数和构造函数概念辨析</h4><p>要注意赋值函数 <code>operator=(initializer_list)</code> 和构造函数 <code>map(initializer_list)</code> 是不同的。</p>
<p>构造函数是初始化时调用的（无论有没有 &#x3D; 号），赋值函数是后期重新赋值时调用的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m&#123;    <span class="comment">// 构造函数 map(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;  <span class="comment">// 虽然有等号，但这里是初始化语境，调用的依然是构造函数 map(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">m = &#123;                   <span class="comment">// m 已经初始化过，这里是重新赋值，才是赋值函数 operator=(initializer_list)</span></span><br><span class="line">    &#123;<span class="string">&quot;timeout&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;delay&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个类要支持初始化，又要支持后期重新赋值，那么构造函数和赋值函数都要实现。</p>
<p>但也可以选择只定义 <code>operator=(map &amp;&amp;)</code> 移动赋值函数而不定义 <code>operator=(initializer_list)</code>。这样当试图 <code>operator=(initializer_list)</code> 时，会匹配到 <code>map(initializer_list)</code> 这个隐式构造函数来转换，然后调用到 <code>operator=(map &amp;&amp;)</code>。标准库选择将两个都定义可能是处于避免一次 map 移动的效率考量。</p>
<h4 id="assign-函数"><a href="#assign-函数" class="headerlink" title="assign 函数"></a>assign 函数</h4><p>map 还有一个 assign 函数，他和 <code>operator=</code> 等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(initializer_list&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt; ilist)</span></span>;</span><br></pre></td></tr></table></figure>

<p>assign 的额外好处是他拥有两个迭代器参数组成区间的版本，和批量 insert 类似，只不过 assign 会清除已有的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(InputIt first, InputIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>和 <code>operator=(map(first, last))</code> 等价。</p>
<h2 id="带插入位置提示的-insert"><a href="#带插入位置提示的-insert" class="headerlink" title="带插入位置提示的 insert"></a>带插入位置提示的 insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这又是 insert 函数的一个重载版，增加了 pos 参数提示插入位置，官方文档称<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<blockquote>
<p>Inserts value in the position as close as possible to the position just prior to pos.</p>
<p>把元素（键值对）插入到位于 pos 之前，又离 pos 尽可能近的地方。</p>
</blockquote>
<p>然而 map 作为红黑树应该始终保持有序，插入位置可以由 K 唯一确定，为啥还要提示？</p>
<p>是为了在已知要插入的大致位置时，能够提升性能。</p>
<blockquote>
<p>（带提示的 insert 版本）中传入的迭代器，仅是给 map 容器提供一个建议，并不一定会被容器采纳。该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:2">2</a></p>
<p>也就是说这玩意还不一定管用，只是提示性质的（和 mmap 函数的 start 参数很像，你可以指定，但只是个提示，指定了不一定有什么软用，具体什么地址还是操作系统说了算，他从返回值里给你的地址才是正确答案）。例如已知指向 “key” 的迭代器，想要插入 “kea”，那么指定指向 “key” 的迭代器就会让 insert 能更容易定位到 “kea” 要插入的位置。</p>
</blockquote>
<h3 id="复杂度分类讨论"><a href="#复杂度分类讨论" class="headerlink" title="复杂度分类讨论"></a>复杂度分类讨论</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当插入位置 pos 提示的准确时，insert 的复杂度可以低至 O(1)+O(1)+。</li>
<li>当插入位置 pos 提示不准确时，和普通的 insert 一样，还是 O(logN)O(log⁡N)。</li>
<li>返回指向成功插入元素位置的迭代器。</li>
</ul>
<p>想想看，这三个看似不相干的特性，能有什么用呢？</p>
<p>可以让已经有序数据的批量插入更高效！</p>
<p>众所周知，普通的批量 insert 复杂度为 O(NlogN)O(Nlog⁡N)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: arr) &#123;</span><br><span class="line">    tab.<span class="built_in">insert</span>(&#123;k, v&#125;);               <span class="comment">// O(log N)</span></span><br><span class="line">&#125;  <span class="comment">// 总共 O(N log N)</span></span><br></pre></td></tr></table></figure>

<p>假如输入本就有序，带提示的批量 insert 复杂度可以降低到 O(N)O(N)。</p>
<p>如果输入无序，带提示的批量 insert 复杂度依然是 O(NlogN)O(Nlog⁡N) 不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="keyword">auto</span> hint = tab.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[k, v]: arr) &#123;</span><br><span class="line">    hint = tab.<span class="built_in">insert</span>(hint, &#123;k, v&#125;);  <span class="comment">// 平均 O(1)</span></span><br><span class="line">&#125;  <span class="comment">// 总共 O(N)</span></span><br></pre></td></tr></table></figure>

<p>想一想，为什么？</p>
<h3 id="小学生的趣味早操"><a href="#小学生的趣味早操" class="headerlink" title="小学生的趣味早操"></a>小学生的趣味早操</h3><p>你是一名小学老师，马上就要出早操了，为应付领导面子，你需要给你的学生排队，根据个子从矮到高排列。</p>
<p>不过这所小学的学生都比较懒散，有的来得早有的来得晚，而且来的早晚顺序和他们的高矮无关。</p>
<p>你本来打算等所有人到齐之后再一次性完成排序（std::sort）的，但是同学来的时间实在是太分散了：明明 8 点就要出早操，最晚的同学却 7 点 59 分才到达。意味着你需要一直干等着这个懒散的同学，最后在 1 分钟时间内临时抱佛脚，完成快速排序。这是不可能的，只能在同学陆续抵达的同时进行排序，这就是堆排序，一边插入一边排序，每次插入后都保证有序，与插入排序不同他使用堆内存中的节点而不是数组避免昂贵的数组平移操作。</p>
<p>每当来一个学生，你就得把他插入到现有的一个已经排好的队伍中去。</p>
<p>如何确定插入的位置？二分法。先从现有队伍的最中间（1&#x2F;2 处）开始，比较中间这个学生和新来的学生哪个高哪个矮，如果发现新来的学生高，则继续从队列的 3&#x2F;4 处那个同学开始比高矮，如果新来的学生矮就从队列的 1&#x2F;4 处继续比较。以此类推，最终唯一确定新同学要插入的位置。因为每次确定的范围就小一半，所以最多只需要 logNlog⁡N 次比较就可以成功插入，其中 NN 是当前已有学生的数量。</p>
<p>总共要来 NN 名学生，则你总共需要比较 NlogNNlog⁡N 次。能不能优化？让我们小彭老师省力点？</p>
<h3 id="小学生来的顺序已经有序的情况"><a href="#小学生来的顺序已经有序的情况" class="headerlink" title="小学生来的顺序已经有序的情况"></a>小学生来的顺序已经有序的情况</h3><p>后来你发现一个规律，似乎学生来的早晚顺序和高矮有关：矮小的同学喜欢起的早，高大的同学喜欢起的晚。</p>
<p>知道这个规律后，你改变你的策略：二分法时，不是先从最中间（1&#x2F;2 处）开始查找，而是从最末尾开始查找。因为矮小同学会早到，导致每次新来的同学往往总是队列中最高的那一个。所以可以从队伍的末尾（最高的地方）开始找，例如有 64 名同学则优先和 65&#x2F;64 处比较，找不到再往上一级和 31&#x2F;32 处比较。</p>
<p>这个策略也有缺点：对于早晚顺序和高矮无关、甚至负相关的情况，每次插入的消耗就会变成 2logN2log⁡N 了。</p>
<p>最终我们决定采用的策略是：不是从中间，也不是从开头，也不是从末尾，而是<strong>记住上一次成功插入的位置</strong>，下一次从上一次成功插入的位置开始找。这个记忆的插入位置，就是刚刚代码中那个位置提示迭代器 hint。</p>
<p>这正是我们代码的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = tab.<span class="built_in">insert</span>(hint, &#123;k, v&#125;);</span><br></pre></td></tr></table></figure>

<p>实际上，insert 的批量插入版 <code>insert(arr.begin(), arr.end())</code> 内部就会使用这种带提示的方式，逐个插入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br></pre></td></tr></table></figure>

<h2 id="分奴-emplace"><a href="#分奴-emplace" class="headerlink" title="分奴 emplace"></a>分奴 emplace</h2><p>insert 的究极分奴版（不推荐）：emplace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>虽然变长参数列表 <code>Args &amp;&amp;...args</code> 看起来很酷，然而由于 map 的特殊性，其元素类型是 <code>pair&lt;const K, V&gt;</code>，而 pair 的构造函数只有两个参数，导致实际上这个看似炫酷的变长参数列表往往只能接受两个参数，因此这个函数的调用方法实际上只能是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(K k, V v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">emplace</span>(key, val);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, val&#125;);</span><br></pre></td></tr></table></figure>

<p>返回值还是 <code>pair&lt;iterator, bool&gt;</code>，其意义和 insert 一样，不再赘述。</p>
<hr>
<h3 id="emplace-hint"><a href="#emplace-hint" class="headerlink" title="emplace_hint"></a>emplace_hint</h3><p>insert 的宇宙无敌分奴版（不推荐）：emplace_hint<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace_hint</span><span class="params">(const_iterator pos, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">emplace_hint</span>(pos, key, val);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(pos, &#123;key, val&#125;);</span><br></pre></td></tr></table></figure>

<p>之所以要分两个函数名 emplace 和 emplace_hint 而不是利用重载区分，是因为直接传入 pos 会被 emplace 当做 pair 的构造参数，而不是插入位置提示。</p>
<ul>
<li>emplace 对应于普通的 <code>insert(pair&lt;const K, V&gt;)</code> 这一重载。</li>
<li>emplace_hint 对应于带插入位置提示的 <code>insert(const_iterator, pair&lt;const K, V&gt;)</code> 这一重载。</li>
<li>emplace_hint 的返回类型也和带插入位置提示的 insert 一样，是单独一个 iterator。</li>
</ul>
<h3 id="emplace-的原理和优点"><a href="#emplace-的原理和优点" class="headerlink" title="emplace 的原理和优点"></a>emplace 的原理和优点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">emplace</span><span class="params">(Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>emplace 对于 set，元素类型是比较大的类型时，例如 <code>set&lt;array&lt;int, 100&gt;&gt;</code>，可能确实能起到减少移动构造函数开销的作用。</p>
<p>但是这个 map 他的元素类型不是直接的 V 而是一个 pair，他分的是 pair 的构造函数，没有用，V 部分还是会造成一次额外的移动开销，所以这玩意除了妨碍类型安全和可读性以外，没有任何收益。</p>
<ul>
<li>set 可以用 emplace&#x2F;emplace_hint。</li>
<li>vector 可以用 emplace_back。</li>
<li>不建议在 map 上使用 emplace&#x2F;emplace_hint，请改用 try_emplace。</li>
</ul>
<h2 id="try-emplace-更好"><a href="#try-emplace-更好" class="headerlink" title="try_emplace 更好"></a>try_emplace 更好</h2><p>emplace 只支持 pair 的就地构造，这有什么用？我们要的是 pair 中值类型的就地构造！这就是 try_emplace 的作用了，他对 key 部分依然是传统的移动，只对 value 部分采用就地构造。</p>
<blockquote>
<p>这是观察到大多是值类型很大，急需就地构造，而键类型没用多少就地构造的需求。例如 <code>map&lt;string, array&lt;int, 1000&gt;&gt;</code></p>
<p>如果想不用 try_emplace，完全基于 emplace 实现针对值 value 的就地构造需要用到 std::piecewise_construct 和 std::forward_as_tuple，非常麻烦。</p>
</blockquote>
<p>insert 的托马斯黄金大回旋分奴版：try_emplace（C++17 引入）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">try_emplace</span><span class="params">(K <span class="type">const</span> &amp;k, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">try_emplace</span>(key, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<p>他等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);</span><br></pre></td></tr></table></figure>

<p>后面的变长参数也可以完全没有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">try_emplace</span>(key);</span><br></pre></td></tr></table></figure>

<p>他等价于调用 V 的默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>()&#125;);</span><br></pre></td></tr></table></figure>

<p>由于 emplace 实在是憨憨，他变长参数列表就地构造的是 pair，然而 pair 的构造函数正常不就是只有两个参数吗，变长没有用。实际有用的往往是我们希望用变长参数列表就地构造值类型 V，对 K 部分并不关系。因此 C++17 引入了 try_emplace，其键部分保持 <code>K const &amp;</code>，值部分采用变长参数列表。</p>
<p>我的评价是：这个比 emplace 实用多了，如果要与 vector 的 emplace_back 对标，那么 map 与之对应的一定是 try_emplace。同学们如果要分奴的话还是建议用 try_emplace。</p>
<h3 id="try-emplace-可以避免移动！"><a href="#try-emplace-可以避免移动！" class="headerlink" title="try_emplace 可以避免移动！"></a>try_emplace 可以避免移动！</h3><p>insert 类函数总是不可避免的需要移动构造：先在函数中构造出临时对象，然后构造到真正的 pair 上。</p>
<p>而 try_emplace 可以允许你就地构造值对象，避免移动造成开销。</p>
<p>try_emplace 第一个参数是键，第二个开始是传给构造函数的参数，如只有第一个参数则是调用无参构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i) &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(int)\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">float</span> x) &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(const char *, float)\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, MyClass&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>);                 <span class="comment">// MyClass()</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="number">42</span>);             <span class="comment">// MyClass(int)</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;hell&quot;</span>, <span class="number">3.14f</span>);  <span class="comment">// MyClass(const char *, float)</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>()&#125;);                <span class="comment">// MyClass()</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">42</span>)&#125;);              <span class="comment">// MyClass(int)</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="string">&quot;hell&quot;</span>, <span class="number">3.14f</span>)&#125;);   <span class="comment">// MyClass(const char *, float)</span></span><br></pre></td></tr></table></figure>

<p>对于移动开销较大的类型（例如 <code>array&lt;int, 1000&gt;</code>），try_emplace 可以避免移动；对于不支持移动构造函数的值类型，就必须使用 try_emplace 了。</p>
<h3 id="谈谈-try-emplace-的优缺点"><a href="#谈谈-try-emplace-的优缺点" class="headerlink" title="谈谈 try_emplace 的优缺点"></a>谈谈 try_emplace 的优缺点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式效果等价，只有性能不同</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(key, arg1, arg2, ...);           <span class="comment">// 开销：1次构造函数</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);           <span class="comment">// 开销：1次构造函数 + 2次移动函数</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>(arg1, arg2, ...)));  <span class="comment">// 开销：1次构造函数 + 3次移动函数</span></span><br></pre></td></tr></table></figure>

<p>但是由于 try_emplace 是用圆括号帮你调用的构造函数，而不是花括号初始化。</p>
<p>导致你要么无法省略类型，要么你得手动定义类的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;  <span class="comment">// 没有构造函数，只能用花括号语法进行初始化</span></span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;&#125;);            <span class="comment">// OK: insert 参数类型已知，Student 可以省略不写，但是会造成 2 次移动</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);           <span class="comment">// ERROR: 不存在构造函数 Student(string, int)；C++20 开始则 OK: C++20 起聚合初始化同时支持花括号和圆括号</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, &#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);         <span class="comment">// ERROR: 参数类型是模板类型，未知，无法省略花括号前的类型</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);  <span class="comment">// OK: 明确指定类型的花括号初始化；但这样又会造成 1 次移动，失去了 try_emplace 避免移动的意义</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外还要注意不论 insert、emplace、emplace_hint、try_emplace，都是一个尿性：键冲突时不会覆盖已有元素。</p>
<p>如果需要覆盖性的插入，还得乖乖用 [] 或者 insert_or_assign 函数。</p>
</blockquote>
<p>由于 try_emplace 里写死了圆括号，我们只好手动定义的构造函数才能劳驾 try_emplace 就地构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Student</span>(string sex, <span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">sex</span>(std::<span class="built_in">move</span>(sex))</span><br><span class="line">        , <span class="built_in">age</span>(age)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 由于 try_emplace 会就地构造对象，其值类型可以没有移动构造函数，而 insert 会出错</span></span><br><span class="line">    <span class="built_in">Student</span>(Student &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student &amp;<span class="keyword">operator</span>=(Student &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Student</span>(Student <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student &amp;<span class="keyword">operator</span>=(Student <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);           <span class="comment">// OK: 会调用构造函数 Student(string, int) 就地构造对象</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;彭于斌&quot;</span>, <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>)&#125;);     <span class="comment">// ERROR: insert 需要移动 Student 而 Student 的移动被 delete 了！</span></span><br></pre></td></tr></table></figure>

<h3 id="什么是聚合初始化"><a href="#什么是聚合初始化" class="headerlink" title="什么是聚合初始化"></a>什么是聚合初始化</h3><p>无构造函数时，C++11 支持花括号初始化（官方名: 聚合初始化<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>），C++20 开始聚合初始化也能用圆括号（所以 emplace &#x2F; try_emplace 这类函数变得更好用了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> s1 = Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;;  <span class="comment">// C++11 起 OK: 无构造函数时的花括号初始化语法</span></span><br><span class="line"><span class="keyword">auto</span> s2 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);  <span class="comment">// C++20 起 OK: 编译器会自动生成圆括号构造函数 Student(string, int)</span></span><br></pre></td></tr></table></figure>

<p>和花括号初始化时一样，可以省略一部分参数，这部分参数会用他们的默认值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s1 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);     <span class="comment">// OK: sex 为 &quot;自定义&quot;，age 为 22</span></span><br><span class="line"><span class="keyword">auto</span> s2 = <span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>);         <span class="comment">// OK: 省略 age 自动为 0</span></span><br><span class="line"><span class="keyword">auto</span> s3 = <span class="built_in">Student</span>();                 <span class="comment">// OK: 省略 sex 自动为 &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过他和花括号不一样的是，作为已知参数类型的函数参数时，类型名不能省略了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Student <span class="type">const</span> &amp;stu)</span></span>;    <span class="comment">// 已知函数签名</span></span><br><span class="line"><span class="built_in">func</span>(Student&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);      <span class="comment">// OK: C++11 语法</span></span><br><span class="line"><span class="built_in">func</span>(&#123;<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>&#125;);             <span class="comment">// OK: C++11 语法，已知函数具有唯一重载的情况下类名可以省略</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">Student</span>(<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>));      <span class="comment">// OK: C++20 语法</span></span><br><span class="line"><span class="built_in">func</span>((<span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>));             <span class="comment">// ERROR: 无法从 int 转换为 Student</span></span><br></pre></td></tr></table></figure>

<h3 id="C-20-修复了聚合初始化不支持圆括号的缺点"><a href="#C-20-修复了聚合初始化不支持圆括号的缺点" class="headerlink" title="C++20 修复了聚合初始化不支持圆括号的缺点"></a>C++20 修复了聚合初始化不支持圆括号的缺点</h3><p>所以现在 try_emplace 也可以就地构造无构造函数的类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Student&gt; m;</span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>, <span class="number">22</span>);       <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;自定义&quot;, 22&#125;</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>, <span class="string">&quot;自定义&quot;</span>);           <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;自定义&quot;, 0&#125;</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;彭于斌&quot;</span>);                    <span class="comment">// OK: 等价于 m[&quot;彭于斌&quot;] = Student&#123;&quot;&quot;, 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>方便！</p>
<blockquote>
<p>关于更多 C++20 的聚合初始化小知识，可以看这期 CppCon 视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=flLNi0aejew">https://www.youtube.com/watch?v=flLNi0aejew</a></p>
<p>为方便你在比站搜索搬运，他的标题是：Lightning Talk: Direct Aggregate Initialisation - Timur Doumler - CppCon 2021</p>
</blockquote>
<h3 id="调用开销分析"><a href="#调用开销分析" class="headerlink" title="调用开销分析"></a>调用开销分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass &amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass(MyClass &amp;&amp;)\n&quot;</span>); &#125;</span><br><span class="line">    MyClass &amp;<span class="keyword">operator</span>=(MyClass &amp;&amp;) <span class="keyword">noexcept</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;MyClass &amp;operator=(MyClass &amp;&amp;)\n&quot;</span>); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, MyClass&gt; tab;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;insert的开销:\n&quot;</span>);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="built_in">MyClass</span>()&#125;);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;try_emplace的开销:\n&quot;</span>);</span><br><span class="line">tab.<span class="built_in">try_emplace</span>(<span class="number">2</span>);  <span class="comment">// try_emplace 只有一个 key 参数时，相当于调用无参构造函数 MyClass()</span></span><br></pre></td></tr></table></figure>

<p>insert 调用了两次移动函数，一次发生在 pair 的构造函数，一次发生在 insert 把参数 pair 移进红黑树节点里。</p>
<p>而 try_emplace 内部使用了现代 C++ 的就地构造（placement new），直接在红黑树节点的内存中构造 MyClass，无需反复移动，对于尺寸较大的值类型会更高效。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert的开销:</span><br><span class="line"><span class="keyword">MyClass</span>()</span><br><span class="line"><span class="keyword">MyClass</span>(<span class="keyword">MyClass</span> &amp;&amp;)</span><br><span class="line"><span class="keyword">MyClass</span>(<span class="keyword">MyClass</span> &amp;&amp;)</span><br><span class="line">try_emplace的开销:</span><br><span class="line"><span class="keyword">MyClass</span>()</span><br></pre></td></tr></table></figure>

<h3 id="try-emplace-成功提升性能的案例"><a href="#try-emplace-成功提升性能的案例" class="headerlink" title="try_emplace 成功提升性能的案例"></a>try_emplace 成功提升性能的案例</h3><p>提升了 1.42 倍性能，不能说是惊天地泣鬼神吧，至少也可以说是聊胜于无了。这里的值类型 string 只有 32 字节还不够明显，可能更大的自定义类型会有明显的优势。这种优化的理论上限是 3 倍，最多能从 try_emplace 获得 3 倍性能提升。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test_insert</span><span class="params">(map&lt;K, V&gt; &amp;tab)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1次string(const char *) 2次string(string &amp;&amp;)</span></span><br><span class="line">        tab.<span class="built_in">insert</span>(&#123;i, <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test_try_emplace</span><span class="params">(map&lt;K, V&gt; &amp;tab)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1次string(const char *)</span></span><br><span class="line">        tab.<span class="built_in">try_emplace</span>(i, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, string&gt; tab;</span><br><span class="line">        <span class="built_in">test_insert</span>(tab);</span><br><span class="line">        <span class="built_in">doNotOptimize</span>(tab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, string&gt; tab;</span><br><span class="line">        <span class="built_in">test_try_emplace</span>(tab);</span><br><span class="line">        <span class="built_in">doNotOptimize</span>(tab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printScopeProfiler</span>();</span><br><span class="line">&#125;</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">       <span class="number">39</span>|       <span class="number">34</span>|      <span class="number">218</span>|    <span class="number">39927</span>| <span class="number">1000</span>| test_insert</span><br><span class="line">       <span class="number">28</span>|       <span class="number">27</span>|       <span class="number">91</span>|    <span class="number">28181</span>| <span class="number">1000</span>| test_try_emplace</span><br></pre></td></tr></table></figure>

<hr>
<p>如果改成更大的自定义类型，可以提升 2.3 倍。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4096</span>];</span><br><span class="line">&#125;;</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">     <span class="number">1312</span>|     <span class="number">1193</span>|    <span class="number">18298</span>|  <span class="number">1312871</span>| <span class="number">1000</span>| test_insert</span><br><span class="line">      <span class="number">573</span>|      <span class="number">537</span>|     <span class="number">1064</span>|   <span class="number">573965</span>| <span class="number">1000</span>| test_try_emplace</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="带插入位置提示的-try-emplace"><a href="#带插入位置提示的-try-emplace" class="headerlink" title="带插入位置提示的 try_emplace"></a>带插入位置提示的 try_emplace</h3><p>insert 的炫彩中二摇摆混沌大魔王分奴版：带插入位置提示的 try_emplace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">try_emplace</span><span class="params">(const_iterator pos, K <span class="type">const</span> &amp;k, Args &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = m.<span class="built_in">try_emplace</span>(hint, key, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = m.<span class="built_in">insert</span>(hint, &#123;key, <span class="built_in">V</span>(arg1, arg2, ...)&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这次不需要再分一个什么 try_emplace_hint 出来了，是因为 try_emplace 的第一个参数是 K 类型而不是泛型，不可能和 const_iterator 类型混淆，因此 C++ 委员会最终决定直接共用同一个名字，让编译器自动重载了。</p>
</blockquote>
<h3 id="emplace-家族总结"><a href="#emplace-家族总结" class="headerlink" title="emplace 家族总结"></a>emplace 家族总结</h3><p>总结，如何用 emplace 家族优化？分直接插入和带提示插入两种用法，和你是否需要高性能两种需求，这里标了“推荐”的是建议采用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入版</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;);              <span class="comment">// 可读性推荐</span></span><br><span class="line">m.<span class="built_in">try_emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);                    <span class="comment">// 高性能推荐</span></span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));               <span class="comment">// 没意义</span></span><br><span class="line">m.<span class="built_in">emplace</span>(std::piecewise_construct, std::forward_as_tuple(<span class="string">&quot;key&quot;</span>), std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// C++17 以前的高性能写法</span></span><br><span class="line"><span class="comment">// 带插入位置提示版</span></span><br><span class="line">hint = m.<span class="built_in">insert</span>(hint, &#123;<span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;);       <span class="comment">// 可读性推荐</span></span><br><span class="line">hint = m.<span class="built_in">try_emplace</span>(hint, <span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);             <span class="comment">// 高性能推荐</span></span><br><span class="line">hint = m.<span class="built_in">emplace_hint</span>(hint, <span class="string">&quot;key&quot;</span>, <span class="built_in">MyClass</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">// 没意义</span></span><br><span class="line">hint = m.<span class="built_in">emplace_hint</span>(hint, std::piecewise_construct, std::forward_as_tuple(<span class="string">&quot;key&quot;</span>), std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// C++17 以前的高性能写法</span></span><br></pre></td></tr></table></figure>

<h2 id="map-与-RAII"><a href="#map-与-RAII" class="headerlink" title="map 与 RAII"></a>map 与 RAII</h2><p>梦幻联动：map 容器与 RAII 的双向奔赴</p>
<p>如果 map 中元素的值类型是 RAII 类型，其析构函数会在元素被删除时自动调用。</p>
<p>map 被移动时，不会调用元素的移动函数，因为 map 里只存着指向红黑树根节点的指针，只需指针移动即可。</p>
<p>map 被拷贝时，会调用元素的拷贝函数，如果元素不支持拷贝，则 map 的拷贝也会被禁用（delete）掉。</p>
<p>map 被析构时，其所有元素都会被析构。</p>
<h3 id="案例-1：资源类可以移动"><a href="#案例-1：资源类可以移动" class="headerlink" title="案例 1：资源类可以移动"></a>案例 1：资源类可以移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源移动\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII &amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源移动赋值\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure>

<h3 id="案例-2：资源类禁止移动"><a href="#案例-2：资源类禁止移动" class="headerlink" title="案例 2：资源类禁止移动"></a>案例 2：资源类禁止移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">RAII</span>(RAII <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    RAII &amp;<span class="keyword">operator</span>=(RAII <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新手定义 RAII 类时，记得把移动和拷贝 4 个函数全部删除。没错，<strong>移动也要删除</strong>，很多新手会觉得资源类应该可以移动的呀？要是想保留移动，就得预留一个 i &#x3D;&#x3D; 0 的空状态，那种处理很复杂的。总之一旦定义了析构函数，全部 4 个函数都得删除，除非你有相关经验。参见 <a target="_blank" rel="noopener" href="https://142857.red/book/cpp_lifetime/">C++ 生命周期与析构函数专题</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure>

<p>这时就体现出 try_emplace 的好处了：值类型不需要有移动构造函数也可以插入。</p>
<h3 id="记得删除移动构造函数"><a href="#记得删除移动构造函数" class="headerlink" title="记得删除移动构造函数"></a>记得删除移动构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RAII</span><span class="params">(<span class="type">int</span> i_)</span> : i(i_) &#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源初始化\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RAII</span>(RAII &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RAII</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号资源释放\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冷知识：只需要删除移动构造函数，编译器就会自动帮你删除剩下 3 个，这是因为看到你用了 <code>&amp;&amp;</code> 就知道你是懂 C++11 的，所以不用照顾 C++98 兼容性保留烦人的拷贝构造函数，自动帮你删了，这是个标准，所有 C++ 编译器都是这样的（要我说，建议改成定义了析构函数就自动删全 4 个函数，可惜标准委员会要照顾兼容性…）</p>
<p>以后 RAII 类只需要一行 <code>C(C &amp;&amp;) = delete</code> 就够了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, RAII&gt; m;</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源1号&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源2号&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">try_emplace</span>(<span class="string">&quot;资源3号&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>号资源初始化</span><br><span class="line"><span class="number">2</span>号资源初始化</span><br><span class="line"><span class="number">1</span>号资源释放</span><br><span class="line"><span class="number">3</span>号资源初始化</span><br><span class="line"><span class="number">3</span>号资源释放</span><br><span class="line"><span class="number">2</span>号资源释放</span><br><span class="line">此时所有资源都应该已经释放</span><br></pre></td></tr></table></figure>

<h3 id="统一交给智能指针管理"><a href="#统一交给智能指针管理" class="headerlink" title="统一交给智能指针管理"></a>统一交给智能指针管理</h3><p>如果你想用更可读的 insert，RAII 资源类又不支持移动，可以用 <code>unique_ptr&lt;RAII&gt;</code> 包装一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, std::unique_ptr&lt;RAII&gt;&gt; m;</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源1号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">1</span>));</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源2号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">2</span>));</span><br><span class="line">        m.<span class="built_in">erase</span>(<span class="string">&quot;资源1号&quot;</span>);</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="string">&quot;资源3号&quot;</span>, std::<span class="built_in">make_unique</span>&lt;RAII&gt;(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时所有资源都应该已经释放\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="智能指针帮你避免移动"><a href="#智能指针帮你避免移动" class="headerlink" title="智能指针帮你避免移动"></a>智能指针帮你避免移动</h4><p>对于很大的 V 类型，也可以改用 <code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 避免反复移动元素本体。（用在需要反复扩容的 vector 中也有奇效）</p>
<p>因为包括 map 在内的所有容器都完美支持 RAII 类型，所以也可以用智能指针作为这些容器的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 假设这个很大</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyData</span><span class="params">(<span class="type">int</span> value_)</span> : value(value_) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, unique_ptr&lt;MyData&gt;&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;answer&quot;</span>, <span class="built_in">make_unique</span>&lt;MyData&gt;(<span class="number">42</span>)&#125;);  <span class="comment">// 只有 8 字节的 unique_ptr 被移动 2 次</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;fuck&quot;</span>, <span class="built_in">make_unique</span>&lt;MyData&gt;(<span class="number">985</span>)&#125;);</span><br><span class="line"><span class="built_in">print</span>(m.<span class="built_in">at</span>(<span class="string">&quot;answer&quot;</span>)-&gt;value);  <span class="comment">// 42</span></span><br><span class="line"><span class="comment">// ↑等价于：print((*m.at(&quot;answer&quot;)).value);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>map&lt;T, unique_ptr&lt;V&gt;&gt;</code> 中，智能指针指向的对象会在元素被删除时自动释放。</li>
<li><code>map&lt;T, V *&gt;</code> 中，C 语言原始指针不具备 RAII 功能，除非该指针被其他智能指针打理着，或者用户删除元素之前手动 delete，否则当元素删除时内存会泄露！</li>
</ul>
<p>我推荐完全采用智能指针来自动管理内存，智能指针和同样符合 RAII 思想的各大容器也是相性很好的。</p>
<p>如果需要浅拷贝的话，则可以改用 <code>map&lt;T, shared_ptr&lt;V&gt;&gt;</code>，小彭老师在他的 Zeno 项目中就是这样用的。</p>
<h2 id="增删改查总结"><a href="#增删改查总结" class="headerlink" title="增删改查总结"></a>增删改查总结</h2><h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td><code>m.insert(make_pair(key, val))</code></td>
<td>插入但不覆盖</td>
<td>C++98</td>
<td>💩</td>
</tr>
<tr>
<td><code>m.insert(&#123;key, val&#125;)</code></td>
<td>插入但不覆盖</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.emplace(key, val)</code></td>
<td>插入但不覆盖</td>
<td>C++11</td>
<td>💩</td>
</tr>
<tr>
<td><code>m.try_emplace(key, valargs...)</code></td>
<td>插入但不覆盖</td>
<td>C++17</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.insert_or_assign(key, val)</code></td>
<td>插入或覆盖</td>
<td>C++17</td>
<td>❤</td>
</tr>
<tr>
<td><code>m[key] = val</code></td>
<td>插入或覆盖</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.erase(key)</code></td>
<td>删除指定元素</td>
<td>C++98</td>
<td>❤</td>
</tr>
</tbody></table>
<h3 id="改查"><a href="#改查" class="headerlink" title="改查"></a>改查</h3><table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td><code>m.at(key)</code></td>
<td>找不到则出错，找到则返回引用</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m[key]</code></td>
<td>找不到则自动创建<code>0</code>值，返回引用</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>myutils::map_get(m, key, defl)</code></td>
<td>找不到则返回默认值</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.find(key) == m.end()</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++98</td>
<td>💣</td>
</tr>
<tr>
<td><code>m.count(key)</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.contains(key)</code></td>
<td>检查键 <code>key</code> 是否存在</td>
<td>C++20</td>
<td>💩</td>
</tr>
</tbody></table>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
<th>版本</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td><code>map&lt;K, V&gt; m = &#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td>
<td>初始化为一系列键值对</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>auto m = map&lt;K, V&gt;&#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td>
<td>初始化为一系列键值对</td>
<td>C++11</td>
<td>💩</td>
</tr>
<tr>
<td><code>func(&#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;)</code></td>
<td>给函数参数传入一个 map</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m = &#123;&#123;k1, v1&#125;, &#123;k2, v2&#125;&#125;</code></td>
<td>重置为一系列键值对</td>
<td>C++11</td>
<td>❤</td>
</tr>
<tr>
<td><code>m.clear()</code></td>
<td>清空所有表项</td>
<td>C++98</td>
<td>❤</td>
</tr>
<tr>
<td><code>m = &#123;&#125;</code></td>
<td>清空所有表项</td>
<td>C++11</td>
<td>💣</td>
</tr>
</tbody></table>
<h2 id="节点句柄系列接口"><a href="#节点句柄系列接口" class="headerlink" title="节点句柄系列接口"></a>节点句柄系列接口</h2><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><p>C++17 新增的 extract 函数<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a> 可以“剥离”出单个节点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node_type <span class="title">extract</span><span class="params">(K <span class="type">const</span> &amp;key)</span></span>;</span><br><span class="line"><span class="function">node_type <span class="title">extract</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> &amp;k = node.<span class="built_in">key</span>();    <span class="comment">// 键（引用）</span></span><br><span class="line"><span class="keyword">auto</span> &amp;v = node.<span class="built_in">mapped</span>(); <span class="comment">// 值（引用）</span></span><br></pre></td></tr></table></figure>

<p>其功能与 erase 类似，都会将元素从 map 中删除，但 extract 只是把节点从 map 中移走，并不会直接销毁节点。</p>
<p>extract 会返回这个刚被“剥离”出来节点的句柄，类型为 node_type，节点的生杀大权就这样返回给了用户来处置。</p>
<p>node_type 是指向游离红黑树节点的特殊智能指针，称为节点句柄<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:2">2</a>。只可移动不可拷贝，类似一个指向节点的 unique_ptr。</p>
<p>当调用 extract(key) 时会把 key 对应的键值对所在的红黑树节点“脱离”出来——不是直接释放节点内存并销毁键值对象，而是把删除的节点的所有权移交给了调用者，以返回一个特殊智能指针 node_type 的形式。</p>
<p>调用 extract 后，节点句柄指向的这个红黑树节点已经从 map 中移除（其 left、right、parent 等指针为 NULL），处于游离状态。</p>
<blockquote>
<p>节点中不仅存储着我们感兴趣的键和值，还有 left、right、parent、color 等用于维护数据结构的成员变量，对用户不可见。</p>
</blockquote>
<p>只是因为节点句柄类似于 unique_ptr，维持着节点的生命周期，保护着键 key() 和值 mapped() 没有被销毁，内存没有被释放。</p>
<p>如果调用者接下来不做操作，那么当离开调用者所在的函数体时，这个特殊的 unique_ptr 会自动释放其指向节点。</p>
<ul>
<li>对于第一个按键取出节点句柄的 extract 重载：如果键值不存在，那么 extract 会返回一个特殊的空节点句柄，类似于空指针。可以通过 <code>(bool)node</code> 来判断一个节点句柄是否为空。</li>
<li>对于第二个按迭代器取出句柄的 extract：总是成功，因为既然你已经获得了迭代器，肯定是 find 获得的，而 find 找不到返回的 end 传入 extract 是未定义行为。正如 erase 迭代器版重载 erase(it) 总是成功一样。</li>
</ul>
<h4 id="用途举例"><a href="#用途举例" class="headerlink" title="用途举例"></a>用途举例</h4><p>调用者稍后可以直接销毁这个特殊智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(node.<span class="built_in">key</span>(), node.<span class="built_in">mapped</span>());</span><br><span class="line">&#125; <span class="comment">// node 在此自动销毁</span></span><br></pre></td></tr></table></figure>

<p>也可以做一些修改后（例如修改键值），稍后重新用 insert(node) 重新把他插入回去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;love&quot;</span>;</span><br><span class="line">m.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过去，通过迭代器来修改键值是不允许的：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(it != m.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// *it 是 pair&lt;const string, int&gt;</span></span><br><span class="line">it-&gt;first = <span class="string">&quot;love&quot;</span>; <span class="comment">// 错误！first 是 const string 类型</span></span><br><span class="line">m.<span class="built_in">insert</span>(*it);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为直接修改在 map 里面的一个节点的键，会导致排序失效，破坏红黑树的有序。而 extract 取出来的游离态节点，可以修改 <code>.key()</code>，不会影响任何红黑树的顺序，他已经不在树里面了。</p>
</blockquote>
<p>或者插入到另一个不同的 map 对象（但键和值类型相同）里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1 挪到 m2</span></span><br><span class="line"><span class="keyword">auto</span> node = m1.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br></pre></td></tr></table></figure>

<p>优点在于，extract 和节点版 insert 不涉及内存的重新分配与释放，不涉及元素类型的移动（因为节点句柄类似于智能指针，智能指针的移动并不会导致其指向对象的移动），所以会比下面这种传统写法更高效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1 挪到 m2：传统写法</span></span><br><span class="line"><span class="keyword">if</span> (m1.<span class="built_in">count</span>(<span class="string">&quot;fuck&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = std::<span class="built_in">move</span>(m1.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">    m2[<span class="string">&quot;fuck&quot;</span>] = std::<span class="built_in">move</span>(value);</span><br><span class="line">    m1.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用 auto 完整写出全部类型的形式（古代 C++98 作风）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> map&lt;K, V&gt;::node_type node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">K &amp;k = node.<span class="built_in">key</span>();</span><br><span class="line">V &amp;v = node.<span class="built_in">mapped</span>();</span><br></pre></td></tr></table></figure>

<p>set 也有 extract 函数，其节点句柄没有 key() 和 mapped() 了，而是只有一个 value()，获取其中的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;V&gt; s = &#123;<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;suck&quot;</span>, <span class="string">&quot;dick&quot;</span>&#125;;</span><br><span class="line">set&lt;V&gt;::node_type node = s.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">V &amp;v = node.<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure>

<h3 id="insert-节点版"><a href="#insert-节点版" class="headerlink" title="insert 节点版"></a>insert 节点版</h3><p>insert 函数：插入游离节点的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert_return_type <span class="title">insert</span><span class="params">(node_type &amp;&amp;node)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, node_type &amp;&amp;node)</span></span>; <span class="comment">// 带提示的版本</span></span><br></pre></td></tr></table></figure>

<p>可以用 insert(move(node)) 直接插入一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m1 = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dick&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">auto</span> node = m1.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">m2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));  <span class="comment">// 节点句柄类似于 unique_ptr，不可拷贝，需要用移动语义进行插入</span></span><br></pre></td></tr></table></figure>

<p>调用 insert(move(node)) 后由于所有权被移走，node 将会处于“空指针”状态，可以用 <code>node.empty()</code> 查询节点句柄是否为“空”状态，即节点所有权是否已经移走。</p>
<h4 id="insert-return-type"><a href="#insert-return-type" class="headerlink" title="insert_return_type"></a>insert_return_type</h4><p>这个版本的 insert 返回值类型 insert_return_type 是一个结构体（我的天他们终于肯用结构体而不是 pair 了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">insert_return_type</span> &#123;</span><br><span class="line">    iterator position;</span><br><span class="line">    <span class="type">bool</span> inserted;</span><br><span class="line">    node_type node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">insert_return_type <span class="title">insert</span><span class="params">(node_type &amp;&amp;nh)</span></span>;</span><br></pre></td></tr></table></figure>

<p>官方说法是<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：</p>
<blockquote>
<p>If nh is empty, inserted is false, position is end(), and node is empty.</p>
<p>Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty.</p>
<p>If the insertion failed, inserted is false, node has the previous value of nh, and position points to an element with a key equivalent to nh.key().</p>
</blockquote>
<h3 id="extract-insert-运用案例"><a href="#extract-insert-运用案例" class="headerlink" title="extract + insert 运用案例"></a>extract + insert 运用案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; hells = &#123;</span><br><span class="line">    &#123;<span class="number">666</span>, <span class="string">&quot;devil&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; schools = &#123;</span><br><span class="line">    &#123;<span class="number">985</span>, <span class="string">&quot;professor&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">211</span>, <span class="string">&quot;doctor&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">996</span>, <span class="string">&quot;fucker&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> node = schools.<span class="built_in">extract</span>(<span class="number">996</span>);</span><br><span class="line">hells.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br><span class="line"><span class="built_in">print</span>(schools);</span><br><span class="line"><span class="built_in">print</span>(hells);</span><br><span class="line">&#123;<span class="number">211</span>: <span class="string">&quot;doctor&quot;</span>, <span class="number">985</span>: <span class="string">&quot;professor&quot;</span>&#125;</span><br><span class="line">&#123;<span class="number">666</span>: <span class="string">&quot;devil&quot;</span>, <span class="number">996</span>: <span class="string">&quot;fucker&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>extract + insert(move(node)) 对比 find + insert({key, val})，可以避免键和值类型移动构造函数的开销，至始至终移动的只是一个红黑树节点的指针，元素没有被移动，也没有造成内存空间不必要的分配和释放。</p>
<p>但是 insert(move(node)) 仅适用于从 extract 中取出现有节点的情况，如果要新建节点还得靠 insert({key, val}) 或者 try_emplace(key, val) 的。</p>
<h3 id="extract-性能优化案例"><a href="#extract-性能优化案例" class="headerlink" title="extract 性能优化案例"></a>extract 性能优化案例</h3><p>已知两个映射表 tab1 和 tab2，和一个接受 K 类型做参数的仿函数 cond。</p>
<p>要求把 tab1 中键符合 cond 条件的元素移动到 tab2 中去，其余保留在 tab1 中。</p>
<p>我们编写四份同样功能的程序，分别采用：</p>
<ul>
<li>extract + 带提示的 insert</li>
<li>erase + 带提示的 insert</li>
<li>extract + 直接 insert</li>
<li>erase + 直接 insert</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_extract</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next_it = it;</span><br><span class="line">            ++next_it;</span><br><span class="line">            <span class="keyword">auto</span> node = tab1.<span class="built_in">extract</span>(it);</span><br><span class="line">            tab2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(node));</span><br><span class="line">            it = next_it;</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_erase</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            it = tab1.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">auto</span> kv = std::<span class="built_in">move</span>(*it);</span><br><span class="line">            tab2.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(kv));</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_extract_with_hint</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">auto</span> hint = tab2.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next_it = it;</span><br><span class="line">            ++next_it;</span><br><span class="line">            <span class="keyword">auto</span> node = tab1.<span class="built_in">extract</span>(it);</span><br><span class="line">            hint = tab2.<span class="built_in">insert</span>(hint, std::<span class="built_in">move</span>(node));</span><br><span class="line">            it = next_it;</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cond</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter_with_erase_with_hint</span><span class="params">(map&lt;K, V&gt; &amp;tab1, map&lt;K, V&gt; &amp;tab2, Cond &amp;&amp;cond)</span> </span>&#123;</span><br><span class="line">    DefScopeProfiler;</span><br><span class="line">    <span class="keyword">auto</span> hint = tab2.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tab1.<span class="built_in">begin</span>(); it != tab1.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cond</span>(it-&gt;first)) &#123;</span><br><span class="line">            it = tab1.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">auto</span> kv = std::<span class="built_in">move</span>(*it);</span><br><span class="line">            hint = tab2.<span class="built_in">insert</span>(hint, std::<span class="built_in">move</span>(kv));</span><br><span class="line">        &#125; <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>extract vs erase 性能测试结果 (testextractvserase.cpp)：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">avg</span>   <span class="string">|</span>   <span class="string">min</span>   <span class="string">|</span>   <span class="string">max</span>   <span class="string">|</span>  <span class="string">total</span>  <span class="string">|</span> <span class="string">cnt</span> <span class="string">|</span> <span class="string">tag</span></span><br><span class="line">   <span class="number">889</span><span class="string">|</span>      <span class="number">803</span><span class="string">|</span>     <span class="number">2388</span><span class="string">|</span>   <span class="number">889271</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_erase</span></span><br><span class="line">   <span class="number">642</span><span class="string">|</span>      <span class="number">595</span><span class="string">|</span>     <span class="number">1238</span><span class="string">|</span>   <span class="number">642542</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_extract</span></span><br><span class="line">   <span class="number">525</span><span class="string">|</span>      <span class="number">491</span><span class="string">|</span>     <span class="number">1398</span><span class="string">|</span>   <span class="number">525137</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_erase_with_hint</span></span><br><span class="line">   <span class="number">305</span><span class="string">|</span>      <span class="number">289</span><span class="string">|</span>      <span class="number">842</span><span class="string">|</span>   <span class="number">305472</span><span class="string">|</span> <span class="number">1000</span><span class="string">|</span> <span class="string">filter_with_extract_with_hint</span></span><br></pre></td></tr></table></figure>

<p>extract + 带提示的 insert 获胜，即函数 <code>filter_with_extract_with_hint</code> 是性能最好的那一个。</p>
<h3 id="游离节点可以修改键值"><a href="#游离节点可以修改键值" class="headerlink" title="游离节点可以修改键值"></a>游离节点可以修改键值</h3><p>由于处于游离状态，游离节点不属于任何 map 中，不需要满足排序性质，因此 <code>node.key()</code> 可修改。</p>
<p>先用 extract 取出游离态节点，修改完节点的键后再重新插入，利用这一点做到以前做不到的修改键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(<span class="string">&quot;fuck&quot;</span>);  <span class="comment">// 移出 &quot;fuck&quot; 键对应的节点，此时 m 会变为空</span></span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;fxxk&quot;</span>;  <span class="comment">// 修改键（以前用迭代器时 it-&gt;first 是不允许修改键的，因为迭代器指向的节点不是游离状态，修改键会破坏排序）</span></span><br><span class="line">node.<span class="built_in">mapped</span>() = <span class="number">211</span>;  <span class="comment">// 修改值（这个以前用迭代器时 it-&gt;second 也可以修改）</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">move</span>(node)); <span class="comment">// 把修改好的节点插入回去</span></span><br><span class="line"><span class="built_in">print</span>(m);             <span class="comment">// &#123;&#123;&quot;fxxk&quot;: 211&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>相当于你给小学生排队时，有一个小学生突然瞬间不知道吃了什么激素长高了，你的队伍就会乱掉。</p>
<p>所以需要让这个小学生先出列，让他单独一个人长高，等他长高完了再插入回队列。</p>
<h3 id="带提示的节点版-insert"><a href="#带提示的节点版-insert" class="headerlink" title="带提示的节点版 insert"></a>带提示的节点版 insert</h3><p>但是小学生长高的量可能是有限的（新的键可能和老键很接近）。</p>
<p>这时插入可以优先从他长高之前的位置开始二分法，也就是用 extract 之前，这个小学生后一位同学的位置，作为 insert 的提示，让 insert 更快定位到这个小学生应该插入的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(it != m.<span class="built_in">end</span>()); <span class="comment">// 假定 &quot;fuck&quot; 必须存在（如果不存在会返回 end）</span></span><br><span class="line"><span class="keyword">auto</span> next_it = std::<span class="built_in">next</span>(it); <span class="comment">// 下一位同学（可能会得到 end，但没关系，因为 insert 的提示也允许为 end 迭代器）</span></span><br><span class="line"><span class="keyword">auto</span> node = m.<span class="built_in">extract</span>(it);</span><br><span class="line">node.<span class="built_in">key</span>() = <span class="string">&quot;fxxk&quot;</span>;   <span class="comment">// 修改键值，变化不大</span></span><br><span class="line">m.<span class="built_in">insert</span>(next_it, <span class="built_in">move</span>(node)); <span class="comment">// 如果键值变动不大，优先尝试在老位置插入</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>std::next(it)</code> 对于等价于 it + 1。但是 map 属于双向迭代器（而不是随机迭代器），不支持加法操作，只支持就地 ++。所以 <code>std::next</code> 内部等价于：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">next</span><span class="params">(<span class="keyword">auto</span> it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> next_it = it; <span class="comment">// 先拷贝一份，防止原迭代器被破坏（迭代器都支持拷贝，性质上是浅拷贝）</span></span><br><span class="line">    ++next_it;         <span class="comment">// 再让 next_it 就地自增到下一位</span></span><br><span class="line">    <span class="keyword">return</span> next_it;    <span class="comment">// 返回现在已经相当于 it + 1 的 next_it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果键不变，或者键变了以后，插入位置不变的话，那么这次 insert 可以低至 O(1)O(1) 复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;dick&quot;</span>, <span class="number">211</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;fuck&quot;</span>, <span class="number">985</span>&#125;, <span class="comment">// &quot;fuck&quot; -&gt; &quot;fxxk&quot; 后，重新插入，其依字典序的“大小”依然是介于 &quot;dick&quot; 和 &quot;suck&quot;</span></span><br><span class="line">    &#123;<span class="string">&quot;suck&quot;</span>, <span class="number">996</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="merge：map-的合并操作（并集）"><a href="#merge：map-的合并操作（并集）" class="headerlink" title="merge：map 的合并操作（并集）"></a>merge：map 的合并操作（并集）</h3><p>C++17 新增的 merge 函数<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Cmp2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(map&lt;K, V, Cmp2&gt; &amp;__source)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：set 也有 merge 函数</p>
</blockquote>
<p>注意到 merge 的参数是另一个 map，可变引用，必须和本 map 同类型（这是为了保证节点句柄类型相同），但允许有不同的比较函数</p>
<ul>
<li><code>merge(source)</code> 会把 source 中的所有节点都<strong>移动</strong>并合并到本 map，注意是<strong>移动</strong>而不是拷贝，source 将会被清空，这样是为了更高效。</li>
<li><code>insert(source.begin(), source.end())</code> 则是把 source 里的元素拷贝后插入到本 map，更低效，因为需要拷贝，还得新建红黑树节点，额外分配内存空间。</li>
</ul>
<p>对于键存在冲突的情况：</p>
<ul>
<li>merge: 如果 source 中有与本 map 重复的键，则该元素不会被移动，保留在 source 里。</li>
<li>insert: 如果 source 中有与本 map 重复的键，则该元素不会被插入本 map。无论有没有插入本 map，原 source 中的键都不会被清除。</li>
</ul>
<blockquote>
<p>因此，merge 也并不总是完全清空 source，当 source 和本 map 有冲突时，冲突的键就保留在 source 里了。</p>
</blockquote>
<p>merge 等价于以下手动用 extract 和 insert 来移动节点的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.merge(m2) 等价于：</span></span><br><span class="line"><span class="keyword">auto</span> hint = m1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m2.<span class="built_in">begin</span>(); it != m2.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!m1.<span class="built_in">contains</span>(it-&gt;first)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = m2.<span class="built_in">extract</span>(it);</span><br><span class="line">        hint = m1.<span class="built_in">insert</span>(hint, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量-insert-vs-merge"><a href="#批量-insert-vs-merge" class="headerlink" title="批量 insert vs merge"></a>批量 insert vs merge</h4><p>同样做到两个 map 合并，<code>m1.merge(m2)</code> 与 <code>m1.insert(m2.begin(), m2.end())</code> 性能比较：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;benchmark/benchmark.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_Insert</span><span class="params">(benchmark::State &amp;state)</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m1_init;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m2_init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">range</span>(<span class="number">0</span>); i++) &#123;</span><br><span class="line">        m1_init[<span class="built_in">to_string</span>(i)] = i;</span><br><span class="line">        m2_init[<span class="built_in">to_string</span>(i + state.<span class="built_in">range</span>(<span class="number">0</span>))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">auto</span> m1 = m1_init;</span><br><span class="line">        <span class="keyword">auto</span> m2 = m2_init;</span><br><span class="line">        m2.<span class="built_in">insert</span>(m1.<span class="built_in">begin</span>(), m1.<span class="built_in">end</span>());</span><br><span class="line">        benchmark::<span class="built_in">DoNotOptimize</span>(m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_Insert)-&gt;<span class="built_in">Arg</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_Merge</span><span class="params">(benchmark::State &amp;state)</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m1_init;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m2_init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">range</span>(<span class="number">0</span>); i++) &#123;</span><br><span class="line">        m1_init[<span class="built_in">to_string</span>(i)] = i;</span><br><span class="line">        m2_init[<span class="built_in">to_string</span>(i + state.<span class="built_in">range</span>(<span class="number">0</span>))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">auto</span> m1 = m1_init;</span><br><span class="line">        <span class="keyword">auto</span> m2 = m2_init;</span><br><span class="line">        m2.<span class="built_in">merge</span>(m1);</span><br><span class="line">        benchmark::<span class="built_in">DoNotOptimize</span>(m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_Merge)-&gt;<span class="built_in">Arg</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>merge 函数不会产生不必要的内存分配导致内存碎片化，所以更高效。但作为代价，他会清空 m2！</p>
<ul>
<li>merge 相当于把 m2 的元素“移动”到 m1 中去了。</li>
<li>insert 则是把 m2 的元素“拷贝”了一份插入到 m1 中去，效率自然低下。</li>
</ul>
<p>如果不想破坏掉 m2，或者你用不上 C++17，则仍需要传统的 insert。</p>
<h4 id="merge-和-insert-一样不覆盖旧值"><a href="#merge-和-insert-一样不覆盖旧值" class="headerlink" title="merge 和 insert 一样不覆盖旧值"></a>merge 和 insert 一样不覆盖旧值</h4><p>merge(m2) 和 insert(m2.begin(), m2.end()) 一样尿性：如果 m2 中的键在 m1 中已经存在，则不会 extract 该 m2 中的节点，仍然留在 m2 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; ma &#123;&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;pear&quot;</span>&#125;, &#123;<span class="number">10</span>, <span class="string">&quot;banana&quot;</span>&#125;&#125;;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; mb &#123;&#123;<span class="number">2</span>, <span class="string">&quot;zorro&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;batman&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;X&quot;</span>&#125;, &#123;<span class="number">8</span>, <span class="string">&quot;alpaca&quot;</span>&#125;&#125;;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::string&gt; u;</span><br><span class="line">  u.<span class="built_in">merge</span>(ma);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ma.size(): &quot;</span> &lt;&lt; ma.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  u.<span class="built_in">merge</span>(mb);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mb.size(): &quot;</span> &lt;&lt; mb.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mb.at(5): &quot;</span> &lt;&lt; mb.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="type">const</span> &amp;kv: u)</span><br><span class="line">    std::cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-自定义比较器"><a href="#map-自定义比较器" class="headerlink" title="map 自定义比较器"></a>map 自定义比较器</h2><p>map 容器的全部参数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, Cmp, Alloc&gt;</span><br></pre></td></tr></table></figure>

<p>其中第 3、4 个参数 Cmp 和 Alloc 可以省略。</p>
<ul>
<li>Cmp 默认为 <code>std::less&lt;K&gt;</code></li>
<li>Alloc 默认为 <code>std::allocator&lt;std::pair&lt;K, V&gt;&gt;</code></li>
</ul>
<p>因此 <code>map&lt;K, V&gt;</code> 的完整模板参数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;, std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以简写成 <code>map&lt;K, V&gt;</code>。</p>
<p>其中 allocator 我们以后专门开一节课讲，其他很多容器都有 allocator。</p>
<p>今天只研究 Cmp 这个参数，他决定了 map 如何排序，判断相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这个 <code>std::less</code> 是个什么呢？是一个仿函数(functor)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;x, T <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具有成员函数 <code>operator()</code> 的类型，都被称之为仿函数。</p>
<h3 id="std-less-的作用"><a href="#std-less-的作用" class="headerlink" title="std::less 的作用"></a><code>std::less</code> 的作用</h3><p>仿函数对象，可以直接用圆括号当做普通函数调用，这就是“仿函数”的得名原因，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="type">int</span>&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line">less&lt;string&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>));   <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br><span class="line">less&lt;string_view&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>));   <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure>

<h4 id="operator"><a href="#operator" class="headerlink" title="operator()"></a><code>operator()</code></h4><p>注意仿函数的成员函数 <code>operator()</code> 是两个括号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">operator</span>()(...)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个括号是 <code>operator()</code> 的一部分，表示这是对圆括号 <code>()</code> 的运算符重载。</li>
<li>第二个括号是函数的参数列表，里面是 <code>operator()</code> 这个函数的形参。</li>
</ul>
<blockquote>
<p><code>operator()</code> 相当于 Python 中的 <code>__call__</code>。正如 <code>operator&lt;</code> 相当于 Python 中的 <code>__lt__</code>。这里 <code>operator</code> 和 <code>()</code> 是一个整体，连在一起，形成了一个标识符。</p>
</blockquote>
<h3 id="自定义排序方式"><a href="#自定义排序方式" class="headerlink" title="自定义排序方式"></a>自定义排序方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V, std::less&lt;K&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>我们之前提到 map 内部的元素始终按照键 K 从小到大的顺序排列。</p>
<p>map 决定大小顺序的，并不是直接调用 K 类型的比较运算符 <code>operator&lt;</code>。</p>
<p>而是调用他的模板参数 Cmp 类型的 <code>operator()</code>。</p>
<p>这是为了允许用户通过修改这个参数，控制 map 内部的行为，防止 map 数据结构与具体的比较方法耦合。</p>
<p>由于默认的 Cmp 是 <code>less&lt;K&gt;</code>，调用 <code>Cmp()(x, y)</code> 就相当于 <code>x &lt; y</code>，由此实现从小到大排序。</p>
<p>接下来我们将修改这一默认行为。</p>
<h4 id="只需要小于号"><a href="#只需要小于号" class="headerlink" title="只需要小于号"></a>只需要小于号</h4><p>一个类型要想作为 map 的键，只需要他支持 <code>&lt;</code> 运算符即可，不必定义其他 <code>&gt;</code>、<code>==</code> 运算符。</p>
<p>当 map 需要判断两个键是否相等时 <code>x == y</code>，会用 <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> 来等价地计算。</p>
<p>string, string_view, int, float, void *, shared_ptr, pair, tuple, array…</p>
<p>这些类型都支持比较运算符，都可以作为 map 的键。</p>
<h3 id="自定义小于号的三种方式"><a href="#自定义小于号的三种方式" class="headerlink" title="自定义小于号的三种方式"></a>自定义小于号的三种方式</h3><p>如果你写了个自定义类 Student，要让他作为 map 的键类型，有三种方法：</p>
<p>一、在 Student 类中添加 <code>operator&lt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Student <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)));</span><br><span class="line">        <span class="comment">// 等价于：</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex); <span class="comment">// tuple 实现了正确的 operator&lt; 运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<p>二、特化 <code>less&lt;Student&gt;</code>，添加 <code>operator()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;Student&gt; &#123;  <span class="comment">// 用户可以特化标准库中的 trait</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：以后如果 map 外面要用用到这个类的大小比较，也只能用 <code>less&lt;Student&gt;()(stu1, stu2)</code> 代替 <code>stu1 &lt; stu2</code>。</p>
</blockquote>
<p>三、重新自定义一个仿函数类 <code>LessStudent</code>，添加 <code>operator()</code>，然后把这个 <code>LessStudent</code> 作为 map 的比较器传入模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x.name, x.id, y.sex) &lt; std::<span class="built_in">tie</span>(x.name, x.id, y.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Student, <span class="type">int</span>, LessStudent&gt; stutab;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：以后每次创建新的 map 时，都需要加一个 LessStudent 参数。</p>
</blockquote>
<h3 id="自定义按哪个字段来索引"><a href="#自定义按哪个字段来索引" class="headerlink" title="自定义按哪个字段来索引"></a>自定义按哪个字段来索引</h3><p>如果希望 map 在查找时只根据学生姓名索引，则只需要改一下比较器的实现，让他只比较姓名字段即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LessStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这样的比较器，map 会认为姓名 name 相同的 Student 就是相等的，并去重。即使 id 和 sex 不同，只要名字相等就会视为重复，利用这一点可以实现针对特定字段的去重。</p>
<blockquote>
<p>结论：map 的排序和去重，都取决于于你的比较器如何实现！比较器里没比较的字段，就会被忽略而不参与排序、索引、和去重。</p>
</blockquote>
<h3 id="C-20-三路运算符"><a href="#C-20-三路运算符" class="headerlink" title="C++20 三路运算符 &lt;=&gt;"></a>C++20 三路运算符 <code>&lt;=&gt;</code></h3><p>四（同一）、利用 C++20 新特性，三路比较运算符 <code>&lt;=&gt;</code>：如果自定义类的每个成员都支持比较运算符，可以把 <code>operator&lt;=&gt;</code> 函数声明为 <code>default</code>，然后编译器会自动添加自定义类的所有比较运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(Student <span class="type">const</span> &amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时默认的 <code>operator&lt;</code> 实现等价于 <code>x.name &lt; y.name || (x.name == y.name &amp;&amp; (x.id &lt; y.id || (x.id == y.id &amp;&amp; x.sex &lt; y.sex)))</code>。</p>
<blockquote>
<p><code>&lt;=&gt;</code> 的返回类型是 <code>std::strong_ordering</code>，这是一种有三种取值的强枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;=&gt;` 对应的仿函数为 `std::compare_three_way</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="仿函数运算符全家桶"><a href="#仿函数运算符全家桶" class="headerlink" title="仿函数运算符全家桶"></a>仿函数运算符全家桶</h3><p>libstdc++ 头文件中的 less 和 greater 实现参考：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">  <span class="type">bool</span></span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">  <span class="type">bool</span></span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似的运算符仿函数还有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>仿函数类</th>
</tr>
</thead>
<tbody><tr>
<td>x &#x3D;&#x3D; y</td>
<td>std::equal_to</td>
</tr>
<tr>
<td>x !&#x3D; y</td>
<td>std::not_equal_to</td>
</tr>
<tr>
<td>x &lt; y</td>
<td>std::less</td>
</tr>
<tr>
<td>x &gt; y</td>
<td>std::greater</td>
</tr>
<tr>
<td>x &lt;&#x3D; y</td>
<td>std::less_equal</td>
</tr>
<tr>
<td>x &gt;&#x3D; y</td>
<td>std::greater_equal</td>
</tr>
<tr>
<td>x + y</td>
<td>std::plus</td>
</tr>
<tr>
<td>x - y</td>
<td>std::minus</td>
</tr>
<tr>
<td>x * y</td>
<td>std::multiplies</td>
</tr>
<tr>
<td>x &#x2F; y</td>
<td>std::divides</td>
</tr>
<tr>
<td>x % y</td>
<td>std::modulus</td>
</tr>
<tr>
<td>-x</td>
<td>std::negate</td>
</tr>
</tbody></table>
<p>他们都在 <code>#include &lt;functional&gt;</code> 头文件中定义。</p>
<h3 id="greater-实现反向排序"><a href="#greater-实现反向排序" class="headerlink" title="greater 实现反向排序"></a>greater 实现反向排序</h3><p>案例：使用 greater 仿函数，让 map 反过来从大到小排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ilist = &#123;</span><br><span class="line">    &#123;<span class="number">985</span>, <span class="string">&quot;拳打&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">211</span>, <span class="string">&quot;脚踢&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m1 = ilist;                <span class="comment">// 从小到大排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, string, greater&lt;<span class="type">int</span>&gt;&gt; m2 = ilist;  <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">print</span>(m1); <span class="comment">// &#123;&#123;211, &quot;脚踢&quot;&#125;, &#123;985, &quot;拳打&quot;&#125;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(m2); <span class="comment">// &#123;&#123;985, &quot;拳打&quot;&#125;, &#123;211, &quot;脚踢&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="大小写不敏感的字符串比较器"><a href="#大小写不敏感的字符串比较器" class="headerlink" title="大小写不敏感的字符串比较器"></a>大小写不敏感的字符串比较器</h3><p>自定义比较仿函数，实现无视键大小写的 map 容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LessIgnoreCase</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::lexicographical_compare <span class="comment">// 位于 &lt;algorithm&gt; 头文件，和 std::string 同款的字典序比较</span></span><br><span class="line">        ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">        , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">        , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, string, LessIgnoreCase&gt; m = &#123;</span><br><span class="line">        &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;STUdy&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span><br><span class="line">        &#123;&#123;<span class="string">&quot;stUDy&quot;</span>&#125;, <span class="string">&quot;js&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print</span>(m);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fuck对应的值为:&quot;</span>, m.<span class="built_in">at</span>(<span class="string">&quot;fuck&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;Fuck&quot;</span>: <span class="string">&quot;rust&quot;</span>, <span class="string">&quot;STUdy&quot;</span>: <span class="string">&quot;cpp&quot;</span>&#125;</span><br><span class="line">fuck对应的值为: <span class="string">&quot;rust&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="传入-lambda-做比较器"><a href="#传入-lambda-做比较器" class="headerlink" title="传入 lambda 做比较器"></a>传入 lambda 做比较器</h3><p>C++11 的 lambda 表达式也是仿函数，配合 decltype 后就可以传入 map 作为比较器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">lexicographical_compare</span></span><br><span class="line">    ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">    , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">    , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, string, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;&#123;<span class="string">&quot;Study&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;, cmp)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(&#123;<span class="string">&quot;fuck&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(val);</span><br></pre></td></tr></table></figure>

<p>写的更清晰一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (std::string <span class="type">const</span> &amp;lhs, std::string <span class="type">const</span> &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">lexicographical_compare</span></span><br><span class="line">    ( lhs.<span class="built_in">begin</span>(), lhs.<span class="built_in">end</span>()</span><br><span class="line">    , rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()</span><br><span class="line">    , [] (<span class="type">char</span> lhs, <span class="type">char</span> rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">toupper</span>(lhs) &lt; std::<span class="built_in">toupper</span>(rhs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;string, string, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(cmp)</span></span>;</span><br><span class="line">m = &#123;</span><br><span class="line">    &#123;&#123;<span class="string">&quot;Fuck&quot;</span>&#125;, <span class="string">&quot;rust&quot;</span>&#125;,</span><br><span class="line">    &#123;&#123;<span class="string">&quot;fUCK&quot;</span>&#125;, <span class="string">&quot;java&quot;</span>&#125;,</span><br><span class="line">    &#123;&#123;<span class="string">&quot;Study&quot;</span>&#125;, <span class="string">&quot;cpp&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(m);</span><br><span class="line"><span class="keyword">auto</span> val = m.<span class="built_in">at</span>(&#123;<span class="string">&quot;fuck&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(val);</span><br></pre></td></tr></table></figure>

<h4 id="map-构造函数是如何传入比较器的"><a href="#map-构造函数是如何传入比较器的" class="headerlink" title="map 构造函数是如何传入比较器的"></a>map 构造函数是如何传入比较器的</h4><p>刚刚用到的两个 map 构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span> = std::less&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map &#123;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">map</span>(Cmp cmp);</span><br><span class="line">    <span class="built_in">map</span>(initializer_list&lt;pair&lt;K, V&gt;&gt; ilist, Cmp cmp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基本每个 map 的构造函数都有一个提供额外 cmp 参数的版本，统一都是在最后一个参数后面追加。</p>
<h4 id="有状态（捕获变量）的比较器"><a href="#有状态（捕获变量）的比较器" class="headerlink" title="有状态（捕获变量）的比较器"></a>有状态（捕获变量）的比较器</h4><p>传入的仿函数 cmp 甚至可以捕获其他变量，这种捕获了变量的仿函数称之为有状态仿函数 - stateful functor，和无状态仿函数 - stateless functor 相对：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [&amp;] (<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[i] &lt; arr[j];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">m</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用有状态仿函数可以实现 argsort 等操作，例如上面代码就是根据在 arr 里对应索引的值来排序。</p>
<blockquote>
<p>由于 map 需要比较仿函数为纯函数(pure function)，在上面例子中，请保证 map 存在期间 arr 的内容不发生变化，否则 map 基于排序的二分查找功能会得到错误的结果。</p>
</blockquote>
<p>传入比较器仿函数是设计模式中典型的策略模式，通过依赖注入，允许我们控制 map 内部的行为。</p>
<h4 id="建议用-function"><a href="#建议用-function" class="headerlink" title="建议用 function"></a>建议用 function</h4><p>如果嫌 decltype 麻烦（难以在全局或类内部用），function 容器作为比较运算符，就可以统一了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [] (<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; m;</span><br></pre></td></tr></table></figure>

<p>稍后还可以通过 <code>key_comp()</code> 获取到用于键比较的仿函数，这个就是你刚刚传入的 cmp 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">key_comp</span>()(<span class="number">1</span>, <span class="number">2</span>);              <span class="comment">// 等价于 cmp(1, 2)</span></span><br></pre></td></tr></table></figure>

<p><code>value_comp()</code> 获取到用于元素（键-值对）比较的仿函数（他帮你适配参数类型了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">value_comp</span>()(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;);  <span class="comment">// 等价于 cmp(1, 2)</span></span><br></pre></td></tr></table></figure>

<h2 id="透明-map"><a href="#透明-map" class="headerlink" title="透明 map"></a>透明 map</h2><h3 id="什么是透明仿函数"><a href="#什么是透明仿函数" class="headerlink" title="什么是透明仿函数"></a>什么是透明仿函数</h3><p>C++14 新增了“透明(transparent)”运算符仿函数。</p>
<p>对于 less、greater 这类标准库提供的仿函数，指定模板参数为 void 即可让一个运算符仿函数变成“透明”的。例如对 less 而言，他的透明版就是 <code>less&lt;void&gt;</code>。</p>
<p>C++14 之前用的都是“不透明”版的仿函数，必须指定一个具体的类型，例如 <code>less&lt;int&gt;</code> 就只能用于 int 类型的比较，<code>less&lt;string&gt;</code> 就只能用于 string 类型的比较。</p>
<p>无法用 <code>less&lt;int&gt;</code> 仿函数比较 string 类型。</p>
<p>而 <code>less&lt;void&gt;</code> 是通用的，他的 <code>operator()</code> 函数是泛型的，可以接受任意类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span>&lt;<span class="type">void</span>&gt; &#123;   <span class="comment">// 针对 void 的特化</span></span><br><span class="line">    <span class="comment">// 标准委员会想：由于 void 类型不可能有 &lt; 运算符的需求，所以他们干脆拿 void 作为透明版的模板参数“占位符”了</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tx</span>, <span class="keyword">class</span> <span class="title class_">Ty</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">operator</span><span class="params">()</span><span class="params">(Tx &amp;&amp;x, Ty &amp;&amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forward&lt;Tx&gt;(x) &lt; forward&lt;Ty&gt;(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">is_transparent</span>;  <span class="comment">// 空类，仅供 SFINAE 元编程时检测一个仿函数是否透明时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://142857.red/book/img/question.png" alt="img"> 我的思考：不透明版的 <code>less&lt;T&gt;</code> 泛型体现在类的模板参数上，而透明版的体现在了成员函数 <code>operator()</code> 的模板参数上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://142857.red/book/img/bulb.png" alt="img"> 这里用 <code>void</code> 特化只是一个偷懒，<code>void</code> 并没有什么特殊的，实际上应该单独定义一个没有模板的 <code>transparent_less</code> 类，但他们就是懒得引入新标识符。</p>
</blockquote>
<h3 id="为什么需要透明仿函数"><a href="#为什么需要透明仿函数" class="headerlink" title="为什么需要透明仿函数"></a>为什么需要透明仿函数</h3><p>“透明”版的好处是可以同一个兼容任意类型，而不必创建多个 cmp 对象。而不透明版的好处是方便特化 traits，但毕竟 &lt; 运算符是可以用户自定义(运算符重载)的，没必要用 traits 特化，所以他们逐步发现透明版香了，还能支持左右参数为不同类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="type">void</span>&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>));  <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;cmake&quot;</span>), <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但也要特别注意不能再依赖参数类型自动的隐式转换了，必须至少写完整其中一个 <code>string(&quot;hello&quot;)</code> 才能触发 <code>string</code> 的 <code>operator&lt;</code> 而不是 <code>const char *</code> 的指针比大小。如果只写 <code>cmp(&quot;cmake&quot;, &quot;cppcon&quot;)</code> 则是在比较指针的地址大小，结果是不一定的。</p>
</blockquote>
<p>由于 C++14 的 less 模板参数 T 默认为 void，所以 <code>less&lt;void&gt;</code> 还可以简写成 <code>less&lt;&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">less&lt;&gt; cmp;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 1 &lt; 2: true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="number">5</span>, <span class="number">2</span>));  <span class="comment">// 5 &lt; 2: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>));  <span class="comment">// &quot;hello&quot; &lt; &quot;world&quot;: false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cmp</span>(<span class="built_in">string</span>(<span class="string">&quot;cmake&quot;</span>), <span class="string">&quot;cppcon&quot;</span>));  <span class="comment">// &quot;cmake&quot; &lt; &quot;cppcon&quot;: true</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型版的-find-函数"><a href="#泛型版的-find-函数" class="headerlink" title="泛型版的 find 函数"></a>泛型版的 find 函数</h3><p>普通 find 函数：键类型作为参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(K <span class="type">const</span> &amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++14 新增泛型版的 find 函数<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a>：任意类型作为参数，只要该类型支持与和键比大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(Kt &amp;&amp;k)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(Kt &amp;&amp;k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 Kt 是模板参数类型，可以接受任意类型，此处 <code>&amp;&amp;</code> 是万能引用不是右值引用。</p>
</blockquote>
<p>相同点：找到了就返回一个迭代器指向与该参数相等的元素，如果找不到还是返回 end()。</p>
<p>不同点：泛型版本的参数类型 Kt 不必和键类型 K 一致，只要 Kt 和 K 可以比较大小（&lt; 运算符）即可。</p>
<p>不仅</p>
<h3 id="泛型-find-的要求：透明"><a href="#泛型-find-的要求：透明" class="headerlink" title="泛型 find 的要求：透明"></a>泛型 find 的要求：透明</h3><p>要想用泛型版的 find 函数有一个条件：</p>
<p>map 的比较器必须是“透明(transparent)”的，也就是 <code>less&lt;void&gt;</code> 这种。否则泛型版的 <code>find(Kt &amp;&amp;)</code> 不会参与重载，也就是只能调用传统的 <code>find(K const &amp;)</code>。</p>
<p>但是 <code>map&lt;K, V&gt;</code> 默认的比较器是 <code>less&lt;K&gt;</code>，他是不透明的，比较的两边必须都是 <code>K</code> 类型。如果其中一边不是的话，就得先隐式转换为 <code>K</code> 才能用。</p>
<p>这是早期 C++98 设计的失败，当时他们没想到 <code>find</code> 还可以接受 <code>string_view</code> 和 <code>const char *</code> 这类可以和 <code>string</code> 比较，但构造会廉价得多的弱引用类型。</p>
<p>只好后来引入了透明比较器企图力挽狂澜，然而为了历史兼容，<code>map&lt;K, V&gt;</code> 默认仍然是 <code>map&lt;K, V, less&lt;K&gt;&gt;</code>。</p>
<p>如果我们同学的编译器支持 C++14，建议全部改用这种写法 <code>map&lt;K, V, less&lt;&gt;&gt;</code>，从而用上更高效的 find、at、erase、count、contains 等需要按键查找元素的函数。</p>
<h4 id="应用：字符串为键的字典"><a href="#应用：字符串为键的字典" class="headerlink" title="应用：字符串为键的字典"></a>应用：字符串为键的字典</h4><p>除非传入的刚好就是一个 <code>string</code> 的 const 引用，否则就会发生隐式构造 <code>string</code> 的操作。</p>
<p>如果传入的是一个 <code>string_view</code> 或 <code>const char *</code>，那么需要从他们构造出一个 <code>string</code>，然后才能传入传统的 <code>find(string const &amp;)</code> 函数。而 <code>string</code> 的构造会发生拷贝，且可能产生内存分配。</p>
<p>对于比较大的字符串做键值，每次查找都需要重新构造一个 <code>string</code> 对象，开销会比较大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; lut;</span><br><span class="line"></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="built_in">string</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>)); <span class="comment">// 隐式构造了一个 string，导致深拷贝了整个字符串！</span></span><br></pre></td></tr></table></figure>

<p>而启用了透明比较后，就不需要每次都拷贝整个字符串来构造 <code>string</code> 了。因为 find、at 这类函数会启用一个泛型的版本 <code>at(Kt &amp;&amp;)</code>，Kt 可以是任何类型，只要他支持与 <code>string</code> 比较。可以是 <code>const char *</code>，<code>string_view</code> 或另一个 <code>string</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>, less&lt;&gt;&gt; lut;</span><br><span class="line"></span><br><span class="line">lut.<span class="built_in">at</span>(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">lut.<span class="built_in">at</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="string">&quot;a-very-very-very-very-long-key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为不用拷贝了，更加高效，特别是对于键字符串非常长的情况。</p>
<p>at 内部也不会构造任何新的 <code>string</code>，他会拿着 <code>const char *</code> 和红黑树中的每个节点调用 <code>==</code> 比较。</p>
<blockquote>
<p><code>string == const char *</code> 是安全的，会比较字符串的内容而不是地址。</p>
</blockquote>
<h4 id="应用：智能指针为键的字典"><a href="#应用：智能指针为键的字典" class="headerlink" title="应用：智能指针为键的字典"></a>应用：智能指针为键的字典</h4><p>某有某些特殊情况下，我们需要把指针，甚至智能指针！放进 map 或 set 的键中，用于快速按指针的值查找到元素。（是的你没听错，是放在<strong>键类型</strong>里！）</p>
<blockquote>
<p>轶事：把指针放在键里并不罕见，常见的一个用法是 <code>set&lt;Node *&gt;</code>。好处是当 <code>Node</code> 析构时，他可以直接调用 <code>set.erase(this)</code> 把自己剔除掉。而普通的 <code>set&lt;Node&gt;</code> 就很难做到这一点了，你无法通过 Node 的 this 指针获得他在 set 中的迭代器，也无法知道自己位于哪个 set 中。侵入式红黑树完美解决了这一痛点，LLVM 和 Linux 内核中都大量运用了侵入式链表&#x2F;LRU&#x2F;红黑树，以后的高级数据结构课程中会为你讲解。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;Node *, <span class="type">int</span>&gt; lut;</span><br><span class="line"></span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr);</span><br></pre></td></tr></table></figure>

<p>如果是智能指针，就比较困难了，特别是 <code>unique_ptr</code>。如果你已知一个原始指针，想要在 map 中查找指向同样的智能指针键。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr); <span class="comment">// 错误：无法从 Node * 隐式构造 unique_ptr&lt;Node&gt;</span></span><br></pre></td></tr></table></figure>

<p>过去，人们不得不用一种称为 stale-ptr（变质指针）的黑科技，来构造一个不掌握生命周期的伪 unique_ptr 出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line"><span class="function">unique_ptr&lt;Node&gt; <span class="title">stale_ptr</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">// 一个并不掌握生命周期的“变质智能指针”</span></span><br><span class="line">lut.<span class="built_in">find</span>(stale_ptr); <span class="comment">// OK: 匹配到 find(unique_ptr&lt;Node&gt; const &amp;) 重载</span></span><br><span class="line">stale_ptr.<span class="built_in">release</span>(); <span class="comment">// 必须！否则会出现双重释放 (double-free) 错误</span></span><br></pre></td></tr></table></figure>

<p>而 C++14 中，我们只需定义一个透明的比较函数，支持 <code>Node *</code> 与 <code>unique_ptr&lt;Node&gt;</code> 互相比较即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">transparent_ptr_less</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *<span class="type">const</span> &amp;p1, T <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 &lt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *<span class="type">const</span> &amp;p1, unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 &lt; p2.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p1, T *<span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.<span class="built_in">get</span>() &lt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p1, unique_ptr&lt;T&gt; <span class="type">const</span> &amp;p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.<span class="built_in">get</span>() &lt; p2.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> is_transparent = std::true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;unique_ptr&lt;Node&gt;, <span class="type">int</span>, transparent_ptr_less&gt; lut;</span><br><span class="line">Node *raw_ptr = <span class="built_in">get_some_ptr</span>();</span><br><span class="line">lut.<span class="built_in">find</span>(raw_ptr); <span class="comment">// OK: 匹配到泛型的 find(Kt &amp;&amp;) 重载，其中 Kt 推导为 Node *const &amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用：超大对象为键的字典"><a href="#应用：超大对象为键的字典" class="headerlink" title="应用：超大对象为键的字典"></a>应用：超大对象为键的字典</h4><p>以下摘自 cppreference 上泛型 find 的官方案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FatKey</span>   &#123; <span class="type">int</span> x; <span class="type">int</span> data[<span class="number">1000</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LightKey</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="comment">// Note: as detailed above, the container must use std::less&lt;&gt; (or other </span></span><br><span class="line"><span class="comment">//   transparent Comparator) to access these overloads.</span></span><br><span class="line"><span class="comment">// This includes standard overloads, such as between std::string and std::string_view.</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> FatKey&amp; fk, <span class="type">const</span> LightKey&amp; lk) &#123; <span class="keyword">return</span> fk.x &lt; lk.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> LightKey&amp; lk, <span class="type">const</span> FatKey&amp; fk) &#123; <span class="keyword">return</span> lk.x &lt; fk.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> FatKey&amp; fk1, <span class="type">const</span> FatKey&amp; fk2) &#123; <span class="keyword">return</span> fk1.x &lt; fk2.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// transparent comparison demo</span></span><br><span class="line">    std::map&lt;FatKey, <span class="type">char</span>, std::less&lt;&gt;&gt; example = &#123;&#123;&#123;<span class="number">1</span>, &#123;&#125;&#125;, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;&#123;<span class="number">2</span>, &#123;&#125;&#125;, <span class="string">&#x27;b&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    LightKey lk = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> search = example.<span class="built_in">find</span>(lk); search != example.<span class="built_in">end</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; search-&gt;first.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Found <span class="number">2</span> b</span><br></pre></td></tr></table></figure>

<h2 id="神奇的-multimap"><a href="#神奇的-multimap" class="headerlink" title="神奇的 multimap"></a>神奇的 multimap</h2><p>允许重复键值的 multimap</p>
<p>map 中一个键对应一个值，而 multimap 一个键可以对应多个值。</p>
<ul>
<li>map：排序 + 去重；</li>
<li>multimap：只排序，不去重。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map&lt;K, V&gt; 的插入函数：</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;<span class="type">const</span> K, V&gt; &amp;&amp;kv)</span></span>;</span><br><span class="line"><span class="comment">// multimap&lt;K, V&gt; 的插入函数：</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; <span class="type">const</span> &amp;kv)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; &amp;&amp;kv)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为 multimap 允许重复键值，所以插入总是成功，与普通 map 相比不用返回 bool 表示是否成功了。</p>
<h3 id="元素的排列顺序"><a href="#元素的排列顺序" class="headerlink" title="元素的排列顺序"></a>元素的排列顺序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; tab;</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;silly&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;smart&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;lazy&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;fast&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;pig&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(tab);</span><br><span class="line">&#123;<span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;smart&quot;</span>, <span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;fast&quot;</span>, <span class="string">&quot;java&quot;</span>: <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;silly&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;trash&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;trash&quot;</span>, <span class="string">&quot;rust&quot;</span>: <span class="string">&quot;lazy&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>插入进 multimap 的重复键会紧挨着，他们之间的顺序取决于插入的顺序。例如上面键同样是 “cpp” 的两个元素，”smart” 先于 “fast” 插入，所以 “smart” 靠前了。</p>
<h3 id="用途：动态排序！"><a href="#用途：动态排序！" class="headerlink" title="用途：动态排序！"></a>用途：动态排序！</h3><p>multimap &#x2F; multiset 的作用通常就不是键值映射了，而是利用红黑树会保持元素有序的特性（任何二叉搜索树都这样）实现一边插入一边动态排序。</p>
<p>传统排序方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>multiset 排序方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;<span class="type">int</span>&gt; tab;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    tab.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需再排序，tab 中的键已经是有序的了！</span></span><br><span class="line"><span class="comment">// 如需取出到 vector:</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(tab.begin(), tab.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用 multimap 键-值对的特点，还能轻易实现只对键排序，值的部分不参与排序的效果。</p>
<p>multimap 排序的好处是：</p>
<ul>
<li>动态排序，在插入的过程中就保持整个红黑树的有序性，最后任何无需额外操作。</li>
<li>在一次次插入的过程中，每时每刻都是有序的，而不必等到最后才变得有序。</li>
<li>可以随时动态删除一个元素，同样不会破坏有序性。</li>
<li>还很方便随时按键值查找到和我相等的元素。</li>
<li>如果还额外需要去重，则只需改用普通 map</li>
</ul>
<p>普通 map 轻松实现去重 + 动态排序，如何处置重复的键随你决定：</p>
<ul>
<li>普通 map 的 insert 只接受第一次出现的键-值对。</li>
<li>普通 map 的 insert_or_assign 只保留最后一次出现的键-值对。</li>
</ul>
<h3 id="查询某个键对应的多个值"><a href="#查询某个键对应的多个值" class="headerlink" title="查询某个键对应的多个值"></a>查询某个键对应的多个值</h3><p>因为 multimap 中，一个键不再对于单个值了；所以 multimap 没有 <code>[]</code> 和 <code>at</code> 了，也没有 <code>insert_or_assign</code>（反正 <code>insert</code> 永远不会发生键冲突！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(K <span class="type">const</span> &amp;k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Kt</span>&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(Kt &amp;&amp;k)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要查询 multimap 中的一个键对应了哪些值，可以用 <code>equal_range</code> 获取一前一后两个迭代器，他们形成一个区间。这个区间内所有的元素都是同样的键。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; tab;</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;silly&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;trash&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;smart&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;lazy&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cpp&quot;</span>, <span class="string">&quot;fast&quot;</span>&#125;);</span><br><span class="line">tab.<span class="built_in">insert</span>(&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;pig&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> range = tab.<span class="built_in">equal_range</span>(<span class="string">&quot;cpp&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line">cpp smart</span><br><span class="line">cpp fast</span><br></pre></td></tr></table></figure>

<p><code>equal_range</code> 返回两个迭代器相等时（即区间大小为 0），就代表找不到该键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> range = tab.<span class="built_in">equal_range</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (range.first == range.second) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到该元素！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equal_range</code> 返回的两个迭代器，也可以用 <code>lower_bound</code> 和 <code>upper_bound</code> 分别获得：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin_it = tab.<span class="built_in">lower_bound</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> end_it = tab.<span class="built_in">upper_bound</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (begin_it == end_it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到该元素！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin_it; it != end_it; ++it) &#123;</span><br><span class="line">        <span class="built_in">print</span>(it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lower-upper-bound-实现范围查询"><a href="#lower-upper-bound-实现范围查询" class="headerlink" title="lower&#x2F;upper_bound 实现范围查询"></a>lower&#x2F;upper_bound 实现范围查询</h3><ul>
<li><code>lower_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于等于（&gt;&#x3D;）当前 key 的元素。</li>
<li><code>upper_bound(key)</code> 到 <code>end()</code> 迭代器之间的元素，都是大于（&gt;）当前 key 的元素。</li>
<li><code>begin()</code> 到 <code>lower_bound(key)</code> 迭代器之间的元素，都是小于（&lt;）当前 key 的元素。</li>
<li><code>begin()</code> 到 <code>upper_bound(key)</code> 迭代器之间的元素，都是小于等于（&lt;&#x3D;）当前 key 的元素。</li>
</ul>
<p>例如我要对一系列小彭友的成绩数据进行排序，要求查出大于等于 60 分的所有同学，发放“小红花”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Student&gt; students;</span><br></pre></td></tr></table></figure>

<p>就可以把成绩 int 作为键，学生名字作为值，插入 multimap。</p>
<p>插入的过程中 multimap 就自动为你动态排序了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, string&gt; sorted;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;stu: students) &#123;</span><br><span class="line">    sorted.<span class="built_in">insert</span>(&#123;stu.score, stu.name&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，要找出所有大于等于 60 分的同学，也就是 <code>lower_bound(60)</code> 到 <code>end()</code> 这个区间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where score &gt;= 60</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = sorted.<span class="built_in">lower_bound</span>(<span class="number">60</span>); it != sorted.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜 &#123;&#125; 同学，考出了 &#123;&#125; 分，奖励你一朵小红花&quot;</span>, it-&gt;second, it-&gt;first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找出 30（含）到 60（不含）分的同学也很容易：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where 30 &lt;= score and score &lt; 60</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = sorted.<span class="built_in">upper_bound</span>(<span class="number">30</span>); it != sorted.<span class="built_in">lower_bound</span>(<span class="number">60</span>); ++it) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; 同学考出了 &#123;&#125; 分，不要灰心！小彭老师奖励你一朵小黄花，表示黄牌警告&quot;</span>, it-&gt;second, it-&gt;first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度总结说明"><a href="#时间复杂度总结说明" class="headerlink" title="时间复杂度总结说明"></a>时间复杂度总结说明</h2><table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>m1 &#x3D; move(m2)</td>
<td>移动</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>m1 &#x3D; m2</td>
<td>拷贝</td>
<td>O(N)O(N)</td>
</tr>
<tr>
<td>swap(m1, m2)</td>
<td>交换</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>m.clear()</td>
<td>清空</td>
<td>O(N)O(N)</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>m.insert({key, val})</td>
<td>插入键值对</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.insert(pos, {key, val})</td>
<td>带提示的插入，如果位置提示准确</td>
<td>O(1)O(1)+</td>
</tr>
<tr>
<td>m.insert(pos, {key, val})</td>
<td>带提示的插入，如果位置提示不准确</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m[key] &#x3D; val</td>
<td>插入或覆盖</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.insert_or_assign(key, val)</td>
<td>插入或覆盖</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.insert({vals…})</td>
<td>设 M 为待插入元素（vals）的数量</td>
<td>O(MlogN)O(Mlog⁡N)</td>
</tr>
<tr>
<td>map m &#x3D;</td>
<td>如果 vals 无序</td>
<td>O(NlogN)O(Nlog⁡N)</td>
</tr>
<tr>
<td>map m &#x3D;</td>
<td>如果 vals 已事先从小到大排列</td>
<td>O(N)O(N)</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>m.at(key)</td>
<td>根据指定的键，查找元素，返回值的引用</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.find(key)</td>
<td>根据指定的键，查找元素，返回迭代器</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.count(key)</td>
<td>判断是否存在指定键元素，返回相同键的元素数量（只能为 0 或 1）</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>根据指定的键，确定上下界，返回区间</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.size()</td>
<td>map 中所有元素的数量</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>m.erase(key)</td>
<td>根据指定的键，删除元素</td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m.erase(it)</td>
<td>根据找到的迭代器，删除元素</td>
<td>O(1)+O(1)+</td>
</tr>
<tr>
<td>m.erase(beg, end)</td>
<td>批量删除区间内的元素，设该区间（beg 和 end 之间）有 M 个元素</td>
<td>O(M+logN)O(M+log⁡N)</td>
</tr>
<tr>
<td>erase_if(m, cond)</td>
<td>批量删除所有符合条件的元素</td>
<td>O(N)O(N)</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>函数或写法</th>
<th>解释说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>m.insert(node)</td>
<td></td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>node &#x3D; m.extract(it)</td>
<td></td>
<td>O(1)+O(1)+</td>
</tr>
<tr>
<td>node &#x3D; m.extract(key)</td>
<td></td>
<td>O(logN)O(log⁡N)</td>
</tr>
<tr>
<td>m1.merge(m2)</td>
<td>合并两个 map，清空 m2，结果写入 m1</td>
<td>O(NlogN)O(Nlog⁡N)</td>
</tr>
<tr>
<td>m1.insert(m2.begin(), m2.end())</td>
<td>合并两个 map，m2 保持不变，结果写入 m1</td>
<td>O(NlogN)O(Nlog⁡N)</td>
</tr>
</tbody></table>
<h2 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 unordered_map"></a>哈希表 unordered_map</h2><p>C++11 新增：基于哈希 (hash) 的映射表 unordered_map</p>
<h3 id="unordered-map-与-map-之争：适用场景不同"><a href="#unordered-map-与-map-之争：适用场景不同" class="headerlink" title="unordered_map 与 map 之争：适用场景不同"></a>unordered_map 与 map 之争：适用场景不同</h3><p>之前提到，map 底层基于红黑树，大多数操作的复杂度都是 O(logN)O(log⁡N) 级别的，其中部分按迭代器的插入和删除的复杂度可以降低到 O(1)O(1)。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/hash_map.png" class="" title="hash_map">

<p>而 unordered_map 则是基于哈希表的更高效查找，只需 O(1)O(1) 复杂度！他能实现如此高效查找得益于哈希函数可以把散列唯一定位到一个数组的下标中去，而数组的索引是 O(1)O(1) 的。缺点是哈希值可能产生冲突，而且哈希数组可能有空位没有填满，浪费一部分内存空间。总的来说哈希表在平均复杂度上（O(1)O(1)）比红黑树这类基于树的复杂度（O(logN)O(log⁡N)）更低，虽然固有延迟高，占用空间大，还容易被哈希冲突攻击。</p>
<ul>
<li>哈希表结构简单无脑，在巨量的键值对的存储时会发挥出明显的性能优势，常用于需要高吞吐量但不太在乎延迟的图形学应用。</li>
<li>而各种基于树的数据结构，复杂度更加稳定，看似适合小规模数据，但是因为保持有序的特性，非常适合数据库这种需要范围查询的情况，且有序性反而有利于缓存局域性，无序的哈希表难以胜任。</li>
<li>最近新提出的一种数据结构——跳表，也是有序的，但基于链表，更加高效，在 Redis 等软件中都有应用。别担心，小彭老师之后的数据结构课程会专门介绍并带你手搓所有这些！</li>
</ul>
<hr>
<h3 id="原理：unordered-map-中的“桶”"><a href="#原理：unordered-map-中的“桶”" class="headerlink" title="原理：unordered_map 中的“桶”"></a>原理：unordered_map 中的“桶”</h3><p>unordered_map 如何快速检索数据？高效的秘诀在于 unordered_map 内部是一个数组，一个由许多“桶”组成的数组。插入时把键值对存到键的 hash 对应编号的桶去，查询时就根据 hash 去线性地查找桶（这一操作是 O(1)O(1) 的）。</p>
<p>例如键为 “hello”，假设算出他的 hash 为 42。而当前桶的数量是 32 个，则会把 “hello” 存到 42 % 32 &#x3D; 10 号桶去。查询时，同样计算出 hash(“hello”) % 32 &#x3D; 10 号桶，然后就可以从 10 号桶取出 “hello” 对应的数据了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    array&lt;pair&lt;K, V&gt;, 32&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();  <span class="comment">// 计算出来的 hash 可能很大，取模可以防止 h &gt;= buckets.size()</span></span><br><span class="line">        buckets[h] = kv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">V &amp;<span class="title">at</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(k) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;kv = buckets[h];</span><br><span class="line">        <span class="keyword">if</span> (k != kv.first) <span class="keyword">throw</span> out_of_range&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="哈希冲突-hash-collision"><a href="#哈希冲突-hash-collision" class="headerlink" title="哈希冲突 (hash-collision)"></a>哈希冲突 (hash-collision)</h3><p>但是这里有一个问题，如果两个不同的字符串，刚好 hash 以后的模相同怎么办？这种现象称为 hash 冲突。</p>
<p>C++ 标准库的解决方案是采用链表法：一个桶不是单独的一个 K-V 对，而是数个 K-V 对组成的单链表（forward_list）。一个桶不是只存储一个数据，而是可以存储任意多个数据（0到∞个）。</p>
<p>插入时，找到对应的桶，并往链表的头部插入一个新的 K-V 对。查找时，先找到对应的桶，在这个桶里的链表里顺序遍历查找，由于第一步的桶查找是 O(1)O(1) 的，虽然最后还是链表暴力查找，但是已经被桶分摊了一个维度，因此查找的平均复杂度还是 O(1)+O(1)+ 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();  <span class="comment">// 计算 hash 的模（所在桶的编号）</span></span><br><span class="line">    buckets[h].<span class="built_in">push_front</span>(kv);                <span class="comment">// 单链表的头插，是最高效的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">hash</span>(k) % buckets.<span class="built_in">size</span>();         <span class="comment">// 计算 hash 的模（所在桶的编号）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv: buckets[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == kv.first)  <span class="comment">// 可能有多个不同的键刚好有相同的 hash 模，需要进一步判断键确实相等才能返回</span></span><br><span class="line">            <span class="keyword">return</span> kv.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> out_of_range&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这里还是有一个问题，hash 冲突时，对链表的暴力遍历查找复杂度是 O(N)O(N) 的，随着越来越多的元素被插入进来，32 个桶将会拥挤不堪。假设有 n 个元素，则平均每个桶都会有 n &#x2F; 32 个元素，需要 n &#x2F; 32 次遍历。所以元素数量充分大时 unordered_map 又会退化成暴力遍历的 O(N)O(N) 复杂度，满足不了我们用他加速查找的目的。</p>
<p>桶的数量相比元素的数量越是不足，越是拥挤，越是容易退化成链表。</p>
<p>因此 C++ 标准库规定，插入时，当检测到平均每个桶里都有 1 个元素时，也就是元素数量大于桶的数量时，就会发生自动扩容，一次性让桶的数量扩充 2 倍，并重新计算每个元素的 hash 模（桶编号）全部重新插入一遍。</p>
<blockquote>
<p>元素数量除以桶的数量被称为“负载率（load factor），对于链表法的哈希表 unordered_map 来说，负载率可以高于 1；对于线性地址法的 flat_hash_map 则最高为 1。C++ 标准库通常的 unordered_map 实现中，负载率高于 1 时，就会发生自动扩容。可以通过 <code>.load_factor()</code> 函数查询一个 unordered_map 的负载率。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;  <span class="comment">// 因为需要动态扩容，桶数组变成了动态数组 vector</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;  <span class="comment">// 记录当前容器共有多少个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> &gt; buckets.<span class="built_in">size</span>()) <span class="built_in">reserve</span>(n);  <span class="comment">// 如果插入后的元素数量大于桶的容量，则扩容</span></span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        buckets[h].<span class="built_in">push_front</span>(kv);</span><br><span class="line">        size++;     <span class="comment">// insert 时 size 自动加 1，erase 时也要记得减 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= buckets.<span class="built_in">size</span>()) <span class="keyword">return</span>;  <span class="comment">// 如果要求的大小已经满足，不需要扩容</span></span><br><span class="line">        buckets.<span class="built_in">resize</span>(<span class="built_in">max</span>(n, buckets.<span class="built_in">size</span>() * <span class="number">2</span>));  <span class="comment">// 把桶数组至少扩大 2 倍（避免重复扩容），至多扩到 n</span></span><br><span class="line">        此处省略 rehash 的具体实现  <span class="comment">// 桶的数量发生变化了，需要重新计算一遍所有元素 hash 的模，并重新插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个 key 所在的桶编号计算公式：bucket_index(key) &#x3D; hash(key) % bucket_count()</p>
</blockquote>
<p>还是存在问题，刚刚的 insert 根本没有检测要插入的键是否已经存在了。如果已经存在还插入，那就变成 unordered_multimap 了！我们是普通的需要去重的 unordered_map，所以插入时先需要遍历下链表检测一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">    vector&lt;forward_list&lt;pair&lt;K, V&gt;&gt;&gt; buckets;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(pair&lt;K, V&gt; &amp;kv)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;K, V&gt; kv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> &gt; buckets.<span class="built_in">size</span>()) <span class="built_in">reserve</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="type">size_t</span> h = <span class="built_in">hash</span>(kv.first) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv2: buckets[h]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kv.first == kv2.first)  <span class="comment">// 检测是否发生了冲突</span></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(kv2), <span class="literal">false</span>&#125;;  <span class="comment">// 发生冲突则返回指向已存在的键的迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">        buckets[h].<span class="built_in">push_front</span>(kv);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(buckets.<span class="built_in">front</span>()), <span class="literal">true</span>&#125;;  <span class="comment">// 没发生冲突则返回成功插入元素的迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map-与-map-的异同"><a href="#unordered-map-与-map-的异同" class="headerlink" title="unordered_map 与 map 的异同"></a>unordered_map 与 map 的异同</h2><p>用法上，unordered_map 基本与 map 相同，以下着重介绍他们的不同点。</p>
<h3 id="区别-1：有序性"><a href="#区别-1：有序性" class="headerlink" title="区别 1：有序性"></a>区别 1：有序性</h3><ul>
<li>map 基于红黑树，元素从小到大顺序排列，遍历时也是从小到大的，键类型需要支持比大小（std::less 或 &lt;）。</li>
<li>unordered_map 基于哈希散列表，里面元素顺序随机，键类型需要支持哈希值计算（std::hash）和判断相等（std::equal_to 或 &#x3D;&#x3D;）。</li>
</ul>
<p>map 中的元素始终保持有序，unordered_map 里面的元素是随机的。</p>
<p>这也意味着 std::set_union 这类要求输入区间有序的 algorithm 函数无法适用于 unordered_map&#x2F;set。</p>
<h4 id="hash-和-equal-to"><a href="#hash-和-equal-to" class="headerlink" title="hash 和 equal_to"></a>hash 和 equal_to</h4><p>map 只需要 K 类型支持一个 less 就能工作。</p>
<p>而 unordered_map 需要 K 支持的 trait 有两个：hash 和 equal_to。</p>
<p><code>unordered_map&lt;K, V&gt;</code> 的完整形态是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;K, V, hash&lt;K&gt;, equal_to&lt;K&gt;, allocator&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中 allocator 我们照例先跳过不讲，之后分配器专题课中会介绍。</li>
<li>hash 说的是，如何求键的哈希值？hash 仿函数接受一个 K 类型的键，返回一个 size_t（在 64 位系统上是个无符号 64 位整数，表示哈希值）。</li>
<li>equal_to 说的是，如何判断两个键相等？如果两个键完全相等，他会返回 true。</li>
</ul>
<p>这里对 hash 的实现只有一个要求，<strong>如果两个键相等，则他们的哈希必定也相等，反之则不一定</strong>。</p>
<p>这个假设构成了 unordered_map 得以高效的基石，他使得 unordered_map 可以更快排除不可能的答案，而不必像 vector 的查找那样需要去暴力遍历全部元素，只需要遍历哈希相等的那一部分元素就够了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp,</span><br><span class="line">   <span class="keyword">typename</span> _Hash = hash&lt;_Key&gt;,      <span class="comment">// 默认的哈希函数实现，支持了 int, void *, string 等类型</span></span><br><span class="line">   <span class="keyword">typename</span> _Pred = equal_to&lt;_Key&gt;,  <span class="comment">// 默认的 == 运算符</span></span><br><span class="line">   <span class="keyword">typename</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> _Key, _Tp&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map</span><br></pre></td></tr></table></figure>

<p>换言之，只要 unordered_map 发现两个键不相等，就不用再做具体值的比较了，他们不可能相等了！</p>
<h4 id="哈希函数的思想"><a href="#哈希函数的思想" class="headerlink" title="哈希函数的思想"></a>哈希函数的思想</h4><p>hash 返回的 size_t 这个整数可以理解为一个对任意类型的“摘要”。</p>
<p>把一个很复杂的类型（例如 string）压缩成一个 unordered_map 很轻易就能比较的 size_t 整数，整数比较起来就很容易，而且还能直接作为数组的下标（string 不能直接作为数组的下标）。</p>
<p>这种摘要的关键在于如何把一个极为复杂的类型“映射”到小小的 size_t 上去，并且分布得尽可能均匀，不要冲突。</p>
<p>这就需要我们把这个极为复杂类型的每个成员（对 string 而言就是每个字符）都加到最终结果的表达式中。</p>
<p>以字符串类型 string 为例，常见的一种生成“摘要”的方法是，用一个任意素数的乘方序列和各字符的 ASCII 码做点积：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash_string</span><span class="params">(string <span class="type">const</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">        h = h * <span class="number">37</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如对于字符串 “hello”，则 hash 可以生成这样一个摘要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> h = (((<span class="string">&#x27;h&#x27;</span> * <span class="number">37</span> + <span class="string">&#x27;e&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;o&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>相当于 h⋅374+e⋅373+l⋅372+l⋅37+oh⋅374+e⋅373+l⋅372+l⋅37+o</p>
<blockquote>
<p>也有其他更高效的生成摘要的方法，例如借助位运算。</p>
<p>甚至还有偷懒直接拿 strlen 当哈希函数的“世界上最好的哈希表”，我不说是谁。（其实是早期 PHP 啦）</p>
</blockquote>
<h4 id="自动取模"><a href="#自动取模" class="headerlink" title="自动取模"></a>自动取模</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> h = (((<span class="string">&#x27;h&#x27;</span> * <span class="number">37</span> + <span class="string">&#x27;e&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;l&#x27;</span>) * <span class="number">37</span> + <span class="string">&#x27;o&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>随着字符串长度的增加，这个 h 肯定会超过 size_t 的表示范围，但是没关系，无符号整数的乘法、加法溢出不是未定义行为，他会自动 wrapping（取关于 264264 的模），也就是只保留乘法结果和 2^64 取模的部分。</p>
<p>取模也是对哈希值常见的一个操作，反正哈希值是随机的，取模以后也是随机的，但是缩小了范围。</p>
<blockquote>
<p>基本假设：m 足够小时，一个均匀的分布取以 m 的模以后仍然应该是均匀的</p>
</blockquote>
<p>unordered_map 中桶的数量是有限的，为了把范围从 00 到 264−1264−1 的哈希值映射为 0 到 bucket_count - 1 的桶序号，他内部会把键的哈希值取以桶数量的模，作为一个键要存储到的桶的序号：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bucket_index</span> = hash(key) % bucket_count</span><br></pre></td></tr></table></figure>

<h3 id="hash-是个-trait-类"><a href="#hash-是个-trait-类" class="headerlink" title="hash 是个 trait 类"></a>hash 是个 trait 类</h3><p>std::hash 就是标准库用于计算哈希的仿函数类了，他和 std::less 一样，是一个 trait 类。</p>
<p>一些常见的类型有默认的实现，也可以针对自定义类型添加特化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;t)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 有待实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;  <span class="comment">// 对 int 的特化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;T *&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(t);  <span class="comment">// 对 T * 的偏特化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>std::hash 针对每个不同的类型做了特化，例如当我们需要计算 string 类型的 hash 时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> h = <span class="built_in">hash</span>&lt;string&gt;()(str);</span><br><span class="line"><span class="built_in">print</span>(str, <span class="string">&quot;的哈希是&quot;</span>, h);</span><br></pre></td></tr></table></figure>

<p>注意：这里有两个括号，第一个是空的。第一个括号创建仿函数对象，第二个用str作为实参调用仿函数的 <code>operator()</code>。当然还别忘了第一个尖括号，这个尖括号里的 string 表示的是 hash 仿函数接下来要接受参数的类型，之所以作为类的模板参数而不是模板函数，是为了方便特化和偏特化。同学们也可以自己写一个这样的函数，用起来就不用指定类型（如这里的 string）了，让模板函数自动推导参数类型（类似于 make_pair）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">do_hash</span><span class="params">(T <span class="type">const</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;T&gt;()(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="built_in">do_hash</span>(str);</span><br><span class="line">    <span class="built_in">print</span>(str, <span class="string">&quot;的哈希是&quot;</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;Hello, world&quot;</span> 的哈希是 <span class="number">14701251851404232991</span></span><br></pre></td></tr></table></figure>

<hr>
<p>对任意类型哈希的结果都是一个 size_t，其在 32 位系统上等同于 uint32_t，在我们 64 为系统上等同于 uint64_t。选择 size_t 是为了能哈希了以后直接用于 unordered_map 中桶的索引。</p>
<p>由于 hash 是用作哈希表的哈希函数，而不是用于加密领域（请你移步 md5），或是用于随机数生成（请移步 mt19937），因此对于任意类型，只需要根据他生成一个 size_t 的哈希值即可，只要保证哈希值分布均匀即可，不一定要有随机性。例如标准库对 int 的 hash 实现就是个恒等函数——直接返回其整数值，不用做任何计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;  <span class="comment">// 对 int 的特化真是什么也不做呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于任意指针的实现则是直接把指针 bit-cast 成 size_t：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;T *&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *t)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(t);  <span class="comment">// 指针强制转换为整数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(i);  <span class="comment">// 没想到罢！我系恒等函数哒</span></span><br><span class="line"><span class="built_in">print</span>(i, j);</span><br><span class="line"><span class="number">42</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>记住，std::hash 不是为了加密或随机而生的，他的功能仅仅是尽可能快速地把任意类型 T 映射到 size_t 而已。</p>
<p>至于这对 unordered_map 的性能有何影响？通常没有什么影响，除非输入键故意设为和 bucket_count 同模，毕竟反正你也无法断定输入键的排布模式，不论选什么哈希函数只要保证均匀都是可以的。而恒等函数刚好是均匀的，又不用额外的花里胡哨位运算浪费时间，反而可能因为键有序而提升了缓存局域性，提升了性能，所以各大厂商的标准库都是这么做的。</p>
<h3 id="区别-2：时间复杂度"><a href="#区别-2：时间复杂度" class="headerlink" title="区别 2：时间复杂度"></a>区别 2：时间复杂度</h3><ul>
<li>map 的查询和插入操作是 O(logN)O(log⁡N) 复杂度的。</li>
<li>unordered_map 的查询和插入操作是 O(1)+O(1)+ 复杂度的。</li>
</ul>
<p>看起来 unordered_map 更高效？那还要 map 干什么？完全上位替代啊？</p>
<p>但是我们要注意，上面所说的复杂度 O(1)O(1) 只是平均下来的，并不代表每一次 unordered_map 插入操作的复杂度都是 O(1)O(1)！所以，复杂度表示法里的这个 + 号就是这个意思，代表我这个复杂度只是多次运行取平均，如果只考虑单次最坏的情况，可能更高。</p>
<ul>
<li>map 的插入操作<strong>最坏</strong>也只是 O(logN)O(log⁡N) 复杂度的。</li>
<li>unordered_map 的插入操作<strong>最坏</strong>可以是 O(N)O(N) 复杂度的。</li>
</ul>
<p>处理很高的数据量时，这一点最坏的情况会被平摊掉，unordered_map 更高效。</p>
<h4 id="哈希表的复杂度不稳定"><a href="#哈希表的复杂度不稳定" class="headerlink" title="哈希表的复杂度不稳定"></a>哈希表的复杂度不稳定</h4><p>所以 unordered_map 不稳定，虽然平均是 O(1)O(1) 复杂度，但最坏可达到 O(N)O(N) 复杂度。背后的原因是什么呢？</p>
<p>原来 unordered_map 和 vector 一样，是一个需要不断动态扩容的容器。</p>
<p>如果不扩容，那么当很多元素挤在一个桶里，链表的压力就会变大，会很低效，因此 unordered_map 必须扩容。但是在扩容的时候是需要进行 rehash 操作的。一次扩容，就需要把所有的元素都移动一遍。</p>
<p>结果就是 unordered_map 的插入如果没触发 rehash，那就是 O(1)O(1) 的。触发了，那就是最坏的情况，O(N)O(N) 的。但是不触发的情况远多于触发了的，所以平均下来还是 O(1)O(1)，为了提醒人们他最坏的情况，所以写作 O(1)+O(1)+，读作“平摊 O1”（Amortized Constant）。</p>
<p>此外，不仅 unordered_map 的插入函数是 O(1)+O(1)+，他的查询函数也是 O(1)+O(1)+。为什么呢？设想你在编写一个富连网服务器，如果黑客已知你的 hash 函数，那他就可以通过构造一系列特殊设计好的 key，他们的哈希刚好相等（或同模），这样就使得所有 key 刚好全部落在一个桶里，导致 unordered_map 退化成线性的链表，所有的查询和插入都变成了这一个桶上的链表遍历操作，复杂度达到最坏的 O(N)O(N)，这一现象叫做 hash 退化。</p>
<p>因此 hash 函数的好坏决定着 unordered_map 性能，对于安全领域来说，还要保证 hash 函数无法被黑客破解。只要 hash 函数足够随机，就能保证键不冲突，就很快，一旦出现键冲突就会变慢。但需要频繁使用的 hash 函数计算难度又不能太大，那又会影响性能，因此 hash 也不能太过复杂。</p>
<blockquote>
<p>标准库里存在这种“平摊复杂度”的例子还有很多，例如 vector 的 push_back 不 reserve 的话，就是 O(1)+O(1)+ 的，因为他需要动态扩容。</p>
</blockquote>
<h4 id="哈希表的应用限制"><a href="#哈希表的应用限制" class="headerlink" title="哈希表的应用限制"></a>哈希表的应用限制</h4><p>一些实时性要求很高的领域就不能用 unordered_map。例如你造了个火箭，规定：火箭控制程序需要在 1000 μs 内对外界变化做出实时反应，如果不能及时做出反应，火箭就会做托马斯回旋给你看。</p>
<p>你在火箭控制程序中用了 unordered_map，这个程序会不断运行，以便控制火箭做出正确的机动，对抗侧向风干扰。第一次运行他在 180 μs 内反应了，第二次在 250 μs 内反应了，第三次 245 μs 内反应了，你觉得他很高效。</p>
<p>但是突然有一次，unordered_map 觉得他内部“桶太乱”了，急需重新扩容并 rehash 一下“忧化性能”。然后，他把所有的元素都移动了一遍，移动完了，把处理完的数据返回给火箭姿态调控系统，认为大功告成。但当他睁开眼睛一看，刚想要控制一下姿态呢？却发现自己已经在做托马斯回旋了！原来我这一“忧化”就忧了 4000 μs，超出了火箭实时响应的硬性指标，导致西装骰子人卷款跑路，小彭老师破产。</p>
<p>小彭老师重新创业，这次他选用了稳定的 map，第一次他在 810 μs 内反应了，第二次在 680 μs 内反应了，第三次 730 μs 内反应了，你觉得他很低效。但是他每一次都能成功卡点给你完成任务，从来不会突然超过 O(logN)O(log⁡N)，他的最坏情况是可控的，从而避免了托马斯破产回旋。小彭老师最终创业成功，1000 年后，我司成功建造完成 Type-II 文明所急需的戴森球，向星辰大海进军。</p>
<p>对实时性要求高的这类领域包括，音视频，造火箭，量化交易等。这类低延迟低吞吐量的领域对平摊复杂度很反感，他们只看重最坏的复杂度，而不是平均的。</p>
<p>但对于主打一个高吞吐量无所谓延迟的离线图形学，离线科学计算，实时性不重要的生态化反场景，我们可以认为 unordered_map 的平摊 O(1)+O(1)+ 就是比 map 高效的。</p>
<hr>
<h3 id="区别-3：迭代器失效条件"><a href="#区别-3：迭代器失效条件" class="headerlink" title="区别 3：迭代器失效条件"></a>区别 3：迭代器失效条件</h3><ul>
<li>map 和 unordered_map 都是只有当删除的刚好是迭代器指向的那个元素时才会失效，这点相同。</li>
<li>但 unordered_map 扩容时候的 rehash 操作会造成所有迭代器失效。</li>
</ul>
<blockquote>
<p>insert 可能导致 unordered_map 扩容，其他只读操作不会。</p>
</blockquote>
<p>迭代器指向的那个元素被删除时，不论 map 和 unordered_map 都会失效。</p>
<p>unordered_map 在 insert 时如果发生扩容，之前保存的迭代器可能失效，可以通过调用 reserve 避免 insert 时扩容。</p>
<p>小彭老师编写好了迭代器失效表，方便你记忆:</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>clear</th>
<th>swap</th>
<th>opeartor&#x3D;</th>
<th>rehash</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>map</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>unordered_map</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>容器</th>
<th>find</th>
<th>count</th>
<th>at</th>
<th>[]</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>map</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>unordered_map</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是，如果创建了新元素且 size &#x2F; bucket_count &gt; max_load_factor</td>
</tr>
</tbody></table>
<p>小彭老师编写好了迭代器失效表，方便你记忆:</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>push_back</th>
<th>insert</th>
<th>erase</th>
<th>reserve</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>是，如果 size &gt; capacity</td>
<td>是，如果插入位置在当前迭代器之前，或 size &gt; capacity</td>
<td>是，如果删除的元素在当前迭代器之前，或刚好是当前迭代器指向的</td>
<td>是</td>
</tr>
<tr>
<td>map</td>
<td>-</td>
<td>否</td>
<td>是，如果删除的刚好是当前迭代器指向的元素</td>
<td>-</td>
</tr>
<tr>
<td>unordered_map</td>
<td>-</td>
<td>是，如果 size &#x2F; bucket_count &gt; max_load_factor</td>
<td>是，如果删除的刚好是当前迭代器指向的元素</td>
<td>是</td>
</tr>
</tbody></table>
<p>也可以查看官方版《迭代器失效表》：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container#Iterator_invalidation">https://en.cppreference.com/w/cpp/container#Iterator_invalidation</a></p>
<h3 id="负载率（load-factor）"><a href="#负载率（load-factor）" class="headerlink" title="负载率（load_factor）"></a>负载率（load_factor）</h3><p>计算公式：负载因子(load_factor) &#x3D; 当前元素数量(size) ÷ 当前桶的数量(bucket_count)</p>
<p>插入新元素后，当检测到负载因子大于最大负载因子（默认 1.0）时，就会自动进行 rehash 操作。</p>
<p>为了避免重复小规模扩容浪费时间，这次 rehash 会一次性扩容两倍（跟 vector 的 push_back 扩容类似）。</p>
<blockquote>
<p>最大负载因子可以通过 max_load_factor 函数调整。当前负载因子可以通过 load_factor 函数查询。</p>
</blockquote>
<p>直观理解：当每个桶平均都有一个元素时，unordered_map 就会认为已经很满了，就会扩容并重新分配位置。</p>
<blockquote>
<p>由于默认最大负载因子是 1.0，所以扩容条件等价于 size &gt; bucket_count</p>
</blockquote>
<hr>
<h3 id="rehash-函数"><a href="#rehash-函数" class="headerlink" title="rehash 函数"></a>rehash 函数</h3><p>在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。<a target="_blank" rel="noopener" href="https://142857.red/book/stl_map/#fn:1">1</a></p>
<blockquote>
<p>除了扩容时自动的 rehash，确认数据插入完毕不会再改动时，我们也可以手动调用 rehash() 函数来优化容器中元素的排布，提升性能。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    umap.<span class="built_in">emplace</span>(i, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> pair = umap.<span class="built_in">equal_range</span>(<span class="number">49</span>);  <span class="comment">//获取键为 49 的键值对所在的区间，由于不是 multimap，区间大小只能为 0 或 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123; <span class="comment">//输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">umap.<span class="built_in">rehash</span>(<span class="number">10</span>); <span class="comment">//手动调用 rehash() 函数重哈希为 10 个桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123; <span class="comment">// 重哈希之后，之前保存的迭代器可能会发生变化</span></span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">49</span> </span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="hash-需要特化"><a href="#hash-需要特化" class="headerlink" title="hash 需要特化"></a>hash 需要特化</h3><p>基于红黑树的映射表 map 只需支持比较运算的 less 即可，而 unordered_map 需要哈希和相等两个 trait，他们分别名叫 std::hash 和 std::equal_to。</p>
<p>虽然两者都是仿函数，但也有很多区别：</p>
<ol>
<li>hash 只接受一个参数，而 equal_to 接受两个参数。</li>
<li>hash 返回 size_t，而 equal_to 返回 bool 类型。</li>
<li>equal_to 有默认的实现，那就是调用运算符 &#x3D;&#x3D;。而 hash 没有默认实现，也没相应的运算符，只能手动特化。</li>
</ol>
<p>正因为如此，通常我们需要让一个类（例如 Student）支持 equal_to 或 less 这些有相应运算符的仿函数时，直接在类型内部定义 <code>operator==</code> 或 <code>operator&lt;</code> 即可，而 hash 则是只能用特化的方法才能支持上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;t)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 有待实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="type">const</span> &amp;x, T <span class="type">const</span> &amp;y)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有些类型能用作 map 的键，但不能用作 unordered_map 的键。这是因为偷懒的标准库没对他们的 hash 特化！</p>
<p>例如 tuple 支持 &lt; 运算符，支持 less。</p>
<p>但是 tuple 没有 hash 的特化，不支持 hash。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tup;</span><br><span class="line"><span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(tup);  <span class="comment">// 编译期报错：查无此函数！</span></span><br><span class="line">unordered_map&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="给-tuple-等复合类型自定义哈希函数"><a href="#给-tuple-等复合类型自定义哈希函数" class="headerlink" title="给 tuple 等复合类型自定义哈希函数"></a>给 tuple 等复合类型自定义哈希函数</h3><p>和 less 的情形一样，也是有三种解决方案：</p>
<ol>
<li>自定义一个 hash 的特化，equal_to 的特化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(x.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::equal_to&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Student, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<ol>
<li>自定义一个 hash 的仿函数类，一个 equal_to 的仿函数类，然后传入 unordered_map 做模板参数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(x.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EqualStudent</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x, Student <span class="type">const</span> &amp;y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.name == y.name &amp;&amp; x.id == y.id &amp;&amp; x.sex == y.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Student, <span class="type">int</span>, HashStudent, EqualStudent&gt; stutab;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果 Student 已经定义了 <code>operator==</code>，则这里不用 EqualStudent，默认的 equal_to 会自动调用 &#x3D;&#x3D; 运算符的。</p>
</blockquote>
<ol>
<li>对于 tuple 而言，tuple 已经有了 &#x3D;&#x3D; 运算符，不用特化 equal_to 了，只需要特化或指定 hash 即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) ^ ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<h4 id="试试看效果吧！"><a href="#试试看效果吧！" class="headerlink" title="试试看效果吧！"></a>试试看效果吧！</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) ^ ...); <span class="comment">// 把任意多个元素哈希通过“位异或(^)”拼凑成一个单独的哈希</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// std::apply 会把 tuple 里的元素全部展开来调用 hash_combine，相当于 Python 里的 *args</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">64</span>)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(t);</span><br><span class="line">    <span class="built_in">print</span>(t, <span class="string">&quot;的哈希值是:&quot;</span>, h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">42</span>, <span class="number">64</span>&#125; 的哈希值是: <span class="number">106</span></span><br></pre></td></tr></table></figure>

<p>这里的计算是：42 ^ 64 &#x3D; 106，位异或的知识可以去 Bing 搜索一下，或者问一下 GPT，CS 学生应该都知道的。</p>
<h3 id="更好的-hash-combine"><a href="#更好的-hash-combine" class="headerlink" title="更好的 hash_combine"></a>更好的 hash_combine</h3><p>但是简简单单用一个位异或 ^ 来把两个成员的哈希组合起来，有个严重的问题，如果 <code>tuple&lt;int, int&gt;</code> 里的两个成员值刚好一样，则其两个哈希值也会一样，那么他们通过位异或 ^ 合并的结果就会始终为 0。</p>
<p>例如不论 (42, 42) 还是 (64, 64) 这两个 tuple，他们的哈希值都会为 0。明明具体值不同哈希值却相同，这就是发生了哈希冲突，这会严重影响 unordered_map 的性能，是必须避免的。</p>
<p>用 + 来组合也有这个问题，如果第一个成员刚好是另一个的相反数，或只要是两个数加起来和相等，就会冲突。</p>
<p>例如如果我们用 unordered_map 构建一张地图的话，就发现当玩家在往斜上方移动时就会变得特别卡顿，原来是因为玩家的历史轨迹刚好是一条 y &#x3D; x 的曲线，斜率为 1，由于我们采用 ^ 来组合哈希，就导致刚好这条线上所有的点都会塌缩到 0 号桶去，让 unordered_map 退化成了 O(N)O(N) 复杂度。</p>
<h4 id="最先进的是-boost-hash-combine-的方法"><a href="#最先进的是-boost-hash-combine-的方法" class="headerlink" title="最先进的是 boost::hash_combine 的方法"></a>最先进的是 boost::hash_combine 的方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_combine</span><span class="params">(Ts <span class="type">const</span> &amp;...ts)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">    ((h ^= std::<span class="built_in">hash</span>&lt;Ts&gt;()(ts) + <span class="number">0x9e3779b9</span> + (h &lt;&lt; <span class="number">6</span>) + (h &gt;&gt; <span class="number">2</span>)), ...);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::tuple&lt;Ts...&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::tuple&lt;Ts...&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>(hash_combine&lt;Ts...&gt;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">64</span>)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> h = hash&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(t);</span><br><span class="line">    <span class="built_in">print</span>(t, <span class="string">&quot;的哈希值是:&quot;</span>, h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="number">42</span>, <span class="number">64</span>&#125; 的哈希值是: <span class="number">175247763666</span></span><br></pre></td></tr></table></figure>

<p>可以看到随机性大大提升了。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>用 hash_combine 改进刚刚 Student 的哈希函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;Student&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash_combine</span>(<span class="built_in">hash</span>&lt;string&gt;()(x.name), <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.id), <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(x.sex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理可得 array 的特化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h ^= <span class="built_in">hasher</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<p>采用素数乘方法来提升哈希函数的均匀性和随机性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h = h * <span class="number">18412483</span> + <span class="built_in">hasher</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure>

<p>采用最高级的，基于位运算的，最高效的，boost::hash_combine 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;std::array&lt;T, N&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span> &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::hash&lt;T&gt; hasher;</span><br><span class="line">        <span class="type">size_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span> &amp;t: x) &#123;</span><br><span class="line">            h ^= <span class="built_in">hasher</span>(t) + <span class="number">0x9e3779b9</span> + (h &lt;&lt; <span class="number">6</span>) + (h &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;string, 3&gt;, <span class="type">int</span>&gt; stutab;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ming-z0.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ming-z0.github.io/2024/11/04/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%94%E3%80%81map%E5%92%8C%E4%BB%96%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/">https://ming-z0.github.io/2024/11/04/C++/标准库/五、map和他的朋友们/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ming-z0.github.io" target="_blank">MINGの部落格</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/">开发语言</a></div><div class="post_share"><div class="social-share" data-image="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E6%89%93%E8%B5%8F/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E6%89%93%E8%B5%8F/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/03/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/" title="现代CMake模块化项目指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">现代CMake模块化项目指南</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/09/C++/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/TBB%E5%BC%80%E5%90%AF%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85/" title="TBB开启并行编程之旅"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TBB开启并行编程之旅</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/" title="全面理解STL-前言"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-27</div><div class="title">全面理解STL-前言</div></div></a></div><div><a href="/2024/10/23/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%89%E3%80%81set%E7%B3%BB%E5%88%97%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/" title="全面理解STL-set系列容器与迭代器分类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-27</div><div class="title">全面理解STL-set系列容器与迭代器分类</div></div></a></div><div><a href="/2024/10/21/C++/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/" title="全面理解STL-vector容器与迭代器入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-10-27</div><div class="title">全面理解STL-vector容器与迭代器入门</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC82MDIzOS8zNjcwNw"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ming</div><div class="author-info__description">一个记录、分享自己学习过程的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ming-z0"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ming-z0" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:ming-zhanglu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%81%EF%BC%81%E6%9C%AC%E6%96%87%E5%86%85%E5%AE%B9%E6%90%AC%E8%BF%90%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%8E%B0%E4%BB%A3C-%E5%A4%A7%E5%85%B8%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%85%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E5%A4%87%E4%BB%BD%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%AF%B7%E5%A4%A7%E5%AE%B6%E6%94%AF%E6%8C%81%E5%8E%9F%E4%BD%9C%E8%80%85"><span class="toc-text">！！本文内容搬运小彭老师现代C++大典内容，仅为个人学习备份使用，请大家支持原作者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%9A%E2%9C%9D%EF%B8%8F%E5%B0%8F%E5%BD%AD%E5%A4%A7%E5%85%B8%E2%9C%9D%EF%B8%8F"><span class="toc-text">链接：✝️小彭大典✝️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">数据结构与复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">map 的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0-std-map"><span class="toc-text">为什么要学习 std::map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84-map-%E5%AE%B9%E5%99%A8"><span class="toc-text">标准库中的 map 容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">map 的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text">二叉排序树与二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">二叉树退化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-vs-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">红黑树 vs 平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">平衡树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E7%9A%84%E7%A7%98%E5%AF%86"><span class="toc-text">红黑树实现平衡的秘密</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-map-%E5%AE%B9%E5%99%A8"><span class="toc-text">开始使用 map 容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%80%E5%8C%96%E8%A7%84%E5%88%99%E7%9C%9F%E6%98%AF%E5%AE%B3%E4%BA%BA%E4%B8%8D%E6%B5%85"><span class="toc-text">C 语言的退化规则真是害人不浅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-text">你知道吗？[] 的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%99%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-text">[] 妙用举例：出现次数统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%99%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%BD%92%E7%B1%BB"><span class="toc-text">[] 妙用举例：归类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-1"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%99%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">[] 妙用举例：线程局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8D%E5%90%91%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">为什么需要反向查找表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E6%9E%84%E5%BB%BA%E4%B8%8B%E6%A0%87%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">map 构建下标查找表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E6%9E%84%E5%BB%BA%E5%8F%A6%E4%B8%80%E4%B8%AA-map-%E7%9A%84%E5%8F%8D%E5%90%91%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-text">map 构建另一个 map 的反向查找表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E6%9F%A5%E8%AF%A2%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%EF%BC%9Avalue-type"><span class="toc-text">元编程查询成员类型：value_type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typename-%E4%BF%AE%E9%A5%B0"><span class="toc-text">typename 修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E5%A4%A7%E6%B3%95%E5%A5%BD"><span class="toc-text">decltype 大法好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%90%8D%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="toc-text">查询类名小工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">map 真正的元素类型究竟是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-%E5%92%8C-contains-%E6%B2%A1%E5%8C%BA%E5%88%AB"><span class="toc-text">count 和 contains 没区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#end-%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-text">end 不能解引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">find 的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-17-%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">C++17 语法糖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-text">题外话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-map-%E8%80%8C%E8%A8%80%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AF-pair"><span class="toc-text">对 map 而言，迭代器解引用得到的是 pair</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%BE%B9%E9%81%8D%E5%8E%86%E4%B8%80%E8%BE%B9%E5%88%A0%E9%99%A4%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0"><span class="toc-text">一边遍历一边删除部分元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-20-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%9Aerase-if"><span class="toc-text">C++20 更好的写法：erase_if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-or-assign"><span class="toc-text">insert_or_assign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-or-assign-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">insert_or_assign 的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="toc-text">效率问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">[]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-or-assign-1"><span class="toc-text">insert_or_assign</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%88%91%E5%BA%94%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88"><span class="toc-text">那我应该用什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-or-assign-vs-insert%EF%BC%9A%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">insert_or_assign vs insert：顺序问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-insert"><span class="toc-text">批量 insert</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-insert-%E5%90%8C%E6%A0%B7%E9%81%B5%E5%BE%AA%E4%B8%8D%E8%A6%86%E7%9B%96%E5%8E%9F%E5%88%99"><span class="toc-text">批量 insert 同样遵循不覆盖原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-insert-%E5%AE%9E%E7%8E%B0-map-%E5%90%88%E5%B9%B6"><span class="toc-text">批量 insert 实现 map 合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E5%9C%B0%E5%86%99%E5%85%A5%EF%BC%81"><span class="toc-text">就地写入！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-insert-%E4%BC%98%E5%85%88%E4%BF%9D%E7%95%99%E5%B7%B2%E7%BB%8F%E6%9C%89%E7%9A%84"><span class="toc-text">批量 insert 优先保留已经有的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%EF%BC%9A%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%AD%89"><span class="toc-text">其他操作：交集、并集、差集等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-%E4%B8%80%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">insert 一个初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E9%94%90%E8%AF%84%E6%89%B9%E9%87%8F-insert-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">小彭老师锐评批量 insert 有什么用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-%E4%B9%9F%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">operator&#x3D; 也支持初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="toc-text">赋值函数和构造函数概念辨析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assign-%E5%87%BD%E6%95%B0"><span class="toc-text">assign 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E6%8F%90%E7%A4%BA%E7%9A%84-insert"><span class="toc-text">带插入位置提示的 insert</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA"><span class="toc-text">复杂度分类讨论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AD%A6%E7%94%9F%E7%9A%84%E8%B6%A3%E5%91%B3%E6%97%A9%E6%93%8D"><span class="toc-text">小学生的趣味早操</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AD%A6%E7%94%9F%E6%9D%A5%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%BA%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">小学生来的顺序已经有序的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%A5%B4-emplace"><span class="toc-text">分奴 emplace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace-hint"><span class="toc-text">emplace_hint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E7%82%B9"><span class="toc-text">emplace 的原理和优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-emplace-%E6%9B%B4%E5%A5%BD"><span class="toc-text">try_emplace 更好</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-emplace-%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E7%A7%BB%E5%8A%A8%EF%BC%81"><span class="toc-text">try_emplace 可以避免移动！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-try-emplace-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">谈谈 try_emplace 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">什么是聚合初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-20-%E4%BF%AE%E5%A4%8D%E4%BA%86%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9C%86%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">C++20 修复了聚合初始化不支持圆括号的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90"><span class="toc-text">调用开销分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-emplace-%E6%88%90%E5%8A%9F%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">try_emplace 成功提升性能的案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E6%8F%90%E7%A4%BA%E7%9A%84-try-emplace"><span class="toc-text">带插入位置提示的 try_emplace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace-%E5%AE%B6%E6%97%8F%E6%80%BB%E7%BB%93"><span class="toc-text">emplace 家族总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E4%B8%8E-RAII"><span class="toc-text">map 与 RAII</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9A%E8%B5%84%E6%BA%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%A7%BB%E5%8A%A8"><span class="toc-text">案例 1：资源类可以移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9A%E8%B5%84%E6%BA%90%E7%B1%BB%E7%A6%81%E6%AD%A2%E7%A7%BB%E5%8A%A8"><span class="toc-text">案例 2：资源类禁止移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BE%97%E5%88%A0%E9%99%A4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">记得删除移动构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E4%BA%A4%E7%BB%99%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86"><span class="toc-text">统一交给智能指针管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%B8%AE%E4%BD%A0%E9%81%BF%E5%85%8D%E7%A7%BB%E5%8A%A8"><span class="toc-text">智能指针帮你避免移动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%80%BB%E7%BB%93"><span class="toc-text">增删改查总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0"><span class="toc-text">增删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E6%9F%A5"><span class="toc-text">改查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8F%A5%E6%9F%84%E7%B3%BB%E5%88%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">节点句柄系列接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extract"><span class="toc-text">extract</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94%E4%B8%BE%E4%BE%8B"><span class="toc-text">用途举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-%E8%8A%82%E7%82%B9%E7%89%88"><span class="toc-text">insert 节点版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-return-type"><span class="toc-text">insert_return_type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extract-insert-%E8%BF%90%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">extract + insert 运用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extract-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-text">extract 性能优化案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E7%A6%BB%E8%8A%82%E7%82%B9%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E9%94%AE%E5%80%BC"><span class="toc-text">游离节点可以修改键值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%8F%90%E7%A4%BA%E7%9A%84%E8%8A%82%E7%82%B9%E7%89%88-insert"><span class="toc-text">带提示的节点版 insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%EF%BC%9Amap-%E7%9A%84%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B9%B6%E9%9B%86%EF%BC%89"><span class="toc-text">merge：map 的合并操作（并集）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-insert-vs-merge"><span class="toc-text">批量 insert vs merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#merge-%E5%92%8C-insert-%E4%B8%80%E6%A0%B7%E4%B8%8D%E8%A6%86%E7%9B%96%E6%97%A7%E5%80%BC"><span class="toc-text">merge 和 insert 一样不覆盖旧值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">map 自定义比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-less-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">std::less 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#operator"><span class="toc-text">operator()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">自定义排序方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E9%9C%80%E8%A6%81%E5%B0%8F%E4%BA%8E%E5%8F%B7"><span class="toc-text">只需要小于号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%8F%E4%BA%8E%E5%8F%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">自定义小于号的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E5%93%AA%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%9D%A5%E7%B4%A2%E5%BC%95"><span class="toc-text">自定义按哪个字段来索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-20-%E4%B8%89%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">C++20 三路运算符 &lt;&#x3D;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="toc-text">仿函数运算符全家桶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#greater-%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E6%8E%92%E5%BA%8F"><span class="toc-text">greater 实现反向排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">大小写不敏感的字符串比较器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5-lambda-%E5%81%9A%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">传入 lambda 做比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E5%85%A5%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84"><span class="toc-text">map 构造函数是如何传入比较器的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%88%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">有状态（捕获变量）的比较器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E7%94%A8-function"><span class="toc-text">建议用 function</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E-map"><span class="toc-text">透明 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%8F%E6%98%8E%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">什么是透明仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%80%8F%E6%98%8E%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">为什么需要透明仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%89%88%E7%9A%84-find-%E5%87%BD%E6%95%B0"><span class="toc-text">泛型版的 find 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-find-%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%9A%E9%80%8F%E6%98%8E"><span class="toc-text">泛型 find 的要求：透明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E9%94%AE%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-text">应用：字符串为键的字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%BA%E9%94%AE%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-text">应用：智能指针为键的字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E8%B6%85%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%BA%E9%94%AE%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-text">应用：超大对象为键的字典</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%9A%84-multimap"><span class="toc-text">神奇的 multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F"><span class="toc-text">元素的排列顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A%E5%8A%A8%E6%80%81%E6%8E%92%E5%BA%8F%EF%BC%81"><span class="toc-text">用途：动态排序！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E9%94%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-text">查询某个键对应的多个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lower-upper-bound-%E5%AE%9E%E7%8E%B0%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">lower&#x2F;upper_bound 实现范围查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93%E8%AF%B4%E6%98%8E"><span class="toc-text">时间复杂度总结说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-unordered-map"><span class="toc-text">哈希表 unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-map-%E4%B8%8E-map-%E4%B9%8B%E4%BA%89%EF%BC%9A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C"><span class="toc-text">unordered_map 与 map 之争：适用场景不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9Aunordered-map-%E4%B8%AD%E7%9A%84%E2%80%9C%E6%A1%B6%E2%80%9D"><span class="toc-text">原理：unordered_map 中的“桶”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-hash-collision"><span class="toc-text">哈希冲突 (hash-collision)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map-%E4%B8%8E-map-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">unordered_map 与 map 的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1%EF%BC%9A%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">区别 1：有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-%E5%92%8C-equal-to"><span class="toc-text">hash 和 equal_to</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-text">哈希函数的思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%96%E6%A8%A1"><span class="toc-text">自动取模</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-%E6%98%AF%E4%B8%AA-trait-%E7%B1%BB"><span class="toc-text">hash 是个 trait 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">区别 2：时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-text">哈希表的复杂度不稳定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E9%99%90%E5%88%B6"><span class="toc-text">哈希表的应用限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E6%9D%A1%E4%BB%B6"><span class="toc-text">区别 3：迭代器失效条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E7%8E%87%EF%BC%88load-factor%EF%BC%89"><span class="toc-text">负载率（load_factor）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash-%E5%87%BD%E6%95%B0"><span class="toc-text">rehash 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-%E9%9C%80%E8%A6%81%E7%89%B9%E5%8C%96"><span class="toc-text">hash 需要特化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99-tuple-%E7%AD%89%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text">给 tuple 等复合类型自定义哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%95%E8%AF%95%E7%9C%8B%E6%95%88%E6%9E%9C%E5%90%A7%EF%BC%81"><span class="toc-text">试试看效果吧！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-hash-combine"><span class="toc-text">更好的 hash_combine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%85%88%E8%BF%9B%E7%9A%84%E6%98%AF-boost-hash-combine-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">最先进的是 boost::hash_combine 的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/10/C++/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" title="深入浅出访存优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入浅出访存优化"/></a><div class="content"><a class="title" href="/2024/11/10/C++/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" title="深入浅出访存优化">深入浅出访存优化</a><time datetime="2024-11-16T10:30:37.710Z" title="更新于 2024-11-16 18:30:37">2024-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/" title="现代CMake模块化项目指南"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代CMake模块化项目指南"/></a><div class="content"><a class="title" href="/2024/11/03/C++/CMake/%E7%8E%B0%E4%BB%A3%E5%8C%96CMake%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/" title="现代CMake模块化项目指南">现代CMake模块化项目指南</a><time datetime="2024-11-09T14:23:37.770Z" title="更新于 2024-11-09 22:23:37">2024-11-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Ming</div><div class="footer_custom_text">Hi, 欢迎你来！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Twikoo' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="12875524711" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-volume="0.4" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="97,255,145" opacity="0.7" zIndex="-1" count="88" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "b178ba69-5256-414b-adab-10306c2edf59";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => {
      $crisp.push(["do", "chat:hide"])
    }

    close()
    $crisp.push(["on", "chat:closed", function() {
      close()
    }])

    window.chatBtnFn = () => {
      $crisp.is("chat:visible") ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        $crisp.push(["do", "chat:hide"])
      },
      show: () => {
        $crisp.push(["do", "chat:show"])
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>